<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LendSight - JustData</title>
    <meta name="description" content="HMDA Mortgage Lending Analysis Report - Comprehensive mortgage market intelligence">
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='favicon.png') }}">
    <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='favicon-32x32.png') }}">
    <link rel="icon" type="image/png" sizes="16x16" href="{{ url_for('static', filename='favicon-16x16.png') }}">
    <!-- Skip to main content link for screen readers -->
    <style>
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #1e3a5f;
            color: white;
            padding: 8px;
            text-decoration: none;
            z-index: 100;
        }
        .skip-link:focus {
            top: 0;
        }
    </style>
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="LendSight - Mortgage Lending Analysis Report">
    <meta property="og:description" content="Comprehensive HMDA mortgage lending analysis report">
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <!-- Set base URL for API calls -->
    <script>
        window.APP_BASE_URL = '{{ app_base_url|default("/lendsight") }}';
    </script>
    
    <style>
        /* Print-specific styles for PDF export - optimized for readability */
        @media print {
            .no-print { display: none !important; }
            /* Eliminate all page breaks - content flows naturally */
            .print-break { page-break-before: auto; }
            
            /* Base typography - improved readability */
            body { 
                font-size: 11pt; 
                line-height: 1.4;
                margin: 0;
                padding: 0;
                color: #333;
            }
            
            html {
                margin: 0;
                padding: 0;
            }
            
            /* Report container - reduce padding for more content per page */
            .report-container {
                padding: 15px;
                max-width: 100%;
            }
            
            /* Section spacing - tighter but readable */
            .report-section { 
                margin-bottom: 15px;
                padding: 0;
                page-break-inside: auto;
            }
            
            /* Section titles - clear hierarchy */
            .section-title {
                font-size: 14pt;
                font-weight: 600;
                margin-bottom: 6px;
                margin-top: 0;
                color: #1a1a1a;
            }
            
            /* Table introduction - readable paragraph spacing */
            .table-introduction {
                font-size: 10.5pt;
                line-height: 1.5;
                margin-bottom: 6px;
                margin-top: 0;
                orphans: 2;
                widows: 2;
            }
            
            /* Table description - smaller but readable */
            .table-description {
                font-size: 9.5pt;
                line-height: 1.4;
                color: #555;
                margin-bottom: 6px;
                margin-top: 0;
            }
            
            /* Table container - proper spacing */
            .table-container {
                margin-top: 0;
                margin-bottom: 8px;
            }
            
            /* Tables - improved readability, allow breaking if needed */
            table {
                border-collapse: collapse;
                margin: 0;
                width: 100%;
                font-size: 9pt;
                line-height: 1.3;
            }
            
            /* Table headers - clear and readable */
            th {
                background-color: #f5f5f5 !important;
                font-weight: 600;
                padding: 6px 8px;
                border: 1px solid #ddd;
                text-align: left;
                font-size: 9pt;
            }
            
            /* Table cells - proper spacing, allow breaking if needed */
            td {
                padding: 5px 8px;
                border: 1px solid #e0e0e0;
                font-size: 9pt;
            }
            
            /* Table caption - readable but smaller */
            .table-caption {
                font-size: 8.5pt;
                line-height: 1.4;
                color: #666;
                margin-top: 4px;
                margin-bottom: 0;
            }
            
            /* Table narrative - readable text blocks */
            .table-narrative {
                font-size: 10pt;
                line-height: 1.6;
                margin-top: 12px;
                margin-bottom: 0;
                orphans: 3;
                widows: 3;
            }
            
            /* Report header - compact */
            .report-header {
                margin-bottom: 12px;
            }
            
            /* AI content sections */
            .ai-insight-card {
                margin-bottom: 12px;
            }
            
            .ai-content {
                font-size: 10pt;
                line-height: 1.6;
            }
            
            /* Introduction, population demographics, and key findings - allow natural flow */
            #aiIntroParagraphSection {
                margin-bottom: 12px;
            }
            
            /* Population Demographics section */
            #demographicOverviewTableSection {
                margin-bottom: 12px;
            }
            
            /* Key Findings section */
            #aiKeyFindingsSection {
                margin-bottom: 12px;
            }
            
            /* Reduce excessive white space between sections */
            .report-section.print-break {
                margin-top: 20px;
            }
            
            /* Headings hierarchy */
            h1 { font-size: 16pt; font-weight: 700; margin: 0 0 10px 0; }
            h2 { font-size: 14pt; font-weight: 600; margin: 0 0 8px 0; }
            h3 { font-size: 12pt; font-weight: 600; margin: 0 0 6px 0; }
            
            /* Paragraphs */
            p {
                margin: 0 0 8px 0;
                line-height: 1.5;
            }
            
            /* Lists */
            ul, ol {
                margin: 0 0 8px 0;
                padding-left: 20px;
            }
            
            li {
                margin-bottom: 4px;
                line-height: 1.5;
            }
        }
        
        /* Report-specific styles */
        body {
            padding: 20px;
            background: #f5f5f5;
        }
        
        .report-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            box-sizing: border-box;
        }
        
        @media (max-width: 1240px) {
            body {
                padding: 20px 10px;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            /* Stack intro and chart on mobile */
            #introAndCensusSection > div {
                flex-direction: column !important;
            }
            
            #introAndCensusSection > div > div {
                flex: 1 1 100% !important;
            }
            
            /* Stack intro and table on mobile for Section 1 and 2 */
            .report-section > div[style*="display: flex"] {
                flex-direction: column !important;
            }
            
            .report-section > div[style*="display: flex"] > div {
                flex: 1 1 100% !important;
            }
        }
        
        /* Table column width styles for Section 1 and 2 */
        #demographicOverviewTable {
            table-layout: auto;
        }

        #demographicOverviewTable th:first-child,
        #demographicOverviewTable td:first-child {
            white-space: nowrap;
            width: auto;
            min-width: 0;
        }

        #demographicOverviewTable th:not(:first-child),
        #demographicOverviewTable td:not(:first-child) {
            width: 100px;
            min-width: 100px;
        }
        
        .report-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px 20px;
            background: #1e3a5f;
            color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .report-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: white;
            margin-bottom: 10px;
        }
        
        .report-subtitle {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 20px;
        }
        
        .report-meta {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 20px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.95);
            text-align: left;
        }
        
        .report-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .action-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            color: #333;
            text-decoration: none;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }
        
        .action-btn:hover {
            background: #f5f5f5;
            border-color: #999;
        }
        
        .action-btn.primary {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        .action-btn.primary:hover {
            background: #218838;
            border-color: #218838;
        }

        /* Excel export button specific hover */
        #downloadExcelBtn:hover {
            background: #218838 !important;
        }

        /* PDF export button hover */
        #downloadPdfBtn:hover {
            background: #0f2440 !important;
        }
        
        .dropdown {
            position: relative;
            display: inline-block;
        }
        
        .dropdown-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 180px;
            z-index: 1000;
            display: none;
        }
        
        .dropdown:hover .dropdown-menu {
            display: block;
        }
        
        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            color: #333;
            text-decoration: none;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s ease;
        }
        
        .dropdown-item:last-child {
            border-bottom: none;
        }
        
        .dropdown-item:hover {
            background: #f8f9fa;
            color: #333;
        }
        
        .ai-insights {
            display: grid;
            gap: 20px;
        }
        
        .ai-insight-card {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            transition: box-shadow 0.2s ease;
        }
        
        .ai-insight-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .ai-insight-card h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ai-insight-card h3 i {
            color: #1e3a5f;
        }
        
        .ai-content {
            line-height: 1.6;
            color: #555;
        }
        
        .ai-content p {
            margin: 0 0 15px 0;
        }
        
        .ai-content p:last-child {
            margin-bottom: 0;
        }
        
        .report-section {
            margin-bottom: 40px;
        }
        
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .table-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 8px;
            padding-bottom: 5px;
        }
        
        .table-description {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 15px;
            line-height: 1.4;
            font-style: italic;
        }
        
        .table-introduction {
            font-size: 1rem;
            color: #333;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .table-source {
            font-size: 0.75rem;
            color: #888;
            margin-top: 8px;
            font-style: normal;
        }
        
        .table-caption {
            font-size: 0.85rem;
            color: #666;
            margin-top: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-left: 3px solid #1e3a5f;
            border-radius: 4px;
            line-height: 1.6;
        }
        
        .table-caption strong {
            color: #1e3a5f;
            font-weight: 600;
        }
        
        .table-narrative {
            margin-top: 25px;
            font-size: 1rem;
            line-height: 1.7;
            color: #333;
        }
        
        .table-narrative p {
            margin-bottom: 15px;
        }
        
        .table-narrative p:last-child {
            margin-bottom: 0;
        }
        
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .summary-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }
        
        .summary-card h3 {
            font-size: 2rem;
            font-weight: 700;
            color: #003366;
            margin: 0 0 10px 0;
        }
        
        .summary-card h3 .percentage-text {
            font-size: 1.2rem;
            font-weight: 500;
            color: #666;
        }
        
        .summary-card p {
            margin: 0;
            color: #666;
            font-size: 0.9rem;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .data-table th {
            background: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #e0e0e0;
            vertical-align: middle;
        }
        
        .data-table th[role="button"] {
            position: relative;
            transition: background-color 0.2s ease;
        }
        
        .data-table th[role="button"]:hover {
            background: #e9ecef;
        }
        
        .data-table th[role="button"]:focus {
            outline: 2px solid #1e3a5f;
            outline-offset: -2px;
        }
        
        .sort-indicator {
            display: inline-block;
            margin-left: 4px;
            color: #1e3a5f;
            font-size: 0.85em;
        }
        
        .data-table td {
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .data-table tr:hover {
            background: #f8f9fa;
        }
        
        .data-table tr:last-child td {
            border-bottom: none;
        }
        
        .table-container {
            position: relative;
            overflow-x: auto;
        }
        
        .table-header {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 10px;
        }
        
        .collapse-btn {
            background: #f8f9fa;
            border: 1px solid #ddd;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            color: #666;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .collapse-btn:hover {
            background: #e9ecef;
            border-color: #999;
        }
        
        .collapse-btn i {
            transition: transform 0.2s ease;
        }
        
        .collapse-btn.collapsed i {
            transform: rotate(-90deg);
        }
        
        .collapsible-table {
            transition: all 0.3s ease;
        }
        
        .collapsible-table.collapsed {
            position: relative;
        }
        
        .collapsible-table.collapsed tbody {
            position: relative;
        }
        
        .collapsible-table.collapsed tbody::after {
            content: '... more rows available';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(transparent, rgba(255,255,255,0.9), white);
            pointer-events: none;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 10px;
            font-size: 0.8rem;
            color: #666;
            font-style: italic;
        }
        
        .collapsible-table.collapsed tbody tr:nth-child(n+4) {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: #1e3a5f;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            margin-bottom: 20px;
            transition: background 0.2s ease;
        }
        
        .back-btn:hover {
            background: #2fade3;
            color: white;
        }
        
        @media (max-width: 768px) {
            .report-container {
                padding: 10px;
            }
            
            .report-title {
                font-size: 2rem;
            }
            
            .report-meta {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .data-table {
                font-size: 0.8rem;
            }
            
            .data-table th,
            .data-table td {
                padding: 8px;
            }
        }

        /* ========== Unified Data Table Component ========== */
        .unified-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 0.9rem;
        }
        .unified-table th {
            background: #2C5F8A;
            color: white;
            padding: 10px 8px;
            text-align: center;
            font-weight: 600;
            font-size: 0.85rem;
            border-bottom: 2px solid #1E3D5C;
            white-space: nowrap;
        }
        .unified-table th:first-child {
            text-align: left;
        }
        .unified-table td {
            padding: 8px;
            border-bottom: 1px solid #e0e0e0;
            text-align: center;
            font-size: 0.85rem;
            vertical-align: middle;
        }
        .unified-table td:first-child {
            text-align: left;
            white-space: nowrap;
        }
        .unified-table tr:hover {
            background-color: rgba(26, 143, 201, 0.04);
        }
        .unified-table .total-row {
            background: #f0f0f0 !important;
            font-weight: 600;
            border-bottom: 2px solid #CBD5E1;
        }
        .unified-table .total-row:hover {
            background: #e8e8e8 !important;
        }
        .unified-table .aggregate-row {
            background: #F0F4F8 !important;
            font-weight: 600;
            border-top: 2px solid #CBD5E1;
        }
        .unified-table .aggregate-row:hover {
            background: #e4ebf1 !important;
        }
        .unified-table .aggregate-row td:first-child {
            padding-left: 10px;
        }
        .unified-table .detail-row td:first-child {
            padding-left: 24px;
            position: relative;
        }
        .unified-table .detail-row td:first-child::before {
            content: '';
            position: absolute;
            left: 10px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(26, 143, 201, 0.3);
        }
        .unified-table .census-boundary {
            border-left: 2px solid rgba(51, 51, 51, 0.4) !important;
        }
        .unified-table .census-label-row th {
            background: transparent !important;
            color: #666;
            font-size: 0.7em;
            font-weight: normal;
            padding: 2px 4px;
            border: none;
            border-bottom: none;
        }
        .unified-table .sparkline-cell {
            padding: 4px 6px;
            vertical-align: middle;
        }
        .unified-table .change-cell {
            white-space: nowrap;
            font-weight: 600;
            font-size: 0.85rem;
        }
        .unified-table .change-positive { color: #2E7D32; }
        .unified-table .change-negative { color: #C62828; }
        .unified-table .change-neutral { color: #666; }
        .unified-table .share-bar-cell {
            padding: 4px 8px;
            min-width: 170px;
        }
        .share-bar-container {
            display: flex;
            flex-direction: column;
            gap: 3px;
            width: 170px;
        }
        .share-bar-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .share-bar {
            height: 14px;
            border-radius: 3px;
            min-width: 2px;
        }
        .share-bar-label {
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
        }

        /* Mobile responsive - simplified view below 1024px portrait */
        @media (max-width: 1024px) and (orientation: portrait) {
            .unified-table .year-col:not(.year-latest) {
                display: none;
            }
            .unified-table .pop-share-col {
                display: none;
            }
            .unified-table .share-bar-cell,
            .unified-table th.share-bar-col {
                display: none;
            }
            .unified-table .census-label-row {
                display: none;
            }
            .unified-table th,
            .unified-table td {
                padding: 8px 6px;
                font-size: 0.8rem;
            }
        }

        /* Print: show all unified table columns */
        @media print {
            .unified-table th {
                background-color: #f5f5f5 !important;
                color: #333 !important;
            }
            .unified-table .year-col:not(.year-latest),
            .unified-table .pop-share-col,
            .unified-table .share-bar-cell,
            .unified-table th.share-bar-col {
                display: table-cell !important;
            }
        }

        /* Tab/Overview CSS removed — report loads directly into full view */

        /* Top Lenders table — force uniform header alignment */
        #topLendersDetailedTable th {
            vertical-align: middle !important;
            padding-top: 8px !important;
            padding-bottom: 8px !important;
            line-height: 1.2 !important;
        }

        /* Header logo replacement — hide text, show logo via ::before */
        .app-branding .app-name {
            visibility: hidden;
            position: relative;
            display: inline-block;
            width: 140px;
            height: 30px;
            vertical-align: middle;
        }
        .app-branding .app-name::before {
            visibility: visible;
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            display: block;
            width: 140px;
            height: 30px;
            background: url('/static/img/app-logos/lendsight-white.png') no-repeat center / contain;
        }
    </style>
</head>
<body style="background: var(--ncrc-gray-light);">
    <!-- Report Interstitial Modal - shows while data loads -->
    {% include "report_interstitial.html" %}

    {% include "shared_header.html" %}

    <div class="report-container">
        <!-- Header Actions Row -->
        <div class="report-actions-row no-print" style="display: flex; justify-content: flex-end; align-items: center; gap: 12px; margin-bottom: 20px; padding: 10px 0;">
            <a href="{{ app_base_url|default('/lendsight') }}/download?format=pdf" class="action-btn" id="downloadPdfBtn" style="text-decoration: none; cursor: pointer; padding: 12px 24px; background: #1e3a5f; color: white; border-radius: 5px; display: inline-flex; align-items: center; gap: 8px; font-weight: 500; transition: background-color 0.2s;">
                <i class="fas fa-file-pdf"></i> Download PDF Report
            </a>
            <a href="{{ app_base_url|default('/lendsight') }}/download?format=excel" class="action-btn primary" id="downloadExcelBtn" style="text-decoration: none; cursor: pointer; padding: 12px 24px; background: #28a745; color: white; border-radius: 5px; display: inline-flex; align-items: center; gap: 8px; font-weight: 500; transition: background-color 0.2s;">
                <i class="fas fa-file-excel"></i> Export Full Report to Excel
            </a>
        </div>

        <!-- Loading State -->
        <div id="loadingState" class="loading">
            <i class="fas fa-spinner fa-spin fa-2x"></i>
            <p>Loading report data...</p>
        </div>
        
        <!-- Error State -->
        <div id="errorState" class="error" style="display: none;">
            <h3><i class="fas fa-exclamation-triangle"></i> Error Loading Report</h3>
            <p id="errorMessage"></p>
        </div>
        
        <div class="report-header" style="text-align: center; margin-bottom: 30px; padding: 20px; background: var(--ncrc-dark-blue); color: white; border-radius: 8px;">
            <h1 style="margin: 0 0 10px 0;">Mortgage Lending Analysis</h1>
            <p id="reportMetadata" style="margin: 10px 0 0 0; opacity: 0.9;">
                <span id="counties">Loading...</span> | <span id="years">Loading...</span>
            </p>
        </div>
        
            <!-- Report Content -->
            <main id="main-content" style="display: none;" role="main">

            <!-- Report Content (no tabs — loads directly) -->
            <!-- Intro Paragraph and Census Chart - Side by Side -->
            <div class="report-section print-break" id="introAndCensusSection" style="display: none;">
                <div style="display: flex; gap: 20px; align-items: flex-start;">
                    <!-- Intro Paragraph - 1/3 width -->
                    <div style="flex: 0 0 33.333%;">
                        <div class="ai-insight-card">
                            <div class="ai-content" id="introParagraphContent">
                                <!-- AI content will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Census Chart - 2/3 width -->
                    <div style="flex: 0 0 66.667%;">
                        <h2 class="section-title">Population Demographics</h2>
                        <div style="position: relative; height: 400px;">
                            <canvas id="censusChart"></canvas>
                        </div>
                        <div id="censusChartTotals" style="margin-top: 10px; text-align: center; font-size: 0.9em; color: #666;">
                            <!-- Total population for each year will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Census Boundaries Callout -->
            <div class="report-section" id="censusBoundariesCallout" style="display: none; margin-top: 15px; padding: 15px; background-color: #f0f7ff; border-left: 4px solid #1e3a5f; border-radius: 4px;">
                <p style="margin: 0; font-size: 0.95em; line-height: 1.6;">
                    <strong>Note:</strong> It is important to note that shifting census boundaries that took effect in 2022 resulted in a 30% increase in the number of majority-minority census tracts nationally. The vast majority of these newly designated majority-minority tracts are not low-to-moderate income tracts.
                </p>
            </div>
            
            <!-- AI Key Findings -->
            <div class="report-section print-break" id="aiKeyFindingsSection" style="display: none;">
                <h2 class="section-title">Key Findings</h2>
                <div class="ai-insight-card">
                    <div class="ai-content" id="keyFindingsContent" style="line-height: 1.8;">
                        <!-- AI content will be populated by JavaScript -->
                    </div>
                </div>
                <p style="margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
            </div>
            
            <!-- Population Demographics Table Caption (moved below Key Findings) -->
            <div class="report-section" id="populationDemographicsCaptionSection" style="display: none;">
                <p class="table-caption" id="populationDemographicsCaption">
                    <strong>Source:</strong> U.S. Census Bureau American Community Survey (ACS) 5-year estimates. Data represents the most recent available ACS 5-year period and is shown for reference years in the analysis. Groups representing less than 1% of the total population are excluded from this table.
                </p>
            </div>
            
            <style>
                #keyFindingsContent ul {
                    margin: 0;
                    padding-left: 20px;
                }
                #keyFindingsContent ul li {
                    margin-bottom: 12px;
                    padding-left: 1.5em;
                    text-indent: -1.5em;
                }
                #keyFindingsContent ul li:last-child {
                    margin-bottom: 0;
                }
            </style>
            
            <!-- Section 1: Loans by Race and Ethnicity -->
            <div class="report-section print-break">
                <h2 class="section-title">Section 1: Loans by Race and Ethnicity</h2>
                <h3 style="margin-top: 20px; margin-bottom: 15px; font-size: 1.2em; color: var(--ncrc-dark-blue);">Table 1: Loans by Race and Ethnicity</h3>
                <p class="table-introduction" id="demographicOverviewIntro" style="margin-bottom: 20px; max-width: 100%;">
                    <!-- Introduction will be populated by JavaScript -->
                </p>
                <div class="table-container" style="width: 100%;">
                    <table class="data-table" id="demographicOverviewTable" role="table" aria-label="Demographic Overview Lending Data">
                        <thead>
                            <tr role="row">
                                <th style="text-align: left; width: 240px;" role="columnheader" scope="col">Race / Ethnicity</th>
                            </tr>
                        </thead>
                        <tbody role="rowgroup">
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                    <div style="margin-top: 6px; font-size: 0.8em; color: #666;">
                        <span style="display: inline-block; width: 10px; height: 10px; background: #E07C39; border-radius: 2px; vertical-align: middle; margin-right: 3px;"></span> Population Share
                        <span style="display: inline-block; width: 10px; height: 10px; background: #1a8fc9; border-radius: 2px; vertical-align: middle; margin-left: 12px; margin-right: 3px;"></span> Lending Share
                    </div>
                    <p class="table-caption" id="demographicOverviewCaption">
                        <!-- Caption will be populated by JavaScript -->
                    </p>
                </div>
                <div class="table-narrative" id="demographicOverviewDiscussion">
                    <!-- Discussion will be populated by JavaScript -->
                </div>
                <p id="demographicOverviewAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
            </div>
            
            <!-- Section 2: Income and Neighborhood Indicators -->
            <div class="report-section print-break">
                <h2 class="section-title">Section 2: Income and Neighborhood Indicators</h2>
                
                <!-- Table 1: Lending to Income Borrowers -->
                <h3 style="margin-top: 20px; margin-bottom: 15px; font-size: 1.2em; color: var(--ncrc-dark-blue);">Table 1: Lending to Income Borrowers</h3>
                <p class="table-introduction" id="incomeBorrowersIntro" style="margin-bottom: 20px; max-width: 100%;">
                    This table shows lending activity by borrower income level over the selected time period. Borrower income is classified relative to the area median family income (AMFI) for the Metropolitan Statistical Area (MSA) or Metropolitan Division (MD) in which the property is located. Income thresholds are determined using FFIEC median family income data. Population share refers to the percentage of the county residents that are in each income bracket as of 2020.
                </p>
                <div class="table-container" style="width: 100%;">
                    <table class="data-table" id="incomeBorrowersTable">
                        <thead>
                            <tr>
                                <th style="text-align: left; width: 240px;">Borrower Income</th>
                                <!-- Year columns will be added dynamically by JavaScript -->
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div class="table-narrative" id="incomeBorrowersDiscussion" style="margin-top: 20px;">
                    <!-- AI narrative will be populated by JavaScript -->
                </div>
                <p id="incomeBorrowersAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
                
                <!-- Table 2: Lending to Census Tracts by Income Level -->
                <h3 style="margin-top: 40px; margin-bottom: 15px; font-size: 1.2em; color: var(--ncrc-dark-blue);">Table 2: Lending to Census Tracts by Income Level</h3>
                <p class="table-introduction" id="incomeTractsIntro" style="margin-bottom: 20px; max-width: 100%;">
                    This table shows lending activity by census tract income level over the selected time period. Census tract income is classified relative to the area median family income, as defined by HUD. The table shows lending to Low to Moderate Income Census Tracts (≤80% of AMFI) and their breakdown by Low Income (≤50% of AMFI), Moderate Income (>50% and ≤80% of AMFI), Middle Income (>80% and ≤120% of AMFI), and Upper Income (>120% of AMFI) census tracts. <strong>Note:</strong> Between 2021 and 2022, boundary changes dramatically increased the number of tracts with higher minority populations.
                </p>
                <div class="table-container" style="width: 100%;">
                    <table class="data-table" id="incomeTractsTable">
                        <thead>
                            <tr>
                                <th style="text-align: left; width: 240px;">Tract Median Income</th>
                                <!-- Year columns will be added dynamically by JavaScript -->
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div class="table-narrative" id="incomeTractsDiscussion" style="margin-top: 20px;">
                    <!-- AI narrative will be populated by JavaScript -->
                </div>
                <p id="incomeTractsAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
                
                <!-- Table 3: Lending to Census Tracts by Minority Population -->
                <h3 style="margin-top: 40px; margin-bottom: 15px; font-size: 1.2em; color: var(--ncrc-dark-blue);">Table 3: Lending to Census Tracts by Minority Population</h3>
                <p class="table-introduction" id="minorityTractsIntro" style="margin-bottom: 20px; max-width: 100%;">
                    This table shows lending activity by census tract minority population. "Majority-Minority" tracts have more than 50% residents of color — this is a fixed national threshold. Because that single threshold tells very different stories in different geographies (nearly all tracts qualify in South Florida; almost none in rural Iowa), this table also divides tracts into four quartile groups based on the actual distribution of minority population percentages across all census tracts in the CBSA. Quartile boundaries are specific to this geography. <strong>Note:</strong> Between 2021 and 2022, shifting census boundaries resulted in a ~30% increase in majority-minority census tract designations nationally.
                </p>
                <div class="table-container" style="width: 100%;">
                    <table class="data-table" id="minorityTractsTable">
                        <thead>
                            <tr>
                                <th style="text-align: left; width: 240px;">Tract Minority Population</th>
                                <!-- Year columns will be added dynamically by JavaScript -->
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div class="table-narrative" id="minorityTractsDiscussion" style="margin-top: 20px;">
                    <!-- AI narrative will be populated by JavaScript -->
                </div>
                <p id="minorityTractsAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
                
                <!-- Unified Source Caption -->
                <p class="table-caption" id="section2SourceCaption" style="margin-top: 30px; max-width: 100%;">
                    <strong>Source:</strong> Home Mortgage Disclosure Act (HMDA) data, compiled and maintained in NCRC's curated databases. Census tract income classifications from HUD. <strong>Methodology:</strong> Borrower income is compared to FFIEC median family income for the MSA/MD. Census tract income is compared to area median family income. Minority quartiles are calculated from the distribution of minority population percentages across all census tracts in the CBSA. <strong>Note:</strong> The Change column indicates the change over time since 2020 through 2024. The Population Share (%) column shows the percentage of the population (for borrower income) or census tracts (for tract income and minority) in each category. <span id="section2AsteriskNote" style="display: none;"></span>
                </p>

                <!-- Section 2 Combined AI Discussion - "Neighborhood Overview" -->
                <div id="incomeNeighborhoodDiscussion" style="margin-top: 30px; padding: 20px; background: #F8FAFB; border-left: 4px solid #1a8fc9; border-radius: 4px;">
                    <h4 style="margin: 0 0 12px 0; color: #1e3a5f; font-size: 1.05em; font-weight: 600;">Neighborhood Overview</h4>
                    <div class="table-narrative" id="incomeNeighborhoodDiscussionContent">
                        <!-- AI narrative for Income and Neighborhood Indicators will be populated by JavaScript -->
                    </div>
                </div>
                <p id="incomeNeighborhoodAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
            </div>
            
            <!-- Section 3: Top Lenders by Total Loans -->
            <div class="report-section print-break">
                <h2 class="section-title">Section 3: Top Lenders by Total Loans</h2>
                <h3 style="margin-top: 20px; margin-bottom: 15px; font-size: 1.2em; color: var(--ncrc-dark-blue);">Table 1: Top Lenders by Total Loans</h3>
                <p class="table-introduction" id="topLendersDetailedIntro" style="margin-bottom: 20px; max-width: 100%;">
                    This table ranks the largest mortgage lenders by total loan originations in the most recent year. Market share is calculated as each lender's originations divided by total market originations. Race/ethnicity percentages use loans with demographic data as the denominator; income and neighborhood indicators use each lender's total loans.
                </p>
                <p style="margin-bottom: 10px; font-size: 0.9em; color: #666; font-style: italic;">
                    <strong>Note:</strong> Click on any column header to sort the table. All data columns are in percentages.
                </p>
                <div class="table-container">
                    <div class="table-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="lenderTypeFilter" style="font-weight: 600; white-space: nowrap;">Filter by Lender Type:</label>
                            <select id="lenderTypeFilter" onchange="filterLendersByType()" style="padding: 5px 10px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer;">
                                <option value="all">All Lenders</option>
                                <option value="Bank">Banks</option>
                                <option value="Mortgage">Mortgage Companies</option>
                                <option value="Credit Union">Credit Unions</option>
                            </select>
                        </div>
                        <button class="expand-btn" id="expandTopLendersBtn" onclick="expandTopLendersTable()" style="display: none;">
                            <i class="fas fa-chevron-down"></i> Show All Lenders
                        </button>
                    </div>
                    <table class="data-table collapsible-table" id="topLendersDetailedTable">
                        <thead>
                            <tr>
                                <th style="text-align: left;">Lender Name</th>
                                <th style="text-align: center;">Total Loans</th>
                                <!-- Race/ethnicity and indicator columns will be added dynamically by JavaScript -->
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                    <p class="table-caption" id="topLendersDetailedCaption">
                        <!-- Caption will be populated by JavaScript -->
                    </p>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #666; font-style: italic;">
                        For the complete lender list, download the Excel export.
                    </p>
                </div>
                <div class="table-narrative" id="topLendersDetailedDiscussion">
                    <!-- Discussion will be populated by JavaScript -->
                </div>
                <p id="topLendersDetailedAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
            </div>
            
            <!-- Section 4: Market Concentration -->
            <div class="report-section print-break" id="marketConcentrationSection" style="display: none;">
                <h2 class="section-title">Section 4: Market Concentration</h2>
                <div style="display: flex; gap: 20px; align-items: flex-start;">
                    <!-- Intro Text - 1/3 width -->
                    <div style="flex: 0 0 33.333%;">
                        <div class="ai-insight-card">
                            <div class="ai-content" id="marketConcentrationIntro">
                                <p>The Herfindahl-Hirschman Index (HHI) is a common measure of market concentration and is used to determine market competitiveness. It is calculated by squaring the market share of each firm in the market and then summing the resulting numbers. The HHI can range from 0 to 10,000. A higher HHI indicates greater market concentration and less competition.</p>
                                <p>This chart and table present the HHI for mortgage lending in the selected counties across the selected years, providing insight into how competitive the mortgage lending market is.</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Chart - 2/3 width -->
                    <div style="flex: 0 0 66.667%;">
                        <div class="chart-container" style="height: 400px;">
                            <canvas id="hhiChart"></canvas>
                        </div>
                    </div>
                </div>
                <!-- Source caption - full width -->
                <p class="table-caption" style="margin-top: 15px; width: 100%;">
                    <strong>Source:</strong> Home Mortgage Disclosure Act (HMDA) data, compiled and maintained in NCRC's curated databases. 
                    <strong>Methodology:</strong> Herfindahl-Hirschman Index (HHI) is calculated as the sum of the squares of the market shares of all lenders in the market based on total loan amounts. 
                    HHI values range from 0 to 10,000. 
                    <strong>Concentration Levels:</strong> HHI &lt; 1,500 = Low concentration; 1,500-2,500 = Moderate concentration; &gt; 2,500 = High concentration.
                </p>
                <div class="table-narrative" id="marketConcentrationDiscussion" style="display: none;">
                    <!-- Discussion will be populated by JavaScript -->
                </div>
                <p id="marketConcentrationAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
            </div>
            
            <!-- Methodology Section -->
            <div class="report-section print-break" id="methodsSection">
                <h2 class="section-title">Methods</h2>
                <div class="ai-insight-card">
                    <div class="ai-content">
                        <h3>Data Sources</h3>
                        <p><strong>HMDA Data:</strong> This report uses data from the Home Mortgage Disclosure Act (HMDA), which requires financial institutions to report information about mortgage loan applications and originations. HMDA data is collected and made publicly available by the Consumer Financial Protection Bureau (CFPB). The data used in this report is sourced from NCRC's curated HMDA databases, compiled and maintained by NCRC Research staff. For more information about HMDA data collection and reporting requirements, visit the <a href="https://www.consumerfinance.gov/data-research/hmda/" target="_blank">CFPB HMDA website</a>.</p>

                        <p><strong>HMDA Data Coverage:</strong> This analysis includes mortgage loan originations (action taken = 1) for owner-occupied, site-built, 1-4 unit properties. <span id="loanPurposeCoverage">The analysis includes home purchase loans (loan purpose = 1).</span> Reverse mortgages are excluded from the analysis.</p>

                        <p id="censusDataSource"><strong>Census Data:</strong> <span id="censusDataSourceText">Population demographic data is sourced from the U.S. Census Bureau, including the 2010 Decennial Census, 2020 Decennial Census, and American Community Survey (ACS) 5-year estimates.</span></p>

                        <p><strong>HUD Data:</strong> Income category population shares are sourced from the U.S. Department of Housing and Urban Development (HUD) Low-Mod Summary Data, which shows the percentage of county residents in each income bracket based on 2020 ACS data.</p>

                        <p><strong>Data Filters Applied:</strong> The following filters are automatically applied to all analyses:
                            <ul id="dataFiltersList" style="margin-top: 8px; padding-left: 20px;">
                                <li>Originations only (action taken = 1)</li>
                                <li>Site-built properties (construction method = 1)</li>
                                <li>Owner-occupied properties (occupancy type = 1)</li>
                                <li>Forward loans (excludes reverse mortgages where reverse_mortgage = 1)</li>
                                <li>1-4 unit properties (total_units IN ('1','2','3','4'))</li>
                            </ul>
                        </p>

                        <p><strong>Data Cleaning:</strong> Loan amounts below the 1st percentile and above the 99th percentile within each county-year are excluded (&lt;1% of records). This outlier removal prevents extreme values from distorting market share and HHI calculations.</p>

                        <h3>Definitions</h3>

                        <p><strong>Loan Originations:</strong> Completed mortgage loans where action taken = 1. This excludes applications, denials, and withdrawn/incomplete applications.</p>

                        <p><strong>Low-to-Moderate Income Borrower (LMIB):</strong> Borrowers whose reported income is at or below 80% of Area Median Family Income (AMFI) for the Metropolitan Statistical Area (MSA) or Metropolitan Division (MD) where the property is located.</p>

                        <h4 style="margin-top: 15px; color: #333;">Borrower Income Categories</h4>
                        <p>Borrower income is classified relative to AMFI:</p>
                        <ul style="padding-left: 20px;">
                            <li><strong>Low Income Borrower:</strong> Income at or below 50% of AMFI</li>
                            <li><strong>Moderate Income Borrower:</strong> Income greater than 50% but at or below 80% of AMFI</li>
                            <li><strong>Middle Income Borrower:</strong> Income greater than 80% but at or below 120% of AMFI</li>
                            <li><strong>Upper Income Borrower:</strong> Income greater than 120% of AMFI</li>
                        </ul>

                        <h4 style="margin-top: 15px; color: #333;">Census Tract Income Categories</h4>
                        <p>Census tract income levels are determined by comparing the tract's median family income to the Area Median Family Income (AMFI):</p>
                        <ul style="padding-left: 20px;">
                            <li><strong>Low Income Tract:</strong> Median family income at or below 50% of AMFI</li>
                            <li><strong>Moderate Income Tract:</strong> Median family income greater than 50% but at or below 80% of AMFI</li>
                            <li><strong>Middle Income Tract:</strong> Median family income greater than 80% but at or below 120% of AMFI</li>
                            <li><strong>Upper Income Tract:</strong> Median family income greater than 120% of AMFI</li>
                            <li><strong>Low-to-Moderate Income Census Tract (LMICT or LMI Tract):</strong> Census tracts where median family income is at or below 80% of AMFI (combines Low and Moderate income tracts)</li>
                        </ul>

                        <p><strong>Majority-Minority Census Tract (MMCT):</strong> Census tracts where minority populations represent more than 50% of the total population, as defined by the U.S. Census Bureau.</p>

                        <p><strong>Multi-Racial Borrowers:</strong> Non-Hispanic borrowers who report two or more distinct main race categories. This aligns with the Census Bureau's "Two or More Races" category. Based on national HMDA data (2018-2024), the most common race combinations among multi-racial mortgage borrowers are:</p>
                        <ul style="padding-left: 20px;">
                            <li>Asian and White: 38% of multi-racial borrowers</li>
                            <li>Native American and White: 22%</li>
                            <li>Black and White: 17%</li>
                            <li>Hawaiian/Pacific Islander and White: 5%</li>
                            <li>Native American and Black: 4%</li>
                        </ul>
                        <p>These five combinations account for approximately 86% of all multi-racial mortgage borrowers nationally.</p>

                        <p><strong>Population Share:</strong> The percentage of the population (for borrower income categories) or census tracts (for tract income and minority categories) in each category, based on Census Bureau and HUD data.</p>

                        <h3>Calculations</h3>

                        <p><strong>Race and Ethnicity Classification:</strong> Race and ethnicity are determined from HMDA applicant fields:</p>
                        <ul style="padding-left: 20px;">
                            <li><strong>Hispanic:</strong> Classified if any ethnicity field indicates Hispanic (codes 1, 11, 12, 13, or 14), regardless of race codes.</li>
                            <li><strong>Non-Hispanic Race:</strong> For non-Hispanic borrowers, race is determined from the first valid race code (excluding codes 6, 7, 8):
                                <ul>
                                    <li>Code 1: Native American</li>
                                    <li>Code 2 or 21-27: Asian</li>
                                    <li>Code 3: Black or African American</li>
                                    <li>Code 4 or 41-44: Hawaiian/Pacific Islander</li>
                                    <li>Code 5: White</li>
                                </ul>
                            </li>
                        </ul>

                        <p><strong>Percentage Calculations:</strong> Race/ethnicity percentages are calculated as: (group loans / loans with demographic data) × 100. Loans without race/ethnicity data are excluded from the denominator. Income and neighborhood indicator percentages use total loans as the denominator. Only groups representing ≥1% of loans are displayed in tables.</p>

                        <p><strong>Change Over Time:</strong> For percentage shares, Change = Last Year Share − First Year Share, expressed in percentage points (pp). For total counts, Change = ((Last − First) / First) × 100, expressed as a percentage. Positive changes are displayed in blue; negative changes in red.</p>

                        <h4 style="margin-top: 15px; color: #333;">Herfindahl-Hirschman Index (HHI)</h4>
                        <p>A standard measure of market concentration used by regulators including the Department of Justice and Federal Trade Commission. HHI is calculated as the sum of squared market shares of all lenders in a market:</p>
                        <p style="text-align: center; font-family: monospace; margin: 15px 0;">HHI = Σ(market share<sub>i</sub>)<sup>2</sup></p>
                        <p>Market shares are based on total loan origination amounts (not count). The sum includes all lenders in the market. Market shares are expressed as percentages (0-100), so HHI ranges from 0 to 10,000. Lower values indicate more competitive markets with many lenders; higher values indicate concentrated markets dominated by few lenders.</p>
                        <p><strong>Concentration Levels:</strong></p>
                        <ul style="padding-left: 20px;">
                            <li>HHI &lt; 1,500: Low concentration (competitive market)</li>
                            <li>HHI 1,500-2,500: Moderate concentration</li>
                            <li>HHI &gt; 2,500: High concentration</li>
                        </ul>

                        <p><strong>Top Lenders:</strong> Lenders ranked by total loan originations in the most recent year. Race/ethnicity percentages use loans with demographic data as denominator; income and neighborhood indicators use total loans as denominator.</p>

                        <h4 style="margin-top: 15px; color: #333;">Minority Population Quartile Calculation</h4>
                        <p>Census tracts are divided into quartiles based on the distribution of minority population percentages across all census tracts in the Core Based Statistical Area (CBSA). Quartile boundaries are calculated from the actual distribution in each CBSA:</p>
                        <ol style="padding-left: 20px;">
                            <li><strong>Step 1:</strong> For each census tract in the CBSA, obtain the minority population percentage.</li>
                            <li><strong>Step 2:</strong> Calculate the 25th, 50th, and 75th percentiles across all tracts.</li>
                            <li><strong>Step 3:</strong> Classify each tract — ≤25th percentile = Low Minority, 25th–50th = Moderate, 50th–75th = Middle, &gt;75th = High.</li>
                            <li><strong>Step 4:</strong> For each year, calculate the share of originations in tracts within each category.</li>
                        </ol>
                        <div id="methodologyQuartileValues" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; display: none;">
                            <!-- Dynamic quartile values will be populated by JavaScript from API response -->
                        </div>

                        <h3>Abbreviations</h3>
                        <ul>
                            <li><strong>ACS:</strong> American Community Survey</li>
                            <li><strong>AMFI:</strong> Area Median Family Income</li>
                            <li><strong>CBSA:</strong> Core Based Statistical Area</li>
                            <li><strong>CFPB:</strong> Consumer Financial Protection Bureau</li>
                            <li><strong>FIPS:</strong> Federal Information Processing Standards</li>
                            <li><strong>HHI:</strong> Herfindahl-Hirschman Index</li>
                            <li><strong>HMDA:</strong> Home Mortgage Disclosure Act</li>
                            <li><strong>HUD:</strong> U.S. Department of Housing and Urban Development</li>
                            <li><strong>LMIB:</strong> Low-to-Moderate Income Borrower</li>
                            <li><strong>LMICT:</strong> Low-to-Moderate Income Census Tract</li>
                            <li><strong>MD:</strong> Metropolitan Division</li>
                            <li><strong>MMCT:</strong> Majority-Minority Census Tract</li>
                            <li><strong>MSA:</strong> Metropolitan Statistical Area</li>
                            <li><strong>NCRC:</strong> National Community Reinvestment Coalition</li>
                            <li><strong>pp:</strong> Percentage Points</li>
                        </ul>

                        <h3>Data Quality and AI Disclosure</h3>
                        <div style="padding: 15px; background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; margin-bottom: 15px;">
                            <p style="font-style: italic; color: #856404; margin-bottom: 8px;"><strong>AI Disclosure — Placeholder</strong></p>
                            <p style="color: #856404;">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
                            <p style="color: #856404;">Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit.</p>
                            <p style="font-style: italic; color: #856404; margin-bottom: 0;">[This disclosure text will be provided by Rose/Legal]</p>
                        </div>

                        <p id="lendsightVersionNumber" style="margin-top: 20px; font-size: 0.85em; color: #999; text-align: right;">
                            <!-- LendSight version will be populated by JavaScript -->
                        </p>
                    </div>
                </div>
            </div>
            <!-- end report sections -->

        </main>
        </div>
    </div>

    <script>
        // Update download links with job_id from URL
        function updateDownloadLinks() {
            const urlParams = new URLSearchParams(window.location.search);
            const jobId = urlParams.get('job_id');
            
            if (jobId) {
                // Update dropdown download links
                const downloadLinks = document.querySelectorAll('.dropdown-item[href^="/download"]');
                downloadLinks.forEach(link => {
                    const href = link.getAttribute('href');
                    if (href && !href.includes('job_id=')) {
                        const separator = href.includes('?') ? '&' : '?';
                        link.setAttribute('href', `${href}${separator}job_id=${encodeURIComponent(jobId)}`);
                    }
                });
                
                // Update PDF download button
                const pdfBtn = document.getElementById('downloadPdfBtn');
                if (pdfBtn) {
                    const href = pdfBtn.getAttribute('href');
                    if (href && !href.includes('job_id=')) {
                        const separator = href.includes('?') ? '&' : '?';
                        pdfBtn.setAttribute('href', `${href}${separator}job_id=${encodeURIComponent(jobId)}`);
                    }
                }
                
                // Update Excel download button
                const excelBtn = document.getElementById('downloadExcelBtn');
                if (excelBtn) {
                    const href = excelBtn.getAttribute('href');
                    if (href && !href.includes('job_id=')) {
                        const separator = href.includes('?') ? '&' : '?';
                        excelBtn.setAttribute('href', `${href}${separator}job_id=${encodeURIComponent(jobId)}`);
                    }
                }
            }
        }
        
        // Load and display report data
        async function loadReportData() {
            try {
                // Check for job_id in URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const jobId = urlParams.get('job_id');
                
                console.log('Loading report data...', { jobId, url: window.location.href });
                
                // Update download links with job_id
                updateDownloadLinks();
                
                // Build URL with job_id if available
                const baseUrl = window.APP_BASE_URL || '/lendsight';
                let url = `${baseUrl}/report-data`;
                if (jobId) {
                    url += `?job_id=${encodeURIComponent(jobId)}`;
                    console.log('Using job_id from URL:', jobId);
                } else {
                    console.log('No job_id in URL, relying on session');
                }
                
                const response = await fetch(url);
                console.log('Response status:', response.status);
                
                // Check if response is OK
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Response not OK:', response.status, errorText);
                    throw new Error(`Server returned ${response.status}: ${errorText.substring(0, 200)}`);
                }
                
                // Get response text first to check if it's valid JSON
                const responseText = await response.text();
                console.log('Response text length:', responseText.length);
                
                if (!responseText || responseText.trim().length === 0) {
                    throw new Error('Empty response from server. The analysis may still be running or may have failed.');
                }
                
                // Try to parse JSON
                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (jsonError) {
                    console.error('JSON parse error:', jsonError);
                    console.error('Response text preview (first 500 chars):', responseText.substring(0, 500));
                    console.error('Response text preview (last 500 chars):', responseText.substring(Math.max(0, responseText.length - 500)));
                    throw new Error(`Invalid JSON response: ${jsonError.message}. The response may have been truncated.`);
                }
                
                console.log('Response data:', { success: result.success, hasData: !!result.data, dataKeys: result.data ? Object.keys(result.data) : [] });
                console.log('Metadata:', result.metadata ? {
                    counties: result.metadata.counties,
                    years: result.metadata.years,
                    hasCensusData: !!result.metadata.census_data,
                    censusDataKeys: result.metadata.census_data ? Object.keys(result.metadata.census_data) : []
                } : 'No metadata');
                
                if (!result.success) {
                    const errorMsg = result.error || 'Failed to load report data';
                    console.error('Report data error:', errorMsg);
                    throw new Error(errorMsg);
                }
                
                // Check if we have actual data
                if (!result.data || Object.keys(result.data).length === 0) {
                    console.warn('No data in response:', result);
                    throw new Error('No report data available. The analysis may still be running or may have failed.');
                }
                
                // Ensure metadata exists with defaults
                const metadata = result.metadata || {
                    generated_at: new Date().toISOString(),
                    counties: [],
                    years: [],
                    total_records: 0,
                    ai_insights: {}
                };
                
                console.log('Displaying report with metadata:', metadata);
                displayReport(result.data || {}, metadata);

                // Signal to interstitial that report is ready
                if (typeof ReportInterstitial !== 'undefined') {
                    ReportInterstitial.setReady();
                }

            } catch (error) {
                console.error('Error loading report:', error);
                const errorMessage = error.message || 'Failed to load report data';

                // Signal error to interstitial
                if (typeof ReportInterstitial !== 'undefined') {
                    ReportInterstitial.setError('Error loading report. Click to try again.');
                }

                if (errorMessage.includes('No analysis') || errorMessage.includes('No analysis session') || errorMessage.includes('No report data')) {
                    showError('No analysis data found. Please run an analysis first by selecting counties and years on the <a href="' + (window.APP_BASE_URL || '/lendsight') + '">analysis page</a>.');
                } else {
                    showError('Error loading report: ' + errorMessage + '. Please try running a new analysis on the <a href="' + (window.APP_BASE_URL || '/lendsight') + '">analysis page</a>.');
                }
            }
        }
        
        function displayReport(data, metadata) {
            // Ensure metadata exists
            if (!metadata) {
                console.error('Metadata is missing');
                showError('Report data is incomplete. Please try generating a new report.');
                return;
            }

            // Debug: Log data structure to diagnose empty tables issue
            console.log('[DEBUG] displayReport called');
            console.log('[DEBUG] data:', data);
            console.log('[DEBUG] data keys:', data ? Object.keys(data) : 'data is null/undefined');
            console.log('[DEBUG] data.income_borrowers:', data ? data.income_borrowers : 'N/A');
            console.log('[DEBUG] data.income_tracts:', data ? data.income_tracts : 'N/A');
            console.log('[DEBUG] data.minority_tracts:', data ? data.minority_tracts : 'N/A');
            console.log('[DEBUG] data.demographic_overview:', data ? data.demographic_overview : 'N/A');

            console.log('Displaying report with metadata:', metadata);
            console.log('Census data in metadata:', metadata.census_data ? {
                counties: Object.keys(metadata.census_data),
                sampleCounty: metadata.census_data[Object.keys(metadata.census_data)[0]]
            } : 'No census_data in metadata');
            
            // Hide loading state
            document.getElementById('loadingState').style.display = 'none';
            
            // Show report content
            document.getElementById('main-content').style.display = 'block';
            
            // Update metadata with safe defaults
            document.getElementById('counties').textContent = 
                (metadata.counties && metadata.counties.length > 0) ? metadata.counties.join(', ') : 'N/A';
            
            // Format years as "2020 through 2024" instead of comma-separated
            const yearsEl = document.getElementById('years');
            if (yearsEl && metadata.years && metadata.years.length > 0) {
                const sortedYears = [...metadata.years].sort((a, b) => a - b);
                if (sortedYears.length === 1) {
                    yearsEl.textContent = sortedYears[0].toString();
                } else {
                    const minYear = sortedYears[0];
                    const maxYear = sortedYears[sortedYears.length - 1];
                    yearsEl.textContent = `${minYear} through ${maxYear}`;
                }
            } else {
                yearsEl.textContent = 'N/A';
            }
            
            // Populate overview tab
            // populateOverview removed

            // Populate intro paragraph and demographics chart (always show these)
            generateIntroParagraph(metadata);
            populatePopulationDemographicsChart(metadata);
            
            // Populate AI insights if available
            if (metadata.ai_insights) {
                populateAIInsights(metadata.ai_insights, metadata);
            } else {
                // If no AI insights, still show the caption section after demographics table
                const captionSection = document.getElementById('populationDemographicsCaptionSection');
                if (captionSection) {
                    captionSection.style.display = 'block';
                }
            }
            
            // Populate demographic overview table
            try {
                if (data.demographic_overview && data.demographic_overview.length > 0) {
                    populateDemographicOverviewTable(data.demographic_overview, metadata);
                }
            } catch (e) {
                console.error('[ERROR] Error populating demographic overview table:', e);
            }
            
            // Populate income borrowers table (Table 1)
            try {
                if (data.income_borrowers && data.income_borrowers.length > 0) {
                    populateIncomeBorrowersTable(data.income_borrowers, metadata);
                }
            } catch (e) {
                console.error('[ERROR] Error populating income borrowers table:', e);
            }
            
            // Populate income tracts table (Table 2)
            try {
                if (data.income_tracts && data.income_tracts.length > 0) {
                    populateIncomeTractsTable(data.income_tracts, metadata);
                }
            } catch (e) {
                console.error('[ERROR] Error populating income tracts table:', e);
            }
            
            // Populate minority tracts table (Table 3)
            try {
                if (data.minority_tracts && data.minority_tracts.length > 0) {
                    populateMinorityTractsTable(data.minority_tracts, metadata);
                }
            } catch (e) {
                console.error('[ERROR] Error populating minority tracts table:', e);
            }
            
            // REMOVED: Legacy income_neighborhood_tracts and income_neighborhood_indicators table population
            // These tables have been consolidated into income_borrowers, income_tracts, and minority_tracts

            // Populate top 10 lenders detailed table
            try {
                if (data.top_lenders_detailed && data.top_lenders_detailed.length > 0) {
                    console.log('[DEBUG] Populating top lenders table with', data.top_lenders_detailed.length, 'rows');
                    populateTopLendersDetailedTable(data.top_lenders_detailed, metadata);
                } else {
                    console.warn('[WARNING] No top_lenders_detailed data available. Data keys:', Object.keys(data));
                }
            } catch (e) {
                console.error('[ERROR] Error populating top lenders table:', e);
            }
            
            // Populate market concentration table and chart
            try {
                if (data.market_concentration && data.market_concentration.length > 0) {
                    console.log('[DEBUG] Populating market concentration with', data.market_concentration.length, 'rows');
                    populateMarketConcentrationTable(data.market_concentration, metadata);
                } else {
                    console.warn('[WARNING] No market_concentration data available. Data keys:', Object.keys(data));
                }
            } catch (e) {
                console.error('[ERROR] Error populating market concentration:', e);
            }
            
            // Populate methodology section with loan purpose information
            populateMethodology(metadata);
        }
        
        function populateMethodology(metadata) {
            // Populate loan purpose coverage text
            const loanPurposeCoverage = document.getElementById('loanPurposeCoverage');
            if (loanPurposeCoverage && metadata.loan_purpose) {
                const loanPurposes = Array.isArray(metadata.loan_purpose) ? metadata.loan_purpose : [metadata.loan_purpose];
                
                // Map loan purpose values to display names
                const purposeMap = {
                    'purchase': 'home purchase loans (loan purpose = 1)',
                    'refinance': 'refinance and cash-out refinance loans (loan purpose IN (31, 32))',
                    'equity': 'home equity lending (loan purpose IN (2, 4))'
                };
                
                // Filter out 'all' if present and get actual purposes
                const selectedPurposes = loanPurposes.filter(p => p !== 'all');
                
                // If all three are selected or 'all' was selected, show all purposes
                if (selectedPurposes.length === 0 || 
                    (selectedPurposes.includes('purchase') && selectedPurposes.includes('refinance') && selectedPurposes.includes('equity')) ||
                    loanPurposes.includes('all')) {
                    loanPurposeCoverage.textContent = 'The analysis includes all loan purposes: home purchase loans (loan purpose = 1), refinance and cash-out refinance loans (loan purpose IN (31, 32)), and home equity lending (loan purpose IN (2, 4)).';
                } else if (selectedPurposes.length === 1) {
                    const purposeName = purposeMap[selectedPurposes[0]] || selectedPurposes[0];
                    loanPurposeCoverage.textContent = `The analysis includes ${purposeName}.`;
                } else {
                    const purposeNames = selectedPurposes.map(p => purposeMap[p] || p);
                    const lastPurpose = purposeNames.pop();
                    const purposesText = purposeNames.length > 0 
                        ? purposeNames.join(', ') + ', and ' + lastPurpose
                        : lastPurpose;
                    loanPurposeCoverage.textContent = `The analysis includes ${purposesText}.`;
                }
            } else if (loanPurposeCoverage) {
                // Default text if no loan purpose info is available
                loanPurposeCoverage.textContent = 'The analysis includes all loan purposes: home purchase loans (loan purpose = 1), refinance and cash-out refinance loans (loan purpose IN (31, 32)), and home equity lending (loan purpose IN (2, 4)).';
            }
            
            // Populate Census data source information
            const censusDataSourceText = document.getElementById('censusDataSourceText');
            if (censusDataSourceText && metadata.census_data) {
                const censusData = metadata.census_data;
                const counties = Object.keys(censusData);
                
                if (counties.length > 0) {
                    // Get the ACS data year from the first county
                    const firstCounty = censusData[counties[0]];
                    const timePeriods = firstCounty.time_periods || {};
                    const acsPeriod = timePeriods.acs;
                    const acsYear = acsPeriod?.data_year || 'the most recent available ACS 5-year estimates';
                    
                    let censusText = `Population demographic data is sourced from the U.S. Census Bureau. `;
                    censusText += `The Population Demographics table shows change over time using three data sources: `;
                    censusText += `(1) the most recent American Community Survey (ACS) 5-year estimates (${acsYear}), `;
                    censusText += `(2) the 2020 Decennial Census, and (3) the 2010 Decennial Census. `;
                    censusText += `Census data is used to provide context about the racial and ethnic composition of the selected geography and how it has changed over time. `;
                    censusText += `For more information about Census data, visit the <a href="https://www.census.gov/data/developers/data-sets.html" target="_blank">U.S. Census Bureau Data API website</a>.`;
                    
                    censusDataSourceText.innerHTML = censusText;
                } else {
                    censusDataSourceText.textContent = 'Population demographic data from the U.S. Census Bureau was not available for the selected geography.';
                }
            } else if (censusDataSourceText) {
                censusDataSourceText.textContent = 'Population demographic data from the U.S. Census Bureau was not available for the selected geography.';
            }

            // Populate dynamic quartile values in methodology
            // Extract from minority_tracts metric labels (e.g., "Low Minority Census Tracts (0-22.8%)")
            const quartileValuesEl = document.getElementById('methodologyQuartileValues');
            if (quartileValuesEl) {
                // Try to extract from the report data that's been loaded
                try {
                    const mainContent = document.getElementById('main-content');
                    const minorityTable = document.getElementById('minorityTractsTable');
                    if (minorityTable) {
                        const rows = minorityTable.querySelectorAll('tbody tr');
                        const quartileLabels = [];
                        rows.forEach(row => {
                            const text = row.querySelector('td')?.textContent || '';
                            const match = text.match(/\(([0-9.]+%?)-([0-9.]+%?)\)/);
                            if (match) {
                                quartileLabels.push({ text, low: match[1], high: match[2] });
                            }
                        });
                        if (quartileLabels.length >= 3) {
                            // Extract q25 from Low Minority high bound, q50 from Moderate high bound, q75 from Middle high bound
                            const q25 = quartileLabels[0]?.high?.replace('%', '') || '';
                            const q50 = quartileLabels[1]?.high?.replace('%', '') || '';
                            const q75 = quartileLabels[2]?.high?.replace('%', '') || '';
                            if (q25 && q50 && q75) {
                                quartileValuesEl.innerHTML = `<p style="margin: 0; font-size: 0.9em;"><strong>Quartile breakpoints for this geography:</strong> ` +
                                    `25th percentile = ${q25}%, 50th percentile = ${q50}%, 75th percentile = ${q75}%</p>`;
                                quartileValuesEl.style.display = 'block';
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Could not extract quartile values for methodology:', e);
                }
            }

            // Populate LendSight version number
            const versionEl = document.getElementById('lendsightVersionNumber');
            if (versionEl) {
                const version = metadata.lendsight_version || '1.0.0';
                versionEl.textContent = `LendSight v${version}`;
            }
        }
        
        // Store chart instance for potential updates
        let censusChartInstance = null;
        
        function populatePopulationDemographicsChart(metadata) {
            console.log('populatePopulationDemographicsChart called with metadata:', metadata);
            
            if (!metadata) {
                console.warn('No metadata provided to populatePopulationDemographicsChart');
                return;
            }
            
            const censusData = metadata.census_data;
            console.log('Census data object:', censusData);
            console.log('Census data type:', typeof censusData);
            console.log('Census data keys:', censusData ? Object.keys(censusData) : 'null/undefined');
            console.log('Census data length:', censusData ? Object.keys(censusData).length : 0);
            
            if (!censusData || Object.keys(censusData).length === 0) {
                console.warn('No Census data available - showing empty message');
                const section = document.getElementById('introAndCensusSection');
                if (section) {
                    section.style.display = 'block';
                    const censusChart = section.querySelector('#censusChart');
                    if (censusChart && censusChart.parentElement) {
                        censusChart.parentElement.innerHTML = '<p style="text-align: center; color: #666; font-style: italic; padding: 40px;">Census demographic data is not available for the selected geography.</p>';
                    }
                }
                return;
            }
            
            // Use shared module if available
            if (typeof window.PopulationDemographics !== 'undefined') {
            // Destroy existing chart if it exists
            if (censusChartInstance) {
                censusChartInstance.destroy();
                    censusChartInstance = null;
                }
                
                // Render chart using shared module
                censusChartInstance = window.PopulationDemographics.renderPopulationDemographicsChart(
                    'censusChart',
                    censusData,
                    {
                        chartHeight: 400
                    }
                );
            
            // Show the combined intro and census section
            const section = document.getElementById('introAndCensusSection');
            if (section) {
                section.style.display = 'block';
                console.log('Intro and Census section displayed');
            }
            
            // Update caption (now located below Key Findings)
            const caption = document.getElementById('populationDemographicsCaption');
            if (caption) {
                    const captionText = window.PopulationDemographics.generateSourceCaption(censusData);
                caption.innerHTML = captionText;
            }
            
            // Show the caption section (below Key Findings)
            const captionSection = document.getElementById('populationDemographicsCaptionSection');
            if (captionSection) {
                captionSection.style.display = 'block';
                console.log('Population Demographics caption section displayed');
                }
                
                // Remove total population display below chart (now shown above columns)
                const totalsEl = document.getElementById('censusChartTotals');
                if (totalsEl) {
                    totalsEl.innerHTML = '';
                }
                
                return;
            }
            
            // Inline implementation for population demographics chart
            // Shows 2010 Census, 2020 Census, and current ACS data as grouped bars
            console.log('Using inline population demographics chart implementation');

            const section = document.getElementById('introAndCensusSection');
            if (!section) return;

            section.style.display = 'block';

            // Get the first county's data
            const countyNames = Object.keys(censusData);
            if (countyNames.length === 0) return;

            const countyData = censusData[countyNames[0]];
            if (!countyData || !countyData.time_periods) return;

            const timePeriods = countyData.time_periods;

            // Define race groups to display
            const raceGroups = [
                { key: 'white_percentage', label: 'White' },
                { key: 'black_percentage', label: 'Black' },
                { key: 'hispanic_percentage', label: 'Hispanic' },
                { key: 'asian_percentage', label: 'Asian' },
                { key: 'native_american_percentage', label: 'Native Am.' },
                { key: 'hopi_percentage', label: 'Hawaiian/PI' },
                { key: 'multi_racial_percentage', label: 'Multi-Racial' }
            ];

            // Determine which race groups to show (>= 1% in any time period)
            const visibleGroups = raceGroups.filter(group => {
                const vals = [];
                if (timePeriods.census2010?.demographics) vals.push(timePeriods.census2010.demographics[group.key] || 0);
                if (timePeriods.census2020?.demographics) vals.push(timePeriods.census2020.demographics[group.key] || 0);
                if (timePeriods.acs?.demographics) vals.push(timePeriods.acs.demographics[group.key] || 0);
                return Math.max(...vals) >= 1;
            });

            const labels = visibleGroups.map(g => g.label);

            // NEW LAYOUT: Group by census vintage, with races as bars within each group
            // X-axis: "2010 Census (Pop: X)", "2020 Census (Pop: Y)", "2024 ACS (Pop: Z)"
            // Each group has bars for each race

            // Colors for each race group
            const raceColors = {
                'White': { bg: 'rgba(65, 105, 225, 0.7)', border: 'rgb(65, 105, 225)' },
                'Black': { bg: 'rgba(34, 139, 34, 0.7)', border: 'rgb(34, 139, 34)' },
                'Hispanic': { bg: 'rgba(255, 140, 0, 0.7)', border: 'rgb(255, 140, 0)' },
                'Asian': { bg: 'rgba(220, 20, 60, 0.7)', border: 'rgb(220, 20, 60)' },
                'Native Am.': { bg: 'rgba(148, 103, 189, 0.7)', border: 'rgb(148, 103, 189)' },
                'Hawaiian/PI': { bg: 'rgba(23, 190, 207, 0.7)', border: 'rgb(23, 190, 207)' },
                'Multi-Racial': { bg: 'rgba(188, 189, 34, 0.7)', border: 'rgb(188, 189, 34)' }
            };

            // Track max population count for dynamic Y-axis scaling
            let maxPopCount = 0;

            // Helper to calculate population count from percentage
            const getPopulationCount = (totalPop, percentage) => {
                return Math.round((percentage / 100) * totalPop);
            };

            // Build vintage labels with population totals
            const vintageLabels = [];
            const vintageData = {};

            if (timePeriods.census2010?.demographics) {
                const demo = timePeriods.census2010.demographics;
                const totalPop = demo.total_population || 0;
                const label = `2010 Census\n(Pop: ${totalPop.toLocaleString()})`;
                vintageLabels.push(label);
                vintageData['2010'] = { demo, totalPop, label: '2010 Census' };
            }

            if (timePeriods.census2020?.demographics) {
                const demo = timePeriods.census2020.demographics;
                const totalPop = demo.total_population || 0;
                const label = `2020 Census\n(Pop: ${totalPop.toLocaleString()})`;
                vintageLabels.push(label);
                vintageData['2020'] = { demo, totalPop, label: '2020 Census' };
            }

            if (timePeriods.acs?.demographics) {
                const acsLabel = timePeriods.acs.year || '2024 ACS';
                const demo = timePeriods.acs.demographics;
                const totalPop = demo.total_population || 0;
                const label = `${acsLabel}\n(Pop: ${totalPop.toLocaleString()})`;
                vintageLabels.push(label);
                vintageData['acs'] = { demo, totalPop, label: acsLabel };
            }

            // Build datasets - one dataset per race, with data points for each vintage
            const datasets = [];
            const vintageKeys = Object.keys(vintageData);

            visibleGroups.forEach(group => {
                const dataPoints = [];
                const percentages = [];

                vintageKeys.forEach(key => {
                    const { demo, totalPop } = vintageData[key];
                    const pct = parseFloat((demo[group.key] || 0).toFixed(1));
                    const popCount = getPopulationCount(totalPop, demo[group.key] || 0);
                    if (popCount > maxPopCount) maxPopCount = popCount;
                    dataPoints.push(popCount);  // Use raw population count as data point
                    percentages.push(pct);      // Store percentage for tooltip
                });

                const color = raceColors[group.label] || { bg: 'rgba(128, 128, 128, 0.7)', border: 'rgb(128, 128, 128)' };
                datasets.push({
                    label: group.label,
                    data: dataPoints,
                    backgroundColor: color.bg,
                    borderColor: color.border,
                    borderWidth: 1,
                    percentages: percentages  // Store percentages for tooltip
                });
            });

            // Calculate dynamic Y-axis max: 10% above highest population count, rounded to nice number
            const yAxisMax = Math.ceil((maxPopCount * 1.10) / 10000) * 10000;

            // Create/update chart
            const ctx = document.getElementById('censusChart');
            if (!ctx) return;

            if (censusChartInstance) {
                censusChartInstance.destroy();
            }

            censusChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: vintageLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: `Population Demographics Over Time: ${countyNames[0]}`,
                            font: { size: 16, weight: 'bold' }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataset = context.dataset;
                                    const count = context.raw;  // Raw data is now population count
                                    const percentage = dataset.percentages ? dataset.percentages[context.dataIndex] : 0;
                                    return `${dataset.label}: ${count.toLocaleString()} persons (${percentage}%)`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: yAxisMax,
                            title: {
                                display: true,
                                text: 'Population'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });

            // Update caption
            const caption = document.getElementById('populationDemographicsCaption');
            if (caption) {
                caption.innerHTML = `<strong>Source:</strong> U.S. Census Bureau - 2010 Decennial Census, 2020 Decennial Census, and American Community Survey. Population figures represent ${countyNames[0]}.`;
            }
        }
        
        function generateIntroParagraph(metadata) {
            if (!metadata) return;
            
            const counties = metadata.counties || [];
            const years = metadata.years || [];
            const loanPurpose = metadata.loan_purpose || ['purchase'];
            
            if (counties.length === 0 || years.length === 0) return;
            
            // Format counties - group by state and avoid repeating state names
            let countiesStr = '';
            
            // Parse counties into {name, state} objects
            const parsedCounties = counties.map(county => {
                // Handle formats like "Richmond County, Virginia" or "Richmond city, Virginia"
                const match = county.match(/^(.+?),\s*(.+)$/);
                if (match) {
                    return { name: match[1].trim(), state: match[2].trim(), full: county };
                }
                // If no comma, assume it's just the name (no state specified)
                return { name: county.trim(), state: null, full: county };
            });
            
            // Group by state
            const byState = {};
            parsedCounties.forEach(item => {
                const state = item.state || 'Unknown';
                if (!byState[state]) {
                    byState[state] = [];
                }
                byState[state].push(item.name);
            });
            
            // Format the string
            const states = Object.keys(byState);
            
            if (counties.length === 1) {
                // Single county - use original format
                countiesStr = counties[0];
            } else if (states.length === 1) {
                // All counties in same state
                const state = states[0];
                const names = byState[state];
                if (names.length === 1) {
                    countiesStr = `${names[0]}, ${state}`;
                } else if (names.length === 2) {
                    countiesStr = `${names[0]} and ${names[1]}, ${state}`;
                } else {
                    const last = names.slice().pop();
                    const rest = names.slice(0, -1);
                    countiesStr = `${rest.join(', ')}, and ${last}, ${state}`;
                }
            } else {
                // Multiple states - format each state group
                const stateGroups = states.map(state => {
                    const names = byState[state];
                    if (names.length === 1) {
                        return `${names[0]}, ${state}`;
                    } else if (names.length === 2) {
                        return `${names[0]} and ${names[1]}, ${state}`;
                    } else {
                        const last = names.slice().pop();
                        const rest = names.slice(0, -1);
                        return `${rest.join(', ')}, and ${last}, ${state}`;
                    }
                });
                
                if (stateGroups.length === 2) {
                    countiesStr = stateGroups.join(' and ');
                } else {
                    const last = stateGroups.pop();
                    countiesStr = `${stateGroups.join(', ')}, and ${last}`;
                }
            }
            
            // Format years
            const yearsStr = years.length > 1 
                ? `${Math.min(...years)} to ${Math.max(...years)}`
                : years[0].toString();
            
            // Format loan purposes
            const purposeMap = {
                'purchase': 'home purchase loans',
                'refinance': 'refinance and cash-out refinance loans',
                'equity': 'home equity lending'
            };
            
            const selectedPurposes = Array.isArray(loanPurpose) 
                ? loanPurpose.filter(p => p !== 'all')
                : [loanPurpose].filter(p => p !== 'all');
            
            let loanPurposeStr = '';
            if (selectedPurposes.length === 0 || 
                (selectedPurposes.includes('purchase') && selectedPurposes.includes('refinance') && selectedPurposes.includes('equity'))) {
                loanPurposeStr = 'all loan purposes (home purchase loans, refinance and cash-out refinance loans, and home equity lending)';
            } else if (selectedPurposes.length === 1) {
                loanPurposeStr = purposeMap[selectedPurposes[0]] || selectedPurposes[0];
            } else {
                const purposeNames = selectedPurposes.map(p => purposeMap[p] || p);
                const lastPurpose = purposeNames.pop();
                loanPurposeStr = purposeNames.join(', ') + ', and ' + lastPurpose;
            }
            
            // Build intro paragraph
            let introText = `This report examines ${loanPurposeStr} in ${countiesStr} from ${yearsStr}. `;
            introText += `The analysis includes only loans that were completed (originations) for owner-occupied properties, which means homes where the borrower actually lives rather than investment properties. `;
            introText += `The data is filtered to include only site-built homes (traditional homes constructed on-site, not manufactured or mobile homes), forward mortgages (regular mortgages where the borrower makes payments to the bank, not reverse mortgages where the bank pays the homeowner), and properties with 1-4 units (single-family homes, duplexes, triplexes, and four-unit buildings). `;
            introText += `It is important to note that shifting census boundaries that took effect in 2022 resulted in a 30% increase in the number of majority-minority census tracts nationally. The vast majority of these newly designated majority-minority tracts are not low-to-moderate income tracts.`;
            
            // Add Census demographic context if available
            if (metadata.census_data) {
                const censusData = metadata.census_data;
                const countiesWithData = Object.keys(censusData).filter(county => {
                    const data = censusData[county];
                    return data && data.demographics && data.demographics.total_population;
                });
                
                if (countiesWithData.length > 0) {
                    // Aggregate demographics for context
                    let totalPop = 0;
                    let whiteSum = 0, hispanicSum = 0, blackSum = 0, asianSum = 0;
                    
                    countiesWithData.forEach(county => {
                        const demo = censusData[county].demographics;
                        const pop = demo.total_population || 0;
                        totalPop += pop;
                        whiteSum += (demo.white_percentage || 0) * pop / 100;
                        hispanicSum += (demo.hispanic_percentage || 0) * pop / 100;
                        blackSum += (demo.black_percentage || 0) * pop / 100;
                        asianSum += (demo.asian_percentage || 0) * pop / 100;
                    });
                    
                    if (totalPop > 0) {
                        const whitePct = (whiteSum / totalPop * 100).toFixed(1);
                        const hispanicPct = (hispanicSum / totalPop * 100).toFixed(1);
                        const blackPct = (blackSum / totalPop * 100).toFixed(1);
                        const asianPct = (asianSum / totalPop * 100).toFixed(1);
                        
                        const parts = [];
                        if (parseFloat(whitePct) > 0) parts.push(`${whitePct}% White`);
                        if (parseFloat(hispanicPct) > 0) parts.push(`${hispanicPct}% Hispanic or Latino`);
                        if (parseFloat(blackPct) > 0) parts.push(`${blackPct}% Black or African American`);
                        if (parseFloat(asianPct) > 0) parts.push(`${asianPct}% Asian`);
                        
                        if (parts.length >= 2) {
                            const lastPart = parts.pop();
                            introText += ` According to recent Census data, the population of ${countiesStr} is approximately ${parts.join(', ')}, and ${lastPart}.`;
                        } else if (parts.length === 1) {
                            introText += ` According to recent Census data, the population of ${countiesStr} is approximately ${parts[0]}.`;
                        }
                    }
                }
            }
            
            // Display intro paragraph in the combined section (without census context)
            const element = document.getElementById('introParagraphContent');
            if (element) {
                // Only show the core intro text (without census demographic context and census boundaries note)
                let coreIntroText = `This report examines ${loanPurposeStr} in ${countiesStr} from ${yearsStr}. `;
                coreIntroText += `The analysis includes only loans that were completed (originations) for owner-occupied properties, which means homes where the borrower actually lives rather than investment properties. `;
                coreIntroText += `The data is filtered to include only site-built homes (traditional homes constructed on-site, not manufactured or mobile homes), forward mortgages (regular mortgages where the borrower makes payments to the bank, not reverse mortgages where the bank pays the homeowner), and properties with 1-4 units (single-family homes, duplexes, triplexes, and four-unit buildings).`;
                element.textContent = coreIntroText;
            }
            
            // Display census boundaries callout
            const calloutElement = document.getElementById('censusBoundariesCallout');
            if (calloutElement) {
                calloutElement.style.display = 'block';
            }
        }
        
        function populateAIInsights(aiInsights, metadata) {
            // Populate intro paragraph (now generated in JavaScript)
            generateIntroParagraph(metadata);
            
            // Populate population demographics chart (after intro, before key findings)
            populatePopulationDemographicsChart(metadata);
            
            console.log('populateAIInsights called with:', {
                hasAiInsights: !!aiInsights,
                aiInsightsKeys: aiInsights ? Object.keys(aiInsights) : [],
                demographic_overview_discussion: aiInsights?.demographic_overview_discussion ? 'present' : 'missing',
                income_neighborhood_discussion: aiInsights?.income_neighborhood_discussion ? 'present' : 'missing',
                top_lenders_detailed_discussion: aiInsights?.top_lenders_detailed_discussion ? 'present' : 'missing',
                ai_insights_enabled: metadata?.ai_insights_enabled
            });
            
            // Check if AI insights are disabled
            const aiDisabled = metadata && metadata.ai_insights_enabled === false;
            const getAIDisabledMessage = () => {
                return '<div class="alert alert-info" style="padding: 15px; margin: 15px 0; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px;"><strong>AI Insights Not Available:</strong> AI-powered analysis is currently disabled. To enable AI insights, please configure the CLAUDE_API_KEY environment variable in your deployment settings.</div>';
            };
            
            if (!aiInsights) {
                console.warn('No AI insights provided to populateAIInsights');
                return;
            }
            
            if (aiInsights.key_findings) {
                const content = aiInsights.key_findings;
                const element = document.getElementById('keyFindingsContent');
                if (element) {
                    element.innerHTML = formatMarkdownContent(content);
                    document.getElementById('aiKeyFindingsSection').style.display = 'block';
                    
                    // Show the Population Demographics caption section after Key Findings
                    const captionSection = document.getElementById('populationDemographicsCaptionSection');
                    if (captionSection) {
                        captionSection.style.display = 'block';
                    }
                }
            }
            
            // Populate demographic overview intro (hardcoded two sentences) and discussion
            const demographicOverviewIntroEl = document.getElementById('demographicOverviewIntro');
            if (demographicOverviewIntroEl && metadata && metadata.years && metadata.years.length > 0) {
                const years = metadata.years;
                const yearRange = years.length > 1 
                    ? `${Math.min(...years)} to ${Math.max(...years)}`
                    : years[0].toString();
                demographicOverviewIntroEl.textContent = `This table shows lending activity by race and ethnicity over the time period ${yearRange}, including the number and percentage of loans to each race and ethnic group. Percentages are calculated using loans with demographic data as the denominator (loans without race/ethnicity data are excluded from the calculation). The table includes a change column showing the increase or decrease of each group over the entire span of years in the report, with positive changes displayed in blue and negative changes in red.`;
            }
            
            if (aiInsights.demographic_overview_discussion) {
                console.log('[DEBUG] Found demographic_overview_discussion, length:', aiInsights.demographic_overview_discussion.length);
                const discussionEl = document.getElementById('demographicOverviewDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.demographic_overview_discussion);
                    discussionEl.style.display = 'block'; // Ensure it's visible
                    console.log('[DEBUG] Populated demographicOverviewDiscussion element');
                    
                    // Show AI caption
                    const aiCaption = document.getElementById('demographicOverviewAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                } else {
                    console.error('[ERROR] Could not find demographicOverviewDiscussion element');
                }
            } else {
                console.warn('[WARNING] demographic_overview_discussion is missing or empty from aiInsights');
                // Show appropriate message based on whether AI is disabled
                const discussionEl = document.getElementById('demographicOverviewDiscussion');
                if (discussionEl) {
                    if (aiDisabled) {
                        discussionEl.innerHTML = getAIDisabledMessage();
                    } else {
                        discussionEl.innerHTML = '<p><em>Analysis narrative is being generated. Please refresh the page in a moment.</em></p>';
                    }
                    discussionEl.style.display = 'block';
                }
            }
            
            // Populate income borrowers discussion (Table 1) - only if specific discussion exists
            if (aiInsights.income_borrowers_discussion) {
                const discussionEl = document.getElementById('incomeBorrowersDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.income_borrowers_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('incomeBorrowersAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                }
            }
            // No fallback - combined discussion appears only in incomeNeighborhoodDiscussion section

            // Populate income tracts discussion (Table 2) - only if specific discussion exists
            if (aiInsights.income_tracts_discussion) {
                const discussionEl = document.getElementById('incomeTractsDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.income_tracts_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('incomeTractsAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                }
            }
            // No fallback - combined discussion appears only in incomeNeighborhoodDiscussion section

            // Populate minority tracts discussion (Table 3) - only if specific discussion exists
            if (aiInsights.minority_tracts_discussion) {
                const discussionEl = document.getElementById('minorityTractsDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.minority_tracts_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('minorityTractsAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                }
            }
            // No fallback - combined discussion appears only in incomeNeighborhoodDiscussion section

            // Combined income and neighborhood indicators discussion (Section 2)
            // Always show the combined "Neighborhood Overview" narrative below individual table narratives
            if (aiInsights.income_neighborhood_discussion) {
                const discussionContentEl = document.getElementById('incomeNeighborhoodDiscussionContent');
                const discussionContainerEl = document.getElementById('incomeNeighborhoodDiscussion');
                if (discussionContentEl) {
                    discussionContentEl.innerHTML = formatMarkdownContent(aiInsights.income_neighborhood_discussion);
                }
                if (discussionContainerEl) {
                    discussionContainerEl.style.display = 'block';
                }
                const aiCaption = document.getElementById('incomeNeighborhoodAICaption');
                if (aiCaption) {
                    aiCaption.style.display = 'block';
                }
            } else if (aiDisabled) {
                const discussionContentEl = document.getElementById('incomeNeighborhoodDiscussionContent');
                const discussionContainerEl = document.getElementById('incomeNeighborhoodDiscussion');
                if (discussionContentEl) {
                    discussionContentEl.innerHTML = getAIDisabledMessage();
                }
                if (discussionContainerEl) {
                    discussionContainerEl.style.display = 'block';
                }
            }
            
            // Top lenders intro is now static in the HTML template — no JS overwrite needed
            
            if (aiInsights.top_lenders_detailed_discussion) {
                console.log('[DEBUG] Found top_lenders_detailed_discussion, length:', aiInsights.top_lenders_detailed_discussion.length);
                const discussionEl = document.getElementById('topLendersDetailedDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.top_lenders_detailed_discussion);
                    discussionEl.style.display = 'block';
                    console.log('[DEBUG] Populated topLendersDetailedDiscussion element');
                    
                    // Show AI caption
                    const aiCaption = document.getElementById('topLendersDetailedAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                } else {
                    console.error('[ERROR] Could not find topLendersDetailedDiscussion element');
                }
            } else {
                console.warn('[WARNING] top_lenders_detailed_discussion is missing or empty from aiInsights');
                // Show appropriate message based on whether AI is disabled
                const discussionEl = document.getElementById('topLendersDetailedDiscussion');
                if (discussionEl) {
                    if (aiDisabled) {
                        discussionEl.innerHTML = getAIDisabledMessage();
                        discussionEl.style.display = 'block';
                    }
                }
            }
            
            if (aiInsights.bank_strategies) {
                const content = aiInsights.bank_strategies;
                const element = document.getElementById('bankStrategiesContent');
                if (element) {
                    element.innerHTML = formatMarkdownContent(content);
                    document.getElementById('aiBankStrategiesSection').style.display = 'block';
                }
            }
            
            if (aiInsights.community_impact) {
                const content = aiInsights.community_impact;
                const element = document.getElementById('communityImpactContent');
                if (element) {
                    element.innerHTML = formatMarkdownContent(content);
                    document.getElementById('aiCommunityImpactSection').style.display = 'block';
                }
            }
            
            if (aiInsights.trends_analysis) {
                const content = aiInsights.trends_analysis;
                const element = document.getElementById('trendsAnalysisContent');
                if (element) {
                    element.innerHTML = formatMarkdownContent(content);
                    document.getElementById('aiTrendsAnalysisSection').style.display = 'block';
                }
            }
        }
        
        function formatMarkdownContent(content) {
            // Split into paragraphs
            const paragraphs = content.split('\n\n').filter(p => p.trim());
            
            return paragraphs.map(paragraph => {
                let formatted = paragraph.trim();
                
                // Remove lines that start with ## (markdown headers) since we already have section titles
                const lines = formatted.split('\n');
                const filteredLines = lines.filter(line => {
                    const trimmed = line.trim();
                    // Skip lines that start with ## (markdown headers)
                    return !trimmed.startsWith('##');
                });
                formatted = filteredLines.join('\n').trim();
                
                // Skip empty paragraphs after filtering
                if (!formatted) {
                    return '';
                }
                
                // Convert **text** to <strong>text</strong>
                formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                
                // Convert markdown links [text](url) to <a href="url">text</a>
                formatted = formatted.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                
                // Convert bullet points • to proper list items
                if (formatted.includes('•')) {
                    const lines = formatted.split('\n');
                    const listItems = lines.map(line => {
                        if (line.trim().startsWith('•')) {
                            return `<li>${line.trim().substring(1).trim()}</li>`;
                        }
                        return line;
                    });
                    
                    // Check if we have list items
                    const hasListItems = listItems.some(item => item.startsWith('<li>'));
                    if (hasListItems) {
                        // Group consecutive list items
                        let result = '';
                        let inList = false;
                        
                        for (let i = 0; i < listItems.length; i++) {
                            const item = listItems[i];
                            if (item.startsWith('<li>')) {
                                if (!inList) {
                                    result += '<ul>';
                                    inList = true;
                                }
                                result += item;
                            } else {
                                if (inList) {
                                    result += '</ul>';
                                    inList = false;
                                }
                                if (item.trim()) {
                                    result += `<p>${item}</p>`;
                                }
                            }
                        }
                        
                        if (inList) {
                            result += '</ul>';
                        }
                        
                        return result;
                    }
                }
                
                return `<p>${formatted}</p>`;
            }).filter(p => p).join(''); // Filter out empty strings
        }
        
        function populateSummaryCards(rawData) {
            if (!rawData || rawData.length === 0) return;
            
            const cardsContainer = document.getElementById('summaryCards');
            
            // Find the latest year from the data
            const years = [...new Set(rawData.map(row => row['year']))].sort((a, b) => b - a);
            const latestYear = years[0];
            
            // Update the section title with the latest year
            const titleElement = document.getElementById('latestStatsTitle');
            if (titleElement) {
                titleElement.textContent = `Latest Statistics (${latestYear})`;
            }
            
            // Filter data for the latest year only
            const latestYearData = rawData.filter(row => row['year'] === latestYear);
            
            // Compute unique branches by uninumbr for the latest year only
            // Properly dedupe: LMI only, MMCT only, and both
            const uniqueAll = new Set();
            const uniqueLMIOnly = new Set();      // LMI=1, MMCT=0
            const uniqueMMCTOnly = new Set();     // LMI=0, MMCT=1
            const uniqueBoth = new Set();         // LMI=1, MMCT=1
            
            latestYearData.forEach(row => {
                const id = row['uninumbr'];
                if (id !== null && id !== undefined) {
                    uniqueAll.add(id);
                    
                    // Check LMI and MMCT status
                    const isLMI = (row['lmict'] === 1 || row['br_lmi'] === 1);
                    const isMMCT = (row['mmct'] === 1 || row['br_minority'] === 1);
                    
                    if (isLMI && !isMMCT) {
                        uniqueLMIOnly.add(id);
                    } else if (!isLMI && isMMCT) {
                        uniqueMMCTOnly.add(id);
                    } else if (isLMI && isMMCT) {
                        uniqueBoth.add(id);
                    }
                }
            });
            
            const totalBranches = uniqueAll.size;
            const lmiOnlyCount = uniqueLMIOnly.size;
            const mmctOnlyCount = uniqueMMCTOnly.size;
            const bothCount = uniqueBoth.size;
            
            // Calculate percentages
            const lmiOnlyPct = totalBranches > 0 ? ((lmiOnlyCount / totalBranches) * 100).toFixed(1) : '0.0';
            const mmctOnlyPct = totalBranches > 0 ? ((mmctOnlyCount / totalBranches) * 100).toFixed(1) : '0.0';
            const bothPct = totalBranches > 0 ? ((bothCount / totalBranches) * 100).toFixed(1) : '0.0';
            
            cardsContainer.innerHTML = `
                <div class="summary-card">
                    <h3>${totalBranches.toLocaleString()}</h3>
                    <p>Total Branches (${latestYear})</p>
                </div>
                <div class="summary-card">
                    <h3>${lmiOnlyCount.toLocaleString()} <span class="percentage-text">(${lmiOnlyPct}%)</span></h3>
                    <p>LMI Only Branches (${latestYear})</p>
                </div>
                <div class="summary-card">
                    <h3>${mmctOnlyCount.toLocaleString()} <span class="percentage-text">(${mmctOnlyPct}%)</span></h3>
                    <p>MMCT Only Branches (${latestYear})</p>
                </div>
                <div class="summary-card">
                    <h3>${bothCount.toLocaleString()} <span class="percentage-text">(${bothPct}%)</span></h3>
                    <p>Both LMICT/MMCT Branches (${latestYear})</p>
                </div>
            `;
        }
        
        function toggleTable(tableId) {
            const table = document.getElementById(tableId);
            const button = table.previousElementSibling.querySelector('.collapse-btn');
            const icon = button.querySelector('i');
            
            if (table.classList.contains('collapsed')) {
                // Expand table - show all rows
                table.classList.remove('collapsed');
                button.classList.remove('collapsed');
                icon.style.transform = 'rotate(0deg)';
                
                // Show all rows
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => row.style.display = '');
            } else {
                // Collapse table - show only first 3 rows with fade
                table.classList.add('collapsed');
                button.classList.add('collapsed');
                icon.style.transform = 'rotate(-90deg)';
                
                // Hide rows beyond the first 3
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach((row, index) => {
                    if (index >= 3) {
                        row.style.display = 'none';
                    }
                });
            }
        }
        
        function populateTable(tableId, data, metadata = null, tableKey = null) {
            if (!data || data.length === 0) return;
            
            const table = document.getElementById(tableId);
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            // Special handling for summaryTable (transposed structure)
            if (tableId === 'summaryTable') {
                // Get all column names (Variable + years)
                const columns = Object.keys(data[0]);
                const variableCol = 'Variable';
                const yearCols = columns.filter(col => col !== variableCol).sort((a, b) => {
                    // Put "Net Change" at the end
                    if (a === 'Net Change') return 1;
                    if (b === 'Net Change') return -1;
                    // Sort numeric years
                    return parseInt(a) - parseInt(b);
                });
                
                // Build header row
                let headerRow = `<tr><th style="text-align: left;">${variableCol}</th>`;
                yearCols.forEach(year => {
                    headerRow += `<th style="text-align: center;">${year}</th>`;
                });
                headerRow += '</tr>';
                thead.innerHTML = headerRow;
                
                // Build data rows
                tbody.innerHTML = data.map(row => {
                    let cells = `<td style="text-align: left; font-weight: 600;">${row[variableCol]}</td>`;
                    yearCols.forEach(year => {
                        let value = row[year];
                        if (value === null || value === undefined) {
                            value = 0;
                        }
                        // Format as number with commas
                        const formatted = typeof value === 'number' ? value.toLocaleString() : value;
                        
                        // Apply color coding for Net Change column (same as bankTable)
                        if (year === 'Net Change') {
                            const numValue = typeof value === 'number' ? value : parseFloat(value);
                            const color = numValue < 0 ? 'red' : (numValue > 0 ? '#2fade3' : 'black');
                            cells += `<td style="text-align: center; color: ${color}; font-weight: 600;">${formatted}</td>`;
                        } else {
                            cells += `<td style="text-align: center;">${formatted}</td>`;
                        }
                    });
                    return `<tr>${cells}</tr>`;
                }).join('');
                
                // Populate caption with metadata
                if (metadata) {
                    const caption = document.getElementById('summaryTableCaption');
                    if (caption) {
                        const counties = metadata.counties || [];
                        const years = metadata.years || [];
                        const countyCount = counties.length;
                        
                        let captionText = '<strong>Source:</strong> FDIC Summary of Deposits';
                        
                        if (countyCount > 1) {
                            captionText += ` | <strong>Note:</strong> Data for ${countyCount} counties (${counties.join(', ')}) are summed across all years shown.`;
                        } else if (countyCount === 1) {
                            captionText += ` | <strong>County:</strong> ${counties[0]}`;
                        }
                        
                        if (years && years.length > 0) {
                            const yearRange = years.length > 1 
                                ? `${Math.min(...years)}-${Math.max(...years)}`
                                : years[0].toString();
                            captionText += ` | <strong>Years:</strong> ${yearRange}`;
                        }
                        
                        caption.innerHTML = captionText;
                    }
                }
                
                return;
            }
            
            // Standard table population for other tables
            // Get the table headers to determine column order
            const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
            
            tbody.innerHTML = data.map((row, rowIndex) => {
                // Map data to columns in the correct order based on table headers
                const cells = headers.map(header => {
                    let value = row[header];
                    if (value === null || value === undefined) {
                        return '';
                    }
                    
                    // Format based on column type
                    if (header.toLowerCase().includes('year')) {
                        // Years should not have commas
                        return value.toString();
                    } else if (header.includes('%') || header.toLowerCase().includes('percent')) {
                        // Percentage fields
                        if (typeof value === 'number') {
                            return value.toFixed(1) + '%';
                        }
                        return value + '%';
                    } else if (header.toLowerCase().includes('yoy') || header.toLowerCase().includes('change')) {
                        // YoY change fields - add + for positive values
                        if (typeof value === 'number') {
                            if (value > 0) {
                                return '+' + value.toFixed(1) + '%';
                            } else {
                                return value.toFixed(1) + '%';
                            }
                        }
                        return value;
                    } else if (typeof value === 'number') {
                        // Regular numbers with commas
                        return value.toLocaleString();
                    }
                    return value;
                });
                
                // Special handling for bankTable - first column (Bank Name) should be left-aligned
                // Also handle Net Change column with color coding
                if (tableId === 'bankTable') {
                    const bankNameCell = cells[0];
                    const otherCellsArray = cells.slice(1);
                    const otherCells = otherCellsArray.map((cell, idx) => {
                        // Check if this is the Net Change column (last column)
                        // Header may be "Net Change" or "Net Change (YYYY-YYYY)"
                        const headerIndex = idx + 1; // +1 because we sliced off the first cell
                        const headerText = headerIndex < headers.length ? headers[headerIndex] : '';
                        if (headerText && headerText.startsWith('Net Change')) {
                            const netChangeValue = row['Net Change'];
                            if (netChangeValue !== null && netChangeValue !== undefined) {
                                const numValue = typeof netChangeValue === 'number' ? netChangeValue : parseFloat(netChangeValue);
                                const color = numValue < 0 ? 'red' : (numValue > 0 ? '#2fade3' : 'black');
                                const formatted = typeof numValue === 'number' ? numValue.toLocaleString() : numValue;
                                return `<td style="text-align: center; color: ${color}; font-weight: 600;">${formatted}</td>`;
                            }
                        }
                        return `<td style="text-align: center;">${cell}</td>`;
                    });
                    // Hide rows beyond the first 10 (index 0-9)
                    const isHidden = rowIndex >= 10 ? 'style="display: none;"' : '';
                    return `<tr data-index="${rowIndex}" ${isHidden}><td style="text-align: left; font-weight: 600;">${bankNameCell}</td>${otherCells.join('')}</tr>`;
                }
                
                return `<tr>${cells.map(cell => `<td style="text-align: center;">${cell}</td>`).join('')}</tr>`;
            }).join('');
            
            // Populate caption for bankTable
            if (tableId === 'bankTable' && metadata) {
                const caption = document.getElementById('bankTableCaption');
                if (caption) {
                    const years = metadata.years || [];
                    const latestYear = years.length > 0 ? Math.max(...years) : '';
                    let captionText = '<strong>Source:</strong> FDIC Summary of Deposits';
                    if (latestYear) {
                        captionText += ` | <strong>Year:</strong> ${latestYear} (most recent year in report)`;
                    }
                    caption.innerHTML = captionText;
                }
            }
            
            // Populate caption for countyTable
            if (tableId === 'countyTable' && metadata) {
                const caption = document.getElementById('countyTableCaption');
                if (caption) {
                    const years = metadata.years || [];
                    const latestYear = years.length > 0 ? Math.max(...years) : '';
                    const counties = metadata.counties || [];
                    let captionText = '<strong>Source:</strong> FDIC Summary of Deposits';
                    if (latestYear) {
                        captionText += ` | <strong>Year:</strong> ${latestYear} (most recent year in report)`;
                    }
                    if (counties.length > 1) {
                        captionText += ` | <strong>Counties:</strong> ${counties.join(', ')}`;
                    }
                    caption.innerHTML = captionText;
                }
            }
        }
        
        // ========== Unified Data Table Component ==========
        function parsePercentageValue(val) {
            if (val === null || val === undefined || val === '') return NaN;
            const str = String(val).trim();
            if (str.endsWith('%')) return parseFloat(str.replace('%', ''));
            return NaN;
        }

        function parseChangeValue(val) {
            if (val === null || val === undefined || val === '') return null;
            const str = String(val).trim();
            const match = str.match(/^([+-]?)(\d+\.?\d*)\s*(pp|%)?$/);
            if (!match) return { value: 0, positive: false, unit: 'pp', display: str };
            const sign = match[1];
            const num = parseFloat(match[2]);
            const unit = match[3] || 'pp';
            const value = sign === '-' ? -num : num;
            return { value, positive: value > 0, unit, display: str };
        }

        function createSparklineSVG(values, isPositiveTrend) {
            if (!values || values.length < 2) return '';
            const w = 60, h = 18, p = 2;
            const pw = w - p * 2, ph = h - p * 2;
            const mn = Math.min(...values), mx = Math.max(...values);
            const rng = mx - mn || 1;
            const pts = values.map((v, i) => {
                const x = p + (i / (values.length - 1)) * pw;
                const y = p + ph - ((v - mn) / rng) * ph;
                return `${x.toFixed(1)},${y.toFixed(1)}`;
            });
            const color = isPositiveTrend ? '#1a8fc9' : '#DC2626';
            const lx = (p + pw).toFixed(1);
            const ly = (p + ph - ((values[values.length - 1] - mn) / rng) * ph).toFixed(1);
            return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" style="vertical-align:middle;"><polyline points="${pts.join(' ')}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linejoin="round" stroke-linecap="round"/><circle cx="${lx}" cy="${ly}" r="2.5" fill="${color}"/></svg>`;
        }

        function createChangeArrow(changeStr) {
            const parsed = parseChangeValue(changeStr);
            if (!parsed) return '<span class="change-neutral">&mdash;</span>';
            if (Math.abs(parsed.value) < 0.05) return `<span class="change-neutral">0.0${parsed.unit}</span>`;
            const arrow = parsed.positive ? '&#9650;' : '&#9660;';
            const cls = parsed.positive ? 'change-positive' : 'change-negative';
            return `<span class="${cls}">${arrow} ${parsed.display}</span>`;
        }

        function createShareBar(popShare, lendShare, maxValue) {
            if (isNaN(popShare) && isNaN(lendShare)) return '';
            const safeMax = maxValue || 100;
            const scale = 100 / (safeMax * 1.5);
            const pw = isNaN(popShare) ? 0 : Math.max(popShare * scale, 0.5);
            const lw = isNaN(lendShare) ? 0 : Math.max(lendShare * scale, 0.5);
            const pl = isNaN(popShare) ? '' : popShare.toFixed(1);
            const ll = isNaN(lendShare) ? '' : lendShare.toFixed(1);
            return `<div class="share-bar-container"><div class="share-bar-row"><div class="share-bar" style="width:${pw}%;background:#E07C39;"></div><span class="share-bar-label" style="color:#E07C39;">${pl}</span></div><div class="share-bar-row"><div class="share-bar" style="width:${lw}%;background:#1a8fc9;"></div><span class="share-bar-label" style="color:#1a8fc9;">${ll}</span></div></div>`;
        }

        function getHeatMapColor(value, min, max) {
            if (isNaN(value) || min === max) return 'transparent';
            const norm = Math.max(0, Math.min(1, (value - min) / (max - min)));
            const alpha = 0.06 + (norm * 0.22);
            return `rgba(26,143,201,${alpha.toFixed(3)})`;
        }

        function renderUnifiedTable(tableId, data, opts, metadata) {
            if (!data || data.length === 0) return;
            const table = document.getElementById(tableId);
            if (!table) { console.warn('[renderUnifiedTable] ' + tableId + ' not found'); return; }
            table.classList.remove('data-table');
            table.classList.add('unified-table');
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            if (!thead || !tbody) return;

            const mode = opts.mode || 'optionC';
            const isAgg = opts.isAggregateRow || (() => false);
            const isDet = opts.isDetailRow || (() => false);
            const mw = opts.metricMinWidth || '200px';

            const cols = Object.keys(data[0]);
            const metricCol = 'Metric';
            const popShareCol = 'Population Share (%)';
            const hidePopShare = opts.hidePopShare || false;
            const hasPop = cols.includes(popShareCol) && !hidePopShare;
            const changeCol = cols.find(c => c === 'Change' || c.startsWith('Change Over Time'));
            const yearCols = cols.filter(c => c !== metricCol && c !== popShareCol && c !== changeCol && !c.startsWith('Change') && !isNaN(parseInt(c))).sort((a, b) => parseInt(a) - parseInt(b));
            const latestYear = yearCols[yearCols.length - 1];
            const has2022 = yearCols.includes('2022');

            // Heat map range (percentage rows only)
            let hMin = Infinity, hMax = -Infinity;
            data.forEach(row => {
                if (row[metricCol] === 'Total Loans') return;
                yearCols.forEach(y => {
                    const v = parsePercentageValue(row[y]);
                    if (!isNaN(v)) { if (v < hMin) hMin = v; if (v > hMax) hMax = v; }
                });
            });
            if (hMin === Infinity) hMin = 0;
            if (hMax === -Infinity) hMax = 100;

            // Share bar max (Option A)
            let sbMax = 0;
            if (mode === 'optionA') {
                data.forEach(row => {
                    if (row[metricCol] === 'Total Loans') return;
                    const p = parsePercentageValue(row[popShareCol]);
                    const l = parsePercentageValue(row[latestYear]);
                    if (!isNaN(p) && p > sbMax) sbMax = p;
                    if (!isNaN(l) && l > sbMax) sbMax = l;
                });
            }

            // ===== THEAD =====
            let hdrHtml = '';
            if (has2022) {
                let lr = '<tr class="census-label-row">';
                lr += '<th></th>';
                if (hasPop) lr += '<th></th>';
                if (mode === 'optionA') lr += '<th></th>';
                yearCols.forEach(y => {
                    lr += y === '2022'
                        ? '<th class="census-boundary" style="white-space:nowrap;font-size:11px;">New Census Boundaries</th>'
                        : '<th></th>';
                });
                lr += '<th></th>';
                if (changeCol) lr += '<th></th>';
                lr += '</tr>';
                hdrHtml += lr;
            }
            let mh = '<tr>';
            const metricLabel = opts.metricLabel || 'Metric';
            mh += `<th style="text-align:left;width:240px;">${metricLabel}</th>`;
            if (hasPop) mh += '<th class="pop-share-col">Pop.&nbsp;Share</th>';
            if (mode === 'optionA') mh += '<th class="share-bar-col">Pop.&nbsp;vs&nbsp;Lending</th>';
            yearCols.forEach(y => {
                const cls = ['year-col'];
                if (y === latestYear) cls.push('year-latest');
                if (y === '2022') cls.push('census-boundary');
                mh += `<th class="${cls.join(' ')}">${y}</th>`;
            });
            mh += '<th class="year-col year-latest" style="min-width:65px;">Trend</th>';
            if (changeCol) mh += '<th class="year-col year-latest" style="min-width:80px;">Change</th>';
            mh += '</tr>';
            hdrHtml += mh;
            thead.innerHTML = hdrHtml;

            // ===== TBODY =====
            const shortenLabel = opts.shortenLabel || (m => m);
            const bodyHtml = data.map(row => {
                const metric = row[metricCol];
                const displayMetric = shortenLabel(metric);
                const isTotal = metric === 'Total Loans';
                const agg = isAgg(metric);
                const det = isDet(metric);
                const rc = isTotal ? 'total-row' : (agg ? 'aggregate-row' : (det ? 'detail-row' : ''));
                let cells = '';

                cells += `<td style="text-align:left;width:240px;">${displayMetric}</td>`;

                if (hasPop) {
                    let pv = row[popShareCol];
                    if (pv === null || pv === undefined || pv === '') pv = '';
                    cells += `<td class="pop-share-col" style="text-align:center;">${pv}</td>`;
                }

                if (mode === 'optionA') {
                    if (isTotal) {
                        cells += '<td class="share-bar-cell"></td>';
                    } else {
                        const pn = parsePercentageValue(row[popShareCol]);
                        const ln = parsePercentageValue(row[latestYear]);
                        cells += `<td class="share-bar-cell">${createShareBar(pn, ln, sbMax)}</td>`;
                    }
                }

                const sparkVals = [];
                yearCols.forEach(y => {
                    let val = row[y];
                    if (val === null || val === undefined) val = isTotal ? '0' : '0.0%';
                    const isLat = y === latestYear;
                    const is22 = y === '2022';
                    const cls = ['year-col'];
                    if (isLat) cls.push('year-latest');
                    if (is22) cls.push('census-boundary');
                    const pv = parsePercentageValue(val);
                    if (!isTotal && !isNaN(pv)) {
                        sparkVals.push(pv);
                    } else if (isTotal) {
                        const cv = parseInt(String(val).replace(/,/g, ''));
                        if (!isNaN(cv)) sparkVals.push(cv);
                    }
                    let bg = '';
                    if (!isTotal && !isNaN(pv)) bg = `background-color:${getHeatMapColor(pv, hMin, hMax)};`;
                    const fw = isTotal ? 'font-weight:600;' : '';
                    cells += `<td class="${cls.join(' ')} heatmap-cell" style="text-align:center;${bg}${fw}">${val}</td>`;
                });

                const trend = sparkVals.length >= 2 ? sparkVals[sparkVals.length - 1] >= sparkVals[0] : true;
                cells += `<td class="sparkline-cell year-col year-latest">${createSparklineSVG(sparkVals, trend)}</td>`;

                if (changeCol) {
                    cells += `<td class="change-cell year-col year-latest">${createChangeArrow(row[changeCol])}</td>`;
                }

                return `<tr class="${rc}">${cells}</tr>`;
            }).join('');
            tbody.innerHTML = bodyHtml;
        }

        function populateDemographicOverviewTable(data, metadata) {
            if (!data || data.length === 0) return;
            console.log('populateDemographicOverviewTable called with:', { dataLength: data.length });

            renderUnifiedTable('demographicOverviewTable', data, {
                mode: 'optionA',
                hidePopShare: true,
                metricLabel: 'Race / Ethnicity',
                isAggregateRow: () => false,
                isDetailRow: () => false
            }, metadata);

            // Show section
            const section = document.getElementById('demographicOverviewTableSection');
            if (section) section.style.display = 'block';

            // Populate caption
            if (metadata) {
                const caption = document.getElementById('demographicOverviewCaption');
                if (caption) {
                    const counties = metadata.counties || [];
                    const years = metadata.years || [];
                    const yearRange = years.length > 1 ? `${Math.min(...years)}-${Math.max(...years)}` : (years[0] ? years[0].toString() : '');
                    const firstYear = years.length > 0 ? Math.min(...years) : '';
                    const lastYear = years.length > 0 ? Math.max(...years) : '';
                    let captionText = '<strong>Source:</strong> Home Mortgage Disclosure Act (HMDA) data, compiled and maintained in NCRC\'s curated databases. ';
                    captionText += '<strong>Methodology:</strong> Percentages are calculated as (group loans / loans with demographic data) × 100. Groups < 1% excluded. ';
                    if (firstYear && lastYear) captionText += `<strong>Note:</strong> Change column shows ${firstYear} through ${lastYear}. `;
                    if (counties.length > 0) captionText += `| <strong>Counties:</strong> ${counties.join(', ')} `;
                    if (yearRange) captionText += `| <strong>Years:</strong> ${yearRange}`;
                    caption.innerHTML = captionText;
                }
            }
        }
        
        // REMOVED: populateIncomeNeighborhoodTable - consolidated into income_borrowers, income_tracts, minority_tracts tables

        function populateIncomeBorrowersTable(data, metadata) {
            if (!data || data.length === 0) return;

            renderUnifiedTable('incomeBorrowersTable', data, {
                mode: 'optionC',
                metricLabel: 'Borrower Income',
                isAggregateRow: m => m.includes('Low-to-Moderate') || m.includes('Low to Moderate'),
                isDetailRow: m => /^(Low|Moderate)\s+Income\s+Borrower/i.test(m),
                shortenLabel: m => m.replace(/\s+Income\s+Borrowers?/i, '').replace('Low-to-Moderate', 'Low to Moderate')
            }, metadata);
        }
        
        function populateIncomeTractsTable(data, metadata) {
            if (!data || data.length === 0) return;

            renderUnifiedTable('incomeTractsTable', data, {
                mode: 'optionC',
                metricLabel: 'Tract Median Income',
                isAggregateRow: m => m.includes('Low-to-Moderate') || m.includes('Low to Moderate'),
                isDetailRow: m => /^(Low|Moderate)\s+Income\s+Census/i.test(m),
                shortenLabel: m => m.replace(/\s+Income\s+Census\s+Tracts?\*?/i, '').replace('Low-to-Moderate', 'Low to Moderate')
            }, metadata);

            // Check for asterisk note
            const hasAsterisk = data.some(row => row['Metric'] && row['Metric'].includes('Low Income Census Tracts*'));
            if (hasAsterisk && metadata && metadata.counties && metadata.counties.length > 0) {
                const countyName = metadata.counties[0];
                const asteriskNote = document.getElementById('section2AsteriskNote');
                if (asteriskNote) {
                    asteriskNote.innerHTML = ` <strong>Note:</strong> Columns marked with an asterisk * show 0% because ${countyName} has no census tracts classified as Low Income based on Area Median Income (AMI).`;
                    asteriskNote.style.display = 'inline';
                }
            }
        }
        
        function populateMinorityTractsTable(data, metadata) {
            if (!data || data.length === 0) return;

            renderUnifiedTable('minorityTractsTable', data, {
                mode: 'optionC',
                metricLabel: 'Tract Minority Population',
                isAggregateRow: m => m.includes('Majority Minority'),
                isDetailRow: m => /^(Low|Moderate|Middle|High)\s+Minority/i.test(m),
                shortenLabel: m => {
                    if (m.includes('Majority Minority')) {
                        return 'Majority Minority (\u226550%)';
                    }
                    // "Low Minority Census Tracts (0-45.8%)" → "Low (0-45.8%)"
                    const match = m.match(/^(\w+)\s+Minority\s+Census\s+Tracts?\s*(\(.*\))?/i);
                    if (match) return match[1] + (match[2] ? ' ' + match[2] : '');
                    return m;
                }
            }, metadata);

            // Check for MMCT asterisk note
            const hasAsterisk = data.some(row => row['Metric'] && row['Metric'].includes('Majority Minority Census Tracts*'));
            if (hasAsterisk && metadata && metadata.counties && metadata.counties.length > 0) {
                const countyName = metadata.counties[0];
                const asteriskNote = document.getElementById('section2AsteriskNote');
                if (asteriskNote) {
                    const existingNote = asteriskNote.innerHTML;
                    const mmctNote = ` <strong>Note:</strong> The asterisk * following "Majority Minority Census Tracts" indicates that ${countyName} has no census tracts that meet the qualifications (≥50% minority population).`;
                    asteriskNote.innerHTML = existingNote + (existingNote ? ' ' : '') + mmctNote;
                    asteriskNote.style.display = 'inline';
                }
            }
        }
        
        // REMOVED: populateIncomeNeighborhoodTractsTable - consolidated into income_borrowers, income_tracts, minority_tracts tables

        function populateTopLendersDetailedTable(data, metadata) {
            if (!data || data.length === 0) {
                console.warn('No top lenders data available.');
                return;
            }
            
            const table = document.getElementById('topLendersDetailedTable');
            if (!table) {
                console.warn('[WARNING] topLendersDetailedTable not found, skipping population');
                return;
            }
            
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            if (!thead || !tbody) {
                console.warn('[WARNING] topLendersDetailedTable missing thead or tbody, skipping population');
                return;
            }
            
            // Get all column names (excluding Lender Name, Lender Type, and Total Loans)
            const columns = Object.keys(data[0]);
            const baseCols = ['Lender Name', 'Lender Type', 'Total Loans'];
            const dataCols = columns.filter(col => !baseCols.includes(col));
            
            // Sort data columns: race/ethnicity first, then income/neighborhood indicators
            // Note: Only columns >= 1% overall are included (determined in Python)
            const raceCols = dataCols.filter(col => col.includes('Hispanic') || col.includes('Black') || 
                                                    col.includes('White') || col.includes('Asian') || 
                                                    col.includes('Native American') || col.includes('Hawaiian'));
            const indicatorCols = dataCols.filter(col => col.includes('LMIB') || col.includes('LMICT') || col.includes('MMCT'));
            
            // Sort race columns in a consistent order
            const raceOrder = ['Hispanic (%)', 'Black (%)', 'White (%)', 'Asian (%)', 'Native American (%)', 'Hawaiian/Pacific Islander (%)'];
            const sortedRaceCols = raceOrder.filter(col => raceCols.includes(col));
            const otherRaceCols = raceCols.filter(col => !raceOrder.includes(col));
            const finalRaceCols = [...sortedRaceCols, ...otherRaceCols];
            
            // Sort indicator columns
            const indicatorOrder = ['LMIB (%)', 'LMICT (%)', 'MMCT (%)'];
            const sortedIndicatorCols = indicatorOrder.filter(col => indicatorCols.includes(col));
            const otherIndicatorCols = indicatorCols.filter(col => !indicatorOrder.includes(col));
            const finalIndicatorCols = [...sortedIndicatorCols, ...otherIndicatorCols];
            
            // Function to abbreviate column names for display (remove percentage signs)
            function abbreviateColumnName(col) {
                // Remove (%) from all column names
                let displayName = col.replace(' (%)', '');
                if (displayName === 'Native American') return 'Native Am.';
                if (displayName === 'Hawaiian/Pacific Islander') return 'Hawaiian/PI';
                return displayName;
            }
            
            // Build header row with uniform width for data columns and sorting functionality
            // Lender Name column: narrower but still fits long names like "UNITED SHORE FINANCIAL SERVICES" (35 chars)
            // Using smaller font or tighter spacing, but keeping white-space: nowrap
            let headerRow = `<tr>
                <th style="text-align: left; vertical-align: middle; cursor: pointer; user-select: none; white-space: nowrap; min-width: 280px; max-width: 280px; width: 280px; font-size: 0.9em;" onclick="sortTable('topLendersDetailedTable', 0, 'text')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();sortTable('topLendersDetailedTable', 0, 'text');}" tabindex="0" role="button" aria-label="Sort by Lender Name">
                    Lender Name <span class="sort-indicator" id="sort-indicator-0"></span>
                </th>
                <th style="text-align: center; vertical-align: middle; cursor: pointer; user-select: none; width: 90px; min-width: 90px; max-width: 90px; white-space: nowrap;" onclick="sortTable('topLendersDetailedTable', 1, 'text')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();sortTable('topLendersDetailedTable', 1, 'text');}" tabindex="0" role="button" aria-label="Sort by Lender Type">
                    Type <span class="sort-indicator" id="sort-indicator-1"></span>
                </th>
                <th style="text-align: center; cursor: pointer; user-select: none; vertical-align: middle; width: 90px; min-width: 90px; max-width: 90px;" onclick="sortTable('topLendersDetailedTable', 2, 'number')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();sortTable('topLendersDetailedTable', 2, 'number');}" tabindex="0" role="button" aria-label="Sort by Total Loans">
                    Total <span class="sort-indicator" id="sort-indicator-2"></span>
                </th>`;
            
            let colIndex = 3;
            // All data columns (race/ethnicity and indicators) use uniform width
            const uniformColWidth = '90px';
            finalRaceCols.forEach(col => {
                const displayName = abbreviateColumnName(col);
                headerRow += `<th style="text-align: center; vertical-align: middle; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth}; cursor: pointer; user-select: none;" onclick="sortTable('topLendersDetailedTable', ${colIndex}, 'number')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();sortTable('topLendersDetailedTable', ${colIndex}, 'number');}" tabindex="0" role="button" aria-label="Sort by ${displayName}">
                    ${displayName} <span class="sort-indicator" id="sort-indicator-${colIndex}"></span>
                </th>`;
                colIndex++;
            });
            
            finalIndicatorCols.forEach(col => {
                const displayName = abbreviateColumnName(col);
                headerRow += `<th style="text-align: center; vertical-align: middle; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth}; cursor: pointer; user-select: none;" onclick="sortTable('topLendersDetailedTable', ${colIndex}, 'number')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();sortTable('topLendersDetailedTable', ${colIndex}, 'number');}" tabindex="0" role="button" aria-label="Sort by ${displayName}">
                    ${displayName} <span class="sort-indicator" id="sort-indicator-${colIndex}"></span>
                </th>`;
                colIndex++;
            });
            
            headerRow += '</tr>';
            thead.innerHTML = headerRow;
            
            // Store original data for filtering
            window.topLendersData = data;
            // Store column structure for rebuilding table
            window.topLendersRaceCols = finalRaceCols;
            window.topLendersIndicatorCols = finalIndicatorCols;
            
            // Build data rows
            // Use uniform column width for all data columns (uniformColWidth already declared above)
            tbody.innerHTML = data.map((row, rowIndex) => {
                let cells = `<td style="text-align: left; font-weight: 600; white-space: nowrap; min-width: 280px; max-width: 280px; width: 280px; font-size: 0.9em;">${row['Lender Name']}</td>`;
                cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth}; white-space: nowrap;">${row['Lender Type'] || ''}</td>`;
                cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${row['Total Loans']}</td>`;
                
                finalRaceCols.forEach(col => {
                    const value = row[col] || '';
                    cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${value}</td>`;
                });
                
                finalIndicatorCols.forEach(col => {
                    const value = row[col] || '';
                    cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${value}</td>`;
                });
                
                // Hide rows beyond the first 10 (index 0-9) if there are more than 10 lenders
                const isHidden = (data.length > 10 && rowIndex >= 10) ? 'style="display: none;"' : '';
                return `<tr data-index="${rowIndex}" ${isHidden}>${cells}</tr>`;
            }).join('');
            
            // Show expand button only if there are more than 10 lenders
            console.log('[DEBUG] Checking if should show expand button: data.length =', data.length);
            if (data.length > 10) {
                const expandBtn = document.getElementById('expandTopLendersBtn');
                console.log('[DEBUG] expandBtn element found:', expandBtn ? 'yes' : 'no');
                if (expandBtn) {
                    expandBtn.style.display = 'inline-block';
                    console.log('[DEBUG] Set expandBtn display to inline-block');
                } else {
                    console.warn('[WARNING] expandTopLendersBtn element not found in DOM');
                }
            }
            
            // Populate caption
            if (metadata) {
                const caption = document.getElementById('topLendersDetailedCaption');
                if (caption) {
                    const years = metadata.years || [];
                    const latestYear = years.length > 0 ? Math.max(...years) : '';
                    const counties = metadata.counties || [];
                    
                    let captionText = '<strong>Source:</strong> Home Mortgage Disclosure Act (HMDA) data, compiled and maintained in NCRC\'s curated databases. ';
                    captionText += '<strong>Year:</strong> ' + latestYear + ' (most recent year in report). ';
                    captionText += '<strong>Methodology:</strong> Lenders are sorted in descending order by total loans. ';
                    captionText += 'Race/ethnicity percentages use denominator = loans with demographic data. ';
                    captionText += 'Income and neighborhood indicator percentages use denominator = total loans. ';
                    captionText += 'Only race/ethnicity groups representing ≥1% of overall lending are included. ';
                    captionText += '<strong>Note:</strong> All categories are in percentages. ';
                    captionText += '<strong>Abbreviations:</strong> Native Am. = Native American; Hawaiian/PI = Hawaiian/Pacific Islander.';
                    
                    if (counties.length > 0) {
                        captionText += ` | <strong>Counties:</strong> ${counties.join(', ')}`;
                    }
                    
                    caption.innerHTML = captionText;
                }
            }
        }
        
        function showError(message) {
            document.getElementById('loadingState').style.display = 'none';
            document.getElementById('errorState').style.display = 'block';
            const errorElement = document.getElementById('errorMessage');
            // Allow HTML in error messages (for links)
            errorElement.innerHTML = message;
        }
        
        // Function to expand/collapse bank table to show all banks or just top 10
        function expandBankTable() {
            const table = document.getElementById('bankTable');
            const rows = table.querySelectorAll('tbody tr');
            const expandBtn = document.getElementById('expandBankTableBtn');
            const icon = expandBtn.querySelector('i');
            
            // Check if currently showing all (rows 10+ are visible)
            const isExpanded = rows.length > 10 && rows[10].style.display !== 'none';
            
            if (isExpanded) {
                // Collapse to top 10
                rows.forEach((row, index) => {
                    if (index >= 10) {
                        row.style.display = 'none';
                    }
                });
                expandBtn.innerHTML = '<i class="fas fa-chevron-down"></i> Show All Banks';
            } else {
                // Expand to show all
                rows.forEach((row) => {
                    row.style.display = '';
                });
                expandBtn.innerHTML = '<i class="fas fa-chevron-up"></i> Show Top 10 Only';
            }
        }
        
        // Function to filter lenders by type and show top 10 of that type
        function filterLendersByType() {
            const filterValue = document.getElementById('lenderTypeFilter').value;
            const table = document.getElementById('topLendersDetailedTable');
            const tbody = table.querySelector('tbody');
            
            if (!window.topLendersData) {
                console.warn('No top lenders data available for filtering');
                return;
            }
            
            // Filter data by lender type
            let filteredData = window.topLendersData;
            if (filterValue !== 'all') {
                filteredData = window.topLendersData.filter(row => row['Lender Type'] === filterValue);
            }
            
            // Sort by Total Loans (descending) - parse the value to handle comma-separated numbers
            filteredData = filteredData.sort((a, b) => {
                const aTotal = parseInt(String(a['Total Loans']).replace(/,/g, '')) || 0;
                const bTotal = parseInt(String(b['Total Loans']).replace(/,/g, '')) || 0;
                return bTotal - aTotal;
            });
            
            // Always take top 10 (or fewer if less than 10) of the filtered/sorted data
            const topLenders = filteredData.slice(0, 10);
            
            // Get column structure from existing table
            const thead = table.querySelector('thead');
            const headerRow = thead.querySelector('tr');
            const columns = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim().split(' ')[0]);
            
            // Rebuild table rows with top lenders
            const uniformColWidth = '90px';
            const raceCols = window.topLendersRaceCols || [];
            const indicatorCols = window.topLendersIndicatorCols || [];
            
            // Build all rows (not just top 10) but hide rows beyond 10
            tbody.innerHTML = filteredData.map((row, rowIndex) => {
                let cells = `<td style="text-align: left; font-weight: 600; white-space: nowrap; min-width: 280px; max-width: 280px; width: 280px; font-size: 0.9em;">${row['Lender Name']}</td>`;
                cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth}; white-space: nowrap;">${row['Lender Type'] || ''}</td>`;
                cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${row['Total Loans']}</td>`;
                
                raceCols.forEach(col => {
                    const value = row[col] || '';
                    cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${value}</td>`;
                });
                
                indicatorCols.forEach(col => {
                    const value = row[col] || '';
                    cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${value}</td>`;
                });
                
                // Hide rows beyond the first 10 (index 0-9) if there are more than 10 lenders
                const isHidden = (filteredData.length > 10 && rowIndex >= 10) ? 'style="display: none;"' : '';
                return `<tr data-index="${rowIndex}" ${isHidden}>${cells}</tr>`;
            }).join('');
            
            // Update expand button - show it if there are more than 10 lenders, hide otherwise
            const expandBtn = document.getElementById('expandTopLendersBtn');
            if (expandBtn) {
                if (filteredData.length > 10) {
                    expandBtn.style.display = 'inline-block';
                    expandBtn.innerHTML = '<i class="fas fa-chevron-down"></i> Show All Lenders';
                } else {
                    expandBtn.style.display = 'none';
                }
            }
        }
        
        // Function to expand/collapse top lenders table to show all lenders or just top 10
        function expandTopLendersTable() {
            console.log('[DEBUG] expandTopLendersTable called');
            const table = document.getElementById('topLendersDetailedTable');
            if (!table) {
                console.error('topLendersDetailedTable not found');
                return;
            }

            const allRows = Array.from(table.querySelectorAll('tbody tr'));
            const expandBtn = document.getElementById('expandTopLendersBtn');

            console.log('[DEBUG] Total rows:', allRows.length);

            // Only proceed if there are more than 10 lenders
            if (allRows.length <= 10) {
                console.log('[DEBUG] 10 or fewer rows, nothing to expand');
                return;
            }

            // Check if currently expanded (row 10 is visible)
            const row10 = allRows[10];
            const isExpanded = row10 && row10.style.display !== 'none';
            console.log('[DEBUG] isExpanded:', isExpanded);

            if (isExpanded) {
                // Collapse to top 10
                allRows.forEach((row, index) => {
                    if (index >= 10) {
                        row.style.display = 'none';
                    }
                });
                if (expandBtn) {
                    expandBtn.innerHTML = '<i class="fas fa-chevron-down"></i> Show All Lenders';
                }
                console.log('[DEBUG] Collapsed to top 10');
            } else {
                // Expand to show all
                allRows.forEach((row) => {
                    row.style.display = '';
                });
                if (expandBtn) {
                    expandBtn.innerHTML = '<i class="fas fa-chevron-up"></i> Show Top 10 Only';
                }
                console.log('[DEBUG] Expanded to show all');
            }
        }
        
        // Chart instance for HHI chart (global to allow destruction)
        let hhiChartInstance = null;
        
        function populateMarketConcentrationTable(data, metadata) {
            if (!data || data.length === 0) {
                console.warn('No market concentration data available.');
                const section = document.getElementById('marketConcentrationSection');
                if (section) {
                    section.style.display = 'none';
                }
                return;
            }

            const section = document.getElementById('marketConcentrationSection');
            if (section) {
                section.style.display = 'block';
            }

            // Determine which loan purposes to show based on user selection
            const loanPurposes = metadata.loan_purpose
                ? (Array.isArray(metadata.loan_purpose) ? metadata.loan_purpose : [metadata.loan_purpose])
                : ['all'];

            // Map metadata purpose values to data row names
            const purposeMap = {
                'purchase': 'Home Purchase',
                'refinance': 'Refinance',
                'equity': 'Home Equity'
            };
            const purposeColors = {
                'All Loans': '#1e3a5f',
                'Home Purchase': '#1a8fc9',
                'Refinance': '#E07C39',
                'Home Equity': '#0d7377'
            };

            // Determine which rows to show
            const selectedPurposes = loanPurposes.filter(p => p !== 'all');
            const showAll = loanPurposes.includes('all') ||
                (selectedPurposes.includes('purchase') && selectedPurposes.includes('refinance') && selectedPurposes.includes('equity'));

            let displayRows;
            if (showAll) {
                // Show all 4 rows
                displayRows = data.filter(row => ['All Loans', 'Home Purchase', 'Refinance', 'Home Equity'].includes(row['Loan Purpose']));
            } else if (selectedPurposes.length === 1) {
                // Single purpose - show just that row
                const rowName = purposeMap[selectedPurposes[0]];
                const matchedRow = data.find(row => row['Loan Purpose'] === rowName);
                displayRows = matchedRow ? [matchedRow] : [data[0]];
            } else {
                // Multiple but not all - show selected rows
                const rowNames = selectedPurposes.map(p => purposeMap[p]).filter(Boolean);
                displayRows = data.filter(row => rowNames.includes(row['Loan Purpose']));
                if (displayRows.length === 0) displayRows = [data[0]];
            }

            const years = metadata && metadata.years ? metadata.years : [];
            if (years.length === 0) return;
            const sortedYears = [...years].sort((a, b) => a - b);

            // Populate table if it exists (may have been removed)
            const table = document.getElementById('marketConcentrationTable');
            if (table) {
                const thead = table.querySelector('thead');
                const tbody = table.querySelector('tbody');
                if (thead && tbody) {
                    if (displayRows.length === 1) {
                        thead.innerHTML = '<tr><th style="text-align:left;">Year</th><th style="text-align:center;">HHI</th></tr>';
                        tbody.innerHTML = sortedYears.map(year => {
                            const yearStr = year.toString();
                            const val = displayRows[0][yearStr] !== undefined ? displayRows[0][yearStr] : (displayRows[0][year] !== undefined ? displayRows[0][year] : 0);
                            return `<tr><td style="text-align:left;">${yearStr}</td><td style="text-align:center;">${Math.round(parseFloat(val) || 0).toLocaleString()}</td></tr>`;
                        }).join('');
                    } else {
                        let hdrRow = '<tr><th style="text-align:left;">Loan Purpose</th>';
                        sortedYears.forEach(y => { hdrRow += `<th style="text-align:center;">${y}</th>`; });
                        hdrRow += '</tr>';
                        thead.innerHTML = hdrRow;

                        tbody.innerHTML = displayRows.map(row => {
                            let cells = `<td style="text-align:left;font-weight:600;">${row['Loan Purpose']}</td>`;
                            sortedYears.forEach(year => {
                                const yearStr = year.toString();
                                const val = row[yearStr] !== undefined ? row[yearStr] : (row[year] !== undefined ? row[year] : 0);
                                cells += `<td style="text-align:center;">${Math.round(parseFloat(val) || 0).toLocaleString()}</td>`;
                            });
                            return `<tr>${cells}</tr>`;
                        }).join('');
                    }
                }
            }

            // Create Chart.js bar chart with threshold lines
            const hhiCanvas = document.getElementById('hhiChart');
            if (hhiCanvas && typeof Chart !== 'undefined') {
                const ctx = hhiCanvas.getContext('2d');
                if (hhiChartInstance) {
                    hhiChartInstance.destroy();
                }

                const yearsLabels = sortedYears.map(y => y.toString());

                // Build datasets - one per displayed loan purpose
                const datasets = displayRows.map(row => {
                    const purpose = row['Loan Purpose'];
                    const values = sortedYears.map(year => {
                        const yearStr = year.toString();
                        const val = parseFloat(row[yearStr] !== undefined ? row[yearStr] : (row[year] || 0));
                        return isNaN(val) ? 0 : val;
                    });
                    return {
                        label: purpose,
                        data: values,
                        backgroundColor: purposeColors[purpose] || '#1e3a5f',
                        borderColor: purposeColors[purpose] || '#1e3a5f',
                        borderWidth: 1
                    };
                });

                // Calculate y-axis max
                let maxHHI = 2500;
                datasets.forEach(ds => { ds.data.forEach(v => { if (v > maxHHI) maxHHI = v; }); });
                const yMax = Math.min(Math.max(maxHHI * 1.15, 3000), 10000);

                // Register annotation plugin if available
                if (typeof Chart !== 'undefined' && Chart.register) {
                    try {
                        const annotationPlugin = window.chartjsPluginAnnotation;
                        if (annotationPlugin) Chart.register(annotationPlugin);
                    } catch (e) {
                        console.warn('Chart.js annotation plugin not available');
                    }
                }

                const chartTitle = displayRows.length === 1
                    ? `Market Concentration (HHI) — ${displayRows[0]['Loan Purpose']}`
                    : 'Market Concentration (HHI) by Loan Purpose';

                hhiChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: { labels: yearsLabels, datasets: datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: { padding: { top: 10, bottom: 10, left: 10, right: 10 } },
                        plugins: {
                            legend: { display: displayRows.length > 1, position: 'top' },
                            title: {
                                display: true,
                                text: chartTitle,
                                font: { size: 14, weight: 'bold' }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const value = context.parsed.y;
                                        const prefix = displayRows.length > 1 ? context.dataset.label + ': ' : '';
                                        return prefix + 'HHI: ' + Math.round(value).toLocaleString();
                                    }
                                }
                            },
                            annotation: {
                                annotations: {
                                    moderateLine: {
                                        type: 'line', yMin: 1500, yMax: 1500,
                                        borderColor: 'rgba(255, 165, 0, 0.8)', borderWidth: 2, borderDash: [5, 5],
                                        label: { content: 'Moderate (1,500)', enabled: true, position: 'end',
                                            backgroundColor: 'rgba(255, 165, 0, 0.9)', color: 'white',
                                            font: { size: 11, weight: 'bold' }, padding: 4
                                        }
                                    },
                                    highLine: {
                                        type: 'line', yMin: 2500, yMax: 2500,
                                        borderColor: 'rgba(255, 0, 0, 0.8)', borderWidth: 2, borderDash: [5, 5],
                                        label: { content: 'High (2,500)', enabled: true, position: 'end',
                                            backgroundColor: 'rgba(255, 0, 0, 0.9)', color: 'white',
                                            font: { size: 11, weight: 'bold' }, padding: 4
                                        }
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true, max: yMax,
                                title: { display: true, text: 'HHI', font: { size: 12, weight: 'bold' } },
                                ticks: { callback: function(value) { return value.toLocaleString(); }, font: { size: 10 } },
                                grid: { drawOnChartArea: true }
                            },
                            x: {
                                title: { display: true, text: 'Year', font: { size: 12, weight: 'bold' } },
                                ticks: { font: { size: 10 } }
                            }
                        }
                    }
                });
            }

            // Populate AI discussion if available
            const aiInsights = metadata.ai_insights;
            const aiDisabled = metadata && metadata.ai_insights_enabled === false;
            const getAIDisabledMessage = () => {
                return '<div class="alert alert-info" style="padding: 15px; margin: 15px 0; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px;"><strong>AI Insights Not Available:</strong> AI-powered analysis is currently disabled. To enable AI insights, please configure the CLAUDE_API_KEY environment variable in your deployment settings.</div>';
            };

            const discussionEl = document.getElementById('marketConcentrationDiscussion');
            if (discussionEl) {
                if (aiInsights && aiInsights.market_concentration_discussion) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.market_concentration_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('marketConcentrationAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                } else {
                    if (aiDisabled) {
                        discussionEl.innerHTML = getAIDisabledMessage();
                    } else {
                        discussionEl.innerHTML = '<p><em>Analysis narrative is being generated. Please refresh the page in a moment.</em></p>';
                    }
                    discussionEl.style.display = 'block';
                }
            }
        }
        
        // Table sorting function
        let currentSortColumn = -1;
        let currentSortDirection = 'asc';
        
        function sortTable(tableId, columnIndex, dataType) {
            const table = document.getElementById(tableId);
            if (!table) return;
            
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Clear all sort indicators
            table.querySelectorAll('.sort-indicator').forEach(indicator => {
                indicator.textContent = '';
            });
            
            // Determine sort direction
            if (currentSortColumn === columnIndex) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = columnIndex;
                currentSortDirection = 'asc';
            }
            
            // Sort rows
            rows.sort((a, b) => {
                const aCell = a.cells[columnIndex];
                const bCell = b.cells[columnIndex];
                
                if (!aCell || !bCell) return 0;
                
                let aValue = aCell.textContent.trim();
                let bValue = bCell.textContent.trim();
                
                if (dataType === 'number') {
                    // Extract numeric value (remove % and commas)
                    aValue = parseFloat(aValue.replace(/[%,]/g, '')) || 0;
                    bValue = parseFloat(bValue.replace(/[%,]/g, '')) || 0;
                } else {
                    // Text comparison (case-insensitive)
                    aValue = aValue.toLowerCase();
                    bValue = bValue.toLowerCase();
                }
                
                if (aValue < bValue) return currentSortDirection === 'asc' ? -1 : 1;
                if (aValue > bValue) return currentSortDirection === 'asc' ? 1 : -1;
                return 0;
            });
            
            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
            
            // Update sort indicator
            const indicator = document.getElementById(`sort-indicator-${columnIndex}`);
            if (indicator) {
                indicator.textContent = currentSortDirection === 'asc' ? ' ▲' : ' ▼';
                indicator.setAttribute('aria-label', `Sorted ${currentSortDirection === 'asc' ? 'ascending' : 'descending'}`);
            }
        }
        
        // Update download links immediately (in case DOM is already loaded)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                updateDownloadLinks();
                setupPdfButton();
            });
        } else {
            updateDownloadLinks();
            setupPdfButton();
        }
        
        // Setup PDF button click handler
        // PDF button replaced with Print button - this function is kept for compatibility
        function setupPdfButton() {
            console.log('Print button available - use browser Print for PDF export');
        }
        
        // Tab navigation removed — report loads directly

        // populateOverview removed — Overview tab deleted

        // Load report data when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadReportData);
        } else {
            // DOM is already loaded, call immediately
            loadReportData();
        }
    </script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-analytics-compat.js"></script>

    <!-- JustData Auth -->
    <script src="/static/js/auth.js"></script>

    {% include 'shared_header_js.html' %}

    <!-- Shared Footer -->
    {% set app_name = "LendSight" %}
    {% include "shared_footer.html" %}
</body>
</html>
