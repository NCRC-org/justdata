<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LendSight - JustData</title>
    <meta name="description" content="HMDA Mortgage Lending Analysis Report - Comprehensive mortgage market intelligence">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <!-- Skip to main content link for screen readers -->
    <style>
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #034ea0;
            color: white;
            padding: 8px;
            text-decoration: none;
            z-index: 100;
        }
        .skip-link:focus {
            top: 0;
        }
    </style>
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="LendSight - Mortgage Lending Analysis Report">
    <meta property="og:description" content="Comprehensive HMDA mortgage lending analysis report">
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <!-- Shared Population Demographics Module -->
    <script src="/shared/population_demographics.js"></script>
    
    <style>
        /* Print-specific styles for PDF export - optimized for readability */
        @media print {
            .no-print { display: none !important; }
            /* Eliminate all page breaks - content flows naturally */
            .print-break { page-break-before: auto; }
            
            /* Base typography - improved readability */
            body { 
                font-size: 11pt; 
                line-height: 1.4;
                margin: 0;
                padding: 0;
                color: #333;
            }
            
            html {
                margin: 0;
                padding: 0;
            }
            
            /* Report container - reduce padding for more content per page */
            .report-container {
                padding: 15px;
                max-width: 100%;
            }
            
            /* Section spacing - tighter but readable */
            .report-section { 
                margin-bottom: 15px;
                padding: 0;
                page-break-inside: auto;
            }
            
            /* Section titles - clear hierarchy */
            .section-title {
                font-size: 14pt;
                font-weight: 600;
                margin-bottom: 6px;
                margin-top: 0;
                color: #1a1a1a;
            }
            
            /* Table introduction - readable paragraph spacing */
            .table-introduction {
                font-size: 10.5pt;
                line-height: 1.5;
                margin-bottom: 6px;
                margin-top: 0;
                orphans: 2;
                widows: 2;
            }
            
            /* Table description - smaller but readable */
            .table-description {
                font-size: 9.5pt;
                line-height: 1.4;
                color: #555;
                margin-bottom: 6px;
                margin-top: 0;
            }
            
            /* Table container - proper spacing */
            .table-container {
                margin-top: 0;
                margin-bottom: 8px;
            }
            
            /* Tables - improved readability, allow breaking if needed */
            table {
                border-collapse: collapse;
                margin: 0;
                width: 100%;
                font-size: 9pt;
                line-height: 1.3;
            }
            
            /* Table headers - clear and readable */
            th {
                background-color: #f5f5f5 !important;
                font-weight: 600;
                padding: 6px 8px;
                border: 1px solid #ddd;
                text-align: left;
                font-size: 9pt;
            }
            
            /* Table cells - proper spacing, allow breaking if needed */
            td {
                padding: 5px 8px;
                border: 1px solid #e0e0e0;
                font-size: 9pt;
            }
            
            /* Table caption - readable but smaller */
            .table-caption {
                font-size: 8.5pt;
                line-height: 1.4;
                color: #666;
                margin-top: 4px;
                margin-bottom: 0;
            }
            
            /* Table narrative - readable text blocks */
            .table-narrative {
                font-size: 10pt;
                line-height: 1.6;
                margin-top: 12px;
                margin-bottom: 0;
                orphans: 3;
                widows: 3;
            }
            
            /* Report header - compact */
            .report-header {
                margin-bottom: 12px;
            }
            
            /* AI content sections */
            .ai-insight-card {
                margin-bottom: 12px;
            }
            
            .ai-content {
                font-size: 10pt;
                line-height: 1.6;
            }
            
            /* Introduction, population demographics, and key findings - allow natural flow */
            #aiIntroParagraphSection {
                margin-bottom: 12px;
            }
            
            /* Population Demographics section */
            #demographicOverviewTableSection {
                margin-bottom: 12px;
            }
            
            /* Key Findings section */
            #aiKeyFindingsSection {
                margin-bottom: 12px;
            }
            
            /* Reduce excessive white space between sections */
            .report-section.print-break {
                margin-top: 20px;
            }
            
            /* Headings hierarchy */
            h1 { font-size: 16pt; font-weight: 700; margin: 0 0 10px 0; }
            h2 { font-size: 14pt; font-weight: 600; margin: 0 0 8px 0; }
            h3 { font-size: 12pt; font-weight: 600; margin: 0 0 6px 0; }
            
            /* Paragraphs */
            p {
                margin: 0 0 8px 0;
                line-height: 1.5;
            }
            
            /* Lists */
            ul, ol {
                margin: 0 0 8px 0;
                padding-left: 20px;
            }
            
            li {
                margin-bottom: 4px;
                line-height: 1.5;
            }
        }
        
        /* Report-specific styles */
        body {
            padding: 20px;
            background: #f5f5f5;
        }
        
        .report-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            box-sizing: border-box;
        }
        
        @media (max-width: 1240px) {
            body {
                padding: 20px 10px;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            /* Stack intro and chart on mobile */
            #introAndCensusSection > div {
                flex-direction: column !important;
            }
            
            #introAndCensusSection > div > div {
                flex: 1 1 100% !important;
            }
            
            /* Stack intro and table on mobile for Section 1 and 2 */
            .report-section > div[style*="display: flex"] {
                flex-direction: column !important;
            }
            
            .report-section > div[style*="display: flex"] > div {
                flex: 1 1 100% !important;
            }
        }
        
        /* Table column width styles for Section 1 and 2 */
        #demographicOverviewTable,
        #incomeNeighborhoodTable {
            table-layout: auto;
        }
        
        #demographicOverviewTable th:first-child,
        #demographicOverviewTable td:first-child,
        #incomeNeighborhoodTable th:first-child,
        #incomeNeighborhoodTable td:first-child {
            white-space: nowrap;
            width: auto;
            min-width: 0;
        }
        
        #demographicOverviewTable th:not(:first-child),
        #demographicOverviewTable td:not(:first-child),
        #incomeNeighborhoodTable th:not(:first-child),
        #incomeNeighborhoodTable td:not(:first-child) {
            width: 100px;
            min-width: 100px;
        }
        
        .report-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px 20px;
            background: #034ea0;
            color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .report-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: white;
            margin-bottom: 10px;
        }
        
        .report-subtitle {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 20px;
        }
        
        .report-meta {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 20px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.95);
            text-align: left;
        }
        
        .report-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .action-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            color: #333;
            text-decoration: none;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }
        
        .action-btn:hover {
            background: #f5f5f5;
            border-color: #999;
        }
        
        .action-btn.primary {
            background: #2fade3;
            color: white;
            border-color: #2fade3;
        }
        
        .action-btn.primary:hover {
            background: #034ea0;
            border-color: #034ea0;
        }
        
        .dropdown {
            position: relative;
            display: inline-block;
        }
        
        .dropdown-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 180px;
            z-index: 1000;
            display: none;
        }
        
        .dropdown:hover .dropdown-menu {
            display: block;
        }
        
        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            color: #333;
            text-decoration: none;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s ease;
        }
        
        .dropdown-item:last-child {
            border-bottom: none;
        }
        
        .dropdown-item:hover {
            background: #f8f9fa;
            color: #333;
        }
        
        .ai-insights {
            display: grid;
            gap: 20px;
        }
        
        .ai-insight-card {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            transition: box-shadow 0.2s ease;
        }
        
        .ai-insight-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .ai-insight-card h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ai-insight-card h3 i {
            color: #034ea0;
        }
        
        .ai-content {
            line-height: 1.6;
            color: #555;
        }
        
        .ai-content p {
            margin: 0 0 15px 0;
        }
        
        .ai-content p:last-child {
            margin-bottom: 0;
        }
        
        .report-section {
            margin-bottom: 40px;
        }
        
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .table-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 8px;
            padding-bottom: 5px;
        }
        
        .table-description {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 15px;
            line-height: 1.4;
            font-style: italic;
        }
        
        .table-introduction {
            font-size: 1rem;
            color: #333;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .table-source {
            font-size: 0.75rem;
            color: #888;
            margin-top: 8px;
            font-style: normal;
        }
        
        .table-caption {
            font-size: 0.85rem;
            color: #666;
            margin-top: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-left: 3px solid #034ea0;
            border-radius: 4px;
            line-height: 1.6;
        }
        
        .table-caption strong {
            color: #034ea0;
            font-weight: 600;
        }
        
        .table-narrative {
            margin-top: 25px;
            font-size: 1rem;
            line-height: 1.7;
            color: #333;
        }
        
        .table-narrative p {
            margin-bottom: 15px;
        }
        
        .table-narrative p:last-child {
            margin-bottom: 0;
        }
        
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .summary-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }
        
        .summary-card h3 {
            font-size: 2rem;
            font-weight: 700;
            color: #003366;
            margin: 0 0 10px 0;
        }
        
        .summary-card h3 .percentage-text {
            font-size: 1.2rem;
            font-weight: 500;
            color: #666;
        }
        
        .summary-card p {
            margin: 0;
            color: #666;
            font-size: 0.9rem;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .data-table th {
            background: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .data-table th[role="button"] {
            position: relative;
            transition: background-color 0.2s ease;
        }
        
        .data-table th[role="button"]:hover {
            background: #e9ecef;
        }
        
        .data-table th[role="button"]:focus {
            outline: 2px solid #034ea0;
            outline-offset: -2px;
        }
        
        .sort-indicator {
            display: inline-block;
            margin-left: 4px;
            color: #034ea0;
            font-size: 0.85em;
        }
        
        .data-table td {
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .data-table tr:hover {
            background: #f8f9fa;
        }
        
        .data-table tr:last-child td {
            border-bottom: none;
        }
        
        .table-container {
            position: relative;
        }
        
        .table-header {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 10px;
        }
        
        .collapse-btn {
            background: #f8f9fa;
            border: 1px solid #ddd;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            color: #666;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .collapse-btn:hover {
            background: #e9ecef;
            border-color: #999;
        }
        
        .collapse-btn i {
            transition: transform 0.2s ease;
        }
        
        .collapse-btn.collapsed i {
            transform: rotate(-90deg);
        }
        
        .collapsible-table {
            transition: all 0.3s ease;
        }
        
        .collapsible-table.collapsed {
            position: relative;
        }
        
        .collapsible-table.collapsed tbody {
            position: relative;
        }
        
        .collapsible-table.collapsed tbody::after {
            content: '... more rows available';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(transparent, rgba(255,255,255,0.9), white);
            pointer-events: none;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 10px;
            font-size: 0.8rem;
            color: #666;
            font-style: italic;
        }
        
        .collapsible-table.collapsed tbody tr:nth-child(n+4) {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: #034ea0;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            margin-bottom: 20px;
            transition: background 0.2s ease;
        }
        
        .back-btn:hover {
            background: #2fade3;
            color: white;
        }
        
        @media (max-width: 768px) {
            .report-container {
                padding: 10px;
            }
            
            .report-title {
                font-size: 2rem;
            }
            
            .report-meta {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .data-table {
                font-size: 0.8rem;
            }
            
            .data-table th,
            .data-table td {
                padding: 8px;
            }
        }
    </style>
</head>
<body style="background: var(--ncrc-gray-light);">
    <div class="report-container">
        <!-- New Analysis Button at Top -->
        <div style="text-align: left; margin-bottom: 20px; padding: 10px 0;">
            <a href="/" class="action-btn" style="text-decoration: none; cursor: pointer; padding: 10px 20px; background: var(--ncrc-dark-blue); color: white; border-radius: 5px; display: inline-block; font-weight: 500;">
                <i class="fas fa-arrow-left"></i> Back to New Analysis
            </a>
        </div>
        
        <!-- Download Actions -->
        <div class="report-actions" style="text-align: right; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <a href="/download?format=pdf" class="action-btn" id="downloadPdfBtn" style="text-decoration: none; cursor: pointer; margin-right: 10px; padding: 10px 20px; background: var(--ncrc-primary-blue); color: white; border-radius: 5px; display: inline-block;">
                <i class="fas fa-file-pdf"></i> Download PDF Report
            </a>
            <a href="/download?format=excel" class="action-btn primary" id="downloadExcelBtn" style="text-decoration: none; cursor: pointer; padding: 10px 20px; background: var(--ncrc-secondary-blue); color: white; border-radius: 5px; display: inline-block;">
                <i class="fas fa-file-excel"></i> Export Data (Excel)
            </a>
        </div>
        
        
        <!-- Loading State -->
        <div id="loadingState" class="loading">
            <i class="fas fa-spinner fa-spin fa-2x"></i>
            <p>Loading report data...</p>
        </div>
        
        <!-- Error State -->
        <div id="errorState" class="error" style="display: none;">
            <h3><i class="fas fa-exclamation-triangle"></i> Error Loading Report</h3>
            <p id="errorMessage"></p>
        </div>
        
        <div class="report-header" style="text-align: center; margin-bottom: 30px; padding: 20px; background: var(--ncrc-dark-blue); color: white; border-radius: 8px;">
            <h1 style="margin: 0 0 10px 0;">Mortgage Lending Analysis</h1>
            <p id="reportMetadata" style="margin: 10px 0 0 0; opacity: 0.9;">
                <span id="counties">Loading...</span> | <span id="years">Loading...</span>
            </p>
        </div>
        
            <!-- Report Content -->
            <main id="main-content" style="display: none;" role="main">
            <!-- Intro Paragraph and Census Chart - Side by Side -->
            <div class="report-section print-break" id="introAndCensusSection" style="display: none;">
                <div style="display: flex; gap: 20px; align-items: flex-start;">
                    <!-- Intro Paragraph - 1/3 width -->
                    <div style="flex: 0 0 33.333%;">
                        <div class="ai-insight-card">
                            <div class="ai-content" id="introParagraphContent">
                                <!-- AI content will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Census Chart - 2/3 width -->
                    <div style="flex: 0 0 66.667%;">
                        <h2 class="section-title">Population Demographics</h2>
                        <div style="position: relative; height: 400px;">
                            <canvas id="censusChart"></canvas>
                        </div>
                        <div id="censusChartTotals" style="margin-top: 10px; text-align: center; font-size: 0.9em; color: #666;">
                            <!-- Total population for each year will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Census Boundaries Callout -->
            <div class="report-section" id="censusBoundariesCallout" style="display: none; margin-top: 15px; padding: 15px; background-color: #f0f7ff; border-left: 4px solid #034ea0; border-radius: 4px;">
                <p style="margin: 0; font-size: 0.95em; line-height: 1.6;">
                    <strong>Note:</strong> It is important to note that shifting census boundaries that took effect in 2022 resulted in a 30% increase in the number of majority-minority census tracts nationally. The vast majority of these newly designated majority-minority tracts are not low-to-moderate income tracts.
                </p>
            </div>
            
            <!-- AI Key Findings -->
            <div class="report-section print-break" id="aiKeyFindingsSection" style="display: none;">
                <h2 class="section-title">Key Findings</h2>
                <div class="ai-insight-card">
                    <div class="ai-content" id="keyFindingsContent" style="line-height: 1.8;">
                        <!-- AI content will be populated by JavaScript -->
                    </div>
                </div>
                <p style="margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
            </div>
            
            <!-- Population Demographics Table Caption (moved below Key Findings) -->
            <div class="report-section" id="populationDemographicsCaptionSection" style="display: none;">
                <p class="table-caption" id="populationDemographicsCaption">
                    <strong>Source:</strong> U.S. Census Bureau American Community Survey (ACS) 5-year estimates. Data represents the most recent available ACS 5-year period and is shown for reference years in the analysis. Groups representing less than 1% of the total population are excluded from this table.
                </p>
            </div>
            
            <style>
                #keyFindingsContent ul {
                    margin: 0;
                    padding-left: 20px;
                }
                #keyFindingsContent ul li {
                    margin-bottom: 12px;
                    padding-left: 1.5em;
                    text-indent: -1.5em;
                }
                #keyFindingsContent ul li:last-child {
                    margin-bottom: 0;
                }
            </style>
            
            <!-- Section 1: Loans by Race and Ethnicity -->
            <div class="report-section print-break">
                <h2 class="section-title">Section 1: Loans by Race and Ethnicity</h2>
                <div style="display: flex; gap: 20px; align-items: flex-start;">
                    <!-- Intro Text - 25% width -->
                    <div style="flex: 0 0 25%;">
                        <div class="ai-insight-card">
                            <div class="ai-content" id="demographicOverviewIntro">
                                <!-- Introduction will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Table - 75% width -->
                    <div style="flex: 0 0 75%;">
                        <div class="table-container">
                            <table class="data-table" id="demographicOverviewTable" role="table" aria-label="Demographic Overview Lending Data">
                                <thead>
                                    <tr role="row">
                                        <th style="text-align: left; white-space: nowrap;" role="columnheader" scope="col">Metric</th>
                                        <!-- Year columns will be added dynamically by JavaScript -->
                                    </tr>
                                </thead>
                                <tbody role="rowgroup">
                                    <!-- Data will be populated by JavaScript -->
                                </tbody>
                            </table>
                            <p class="table-caption" id="demographicOverviewCaption">
                                <!-- Caption will be populated by JavaScript -->
                            </p>
                        </div>
                    </div>
                </div>
                <div class="table-narrative" id="demographicOverviewDiscussion">
                    <!-- Discussion will be populated by JavaScript -->
                </div>
                <p id="demographicOverviewAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
            </div>
            
            <!-- Section 2: Income and Neighborhood Indicators -->
            <div class="report-section print-break">
                <h2 class="section-title">Section 2: Income and Neighborhood Indicators</h2>
                
                <!-- Table 1: Lending to Income Borrowers -->
                <h3 style="margin-top: 20px; margin-bottom: 15px; font-size: 1.2em; color: var(--ncrc-dark-blue);">Table 1: Lending to Income Borrowers</h3>
                <p class="table-introduction" id="incomeBorrowersIntro" style="margin-bottom: 20px; max-width: 100%;">
                    This table shows lending activity by borrower income level over the selected time period. Borrower income is classified relative to the area median family income (AMFI) for the Metropolitan Statistical Area (MSA) or Metropolitan Division (MD) in which the property is located. Income thresholds are determined using FFIEC median family income data. <strong>Note:</strong> Between 2021 and 2022, boundary changes dramatically increased the number of tracts with higher minority populations.
                </p>
                <div class="table-container" style="width: 100%;">
                    <table class="data-table" id="incomeBorrowersTable">
                        <thead>
                            <tr>
                                <th style="text-align: left; white-space: nowrap; min-width: 280px;">Metric</th>
                                <!-- Year columns will be added dynamically by JavaScript -->
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div class="table-narrative" id="incomeBorrowersDiscussion" style="margin-top: 20px;">
                    <!-- AI narrative will be populated by JavaScript -->
                </div>
                <p id="incomeBorrowersAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
                
                <!-- Table 2: Lending to Census Tracts by Income Level -->
                <h3 style="margin-top: 40px; margin-bottom: 15px; font-size: 1.2em; color: var(--ncrc-dark-blue);">Table 2: Lending to Census Tracts by Income Level</h3>
                <p class="table-introduction" id="incomeTractsIntro" style="margin-bottom: 20px; max-width: 100%;">
                    This table shows lending activity by census tract income level over the selected time period. Census tract income is classified relative to the area median family income, as defined by HUD. The table shows lending to Low to Moderate Income Census Tracts (≤80% of AMFI) and their breakdown by Low Income (≤50% of AMFI), Moderate Income (>50% and ≤80% of AMFI), Middle Income (>80% and ≤120% of AMFI), and Upper Income (>120% of AMFI) census tracts. <strong>Note:</strong> Between 2021 and 2022, boundary changes dramatically increased the number of tracts with higher minority populations.
                </p>
                <div class="table-container" style="width: 100%;">
                    <table class="data-table" id="incomeTractsTable">
                        <thead>
                            <tr>
                                <th style="text-align: left; white-space: nowrap; min-width: 350px;">Metric</th>
                                <!-- Year columns will be added dynamically by JavaScript -->
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div class="table-narrative" id="incomeTractsDiscussion" style="margin-top: 20px;">
                    <!-- AI narrative will be populated by JavaScript -->
                </div>
                <p id="incomeTractsAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
                
                <!-- Table 3: Lending to Census Tracts by Minority Population -->
                <h3 style="margin-top: 40px; margin-bottom: 15px; font-size: 1.2em; color: var(--ncrc-dark-blue);">Table 3: Lending to Census Tracts by Minority Population</h3>
                <p class="table-introduction" id="minorityTractsIntro" style="margin-bottom: 20px; max-width: 100%;">
                    This table shows lending activity by census tract minority population quartiles over the selected time period. Minority population quartiles are calculated based on the distribution of minority population percentages across all census tracts in the CBSA. The table shows lending to Majority Minority Census Tracts (≥50% minority population) and their quartile breakdown (Low, Moderate, Middle, and High minority tracts). <strong>Note:</strong> Between 2021 and 2022, boundary changes dramatically increased the number of tracts with higher minority populations.
                </p>
                <div class="table-container" style="width: 100%;">
                    <table class="data-table" id="minorityTractsTable">
                        <thead>
                            <tr>
                                <th style="text-align: left; white-space: nowrap; min-width: 350px;">Metric</th>
                                <!-- Year columns will be added dynamically by JavaScript -->
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div class="table-narrative" id="minorityTractsDiscussion" style="margin-top: 20px;">
                    <!-- AI narrative will be populated by JavaScript -->
                </div>
                <p id="minorityTractsAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
                
                <!-- Unified Source Caption -->
                <p class="table-caption" id="section2SourceCaption" style="margin-top: 30px; max-width: 100%;">
                    <strong>Source:</strong> Home Mortgage Disclosure Act (HMDA) data, compiled and maintained in NCRC's curated databases. Census tract income classifications from HUD. <strong>Methodology:</strong> Borrower income is compared to FFIEC median family income for the MSA/MD. Census tract income is compared to area median family income. Minority quartiles are calculated from the distribution of minority population percentages across all census tracts in the CBSA. <strong>Note:</strong> The Change column indicates the change over time since 2020 through 2024. The Population Share (%) column shows the percentage of the population (for borrower income) or census tracts (for tract income and minority) in each category. <span id="section2AsteriskNote" style="display: none;"></span>
                </p>
            </div>
            
            <!-- Section 3: Top Lenders by Total Loans -->
            <div class="report-section print-break">
                <h2 class="section-title">Section 3: Top Lenders by Total Loans</h2>
                <p class="table-introduction" id="topLendersDetailedIntro">
                    <!-- Introduction will be populated by JavaScript -->
                </p>
                <p style="margin-bottom: 10px; font-size: 0.9em; color: #666; font-style: italic;">
                    <strong>Note:</strong> Click on any column header to sort the table. All data columns are in percentages.
                </p>
                <div class="table-container">
                    <div class="table-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="lenderTypeFilter" style="font-weight: 600; white-space: nowrap;">Filter by Lender Type:</label>
                            <select id="lenderTypeFilter" onchange="filterLendersByType()" style="padding: 5px 10px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer;">
                                <option value="all">All Lenders</option>
                                <option value="Bank">Banks</option>
                                <option value="Mortgage">Mortgage Companies</option>
                                <option value="Credit Union">Credit Unions</option>
                            </select>
                        </div>
                        <button class="expand-btn" id="expandTopLendersBtn" onclick="expandTopLendersTable()" style="display: none;">
                            <i class="fas fa-chevron-down"></i> Show All Lenders
                        </button>
                    </div>
                    <table class="data-table collapsible-table" id="topLendersDetailedTable">
                        <thead>
                            <tr>
                                <th style="text-align: left;">Lender Name</th>
                                <th style="text-align: center;">Total Loans</th>
                                <!-- Race/ethnicity and indicator columns will be added dynamically by JavaScript -->
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                    <p class="table-caption" id="topLendersDetailedCaption">
                        <!-- Caption will be populated by JavaScript -->
                    </p>
                </div>
                <div class="table-narrative" id="topLendersDetailedDiscussion">
                    <!-- Discussion will be populated by JavaScript -->
                </div>
                <p id="topLendersDetailedAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
            </div>
            
            <!-- Section 4: Market Concentration -->
            <div class="report-section print-break" id="marketConcentrationSection" style="display: none;">
                <h2 class="section-title">Section 4: Market Concentration</h2>
                <div style="display: flex; gap: 20px; align-items: flex-start;">
                    <!-- Intro Text - 1/3 width -->
                    <div style="flex: 0 0 33.333%;">
                        <div class="ai-insight-card">
                            <div class="ai-content" id="marketConcentrationIntro">
                                <p>The Herfindahl-Hirschman Index (HHI) is a common measure of market concentration and is used to determine market competitiveness. It is calculated by squaring the market share of each firm in the market and then summing the resulting numbers. The HHI can range from 0 to 10,000. A higher HHI indicates greater market concentration and less competition.</p>
                                <p>This chart and table present the HHI for mortgage lending in the selected counties across the selected years, providing insight into how competitive the mortgage lending market is.</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Chart and Table - 2/3 width -->
                    <div style="flex: 0 0 66.667%;">
                        <div class="chart-container" style="height: 400px; margin-bottom: 20px;">
                            <canvas id="hhiChart"></canvas>
                        </div>
                        <div class="table-container">
                            <table class="data-table" id="marketConcentrationTable">
                                <thead>
                                    <tr>
                                        <th style="text-align: left;">Year</th>
                                        <th style="text-align: center;">HHI</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <!-- Data will be populated by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <!-- Source caption - full width -->
                <p class="table-caption" style="margin-top: 15px; width: 100%;">
                    <strong>Source:</strong> Home Mortgage Disclosure Act (HMDA) data, compiled and maintained in NCRC's curated databases. 
                    <strong>Methodology:</strong> Herfindahl-Hirschman Index (HHI) is calculated as the sum of the squares of the market shares of all lenders in the market based on total loan amounts. 
                    HHI values range from 0 to 10,000. 
                    <strong>Concentration Levels:</strong> HHI &lt; 1,500 = Low concentration; 1,500-2,500 = Moderate concentration; &gt; 2,500 = High concentration.
                </p>
                <div class="table-narrative" id="marketConcentrationDiscussion" style="display: none;">
                    <!-- Discussion will be populated by JavaScript -->
                </div>
                <p id="marketConcentrationAICaption" style="display: none; margin-top: 10px; font-size: 0.85em; font-style: italic; color: #666;">
                    Above text is AI generated from NCRC data and analysis
                </p>
            </div>
            
            <!-- Methodology Section -->
            <div class="report-section print-break" id="methodsSection">
                <h2 class="section-title">Methods</h2>
                <div class="ai-insight-card">
                    <div class="ai-content">
                        <h3>Data Sources</h3>
                        <p>This report uses data from the Home Mortgage Disclosure Act (HMDA), which requires financial institutions to report information about mortgage loan applications and originations. HMDA data is collected and made publicly available by the Consumer Financial Protection Bureau (CFPB). The data used in this report is sourced from NCRC's curated HMDA databases, compiled and maintained by NCRC Research staff. Data is queried from NCRC datasets for the years specified in the analysis.</p>
                        
                        <p><strong>HMDA Data Coverage:</strong> This analysis includes mortgage loan originations (action taken = 1) for owner-occupied, site-built, 1-4 unit properties. <span id="loanPurposeCoverage">Loan purpose information will be populated dynamically.</span> Reverse mortgages are excluded from the analysis. For more information about HMDA data collection and reporting requirements, visit the <a href="https://www.consumerfinance.gov/data-research/hmda/" target="_blank">CFPB HMDA website</a>.</p>
                        
                        <p id="censusDataSource"><strong>Census Data Sources:</strong> <span id="censusDataSourceText">Population demographic data is sourced from the U.S. Census Bureau American Community Survey (ACS) 5-year estimates. Census data is used to provide context about the racial and ethnic composition of the selected geography and is displayed in the Population Demographics table. The most recent available ACS 5-year estimates are used for all years in the analysis period.</span></p>
                        
                        <p><strong>Data Filters Applied:</strong> The following filters are automatically applied to all analyses in this report:
                            <ul id="dataFiltersList" style="margin-top: 8px; padding-left: 20px;">
                                <li>Originations only (action taken = 1)</li>
                                <li>Site-built properties (construction method = 1)</li>
                                <li>Owner-occupied properties (occupancy type = 1)</li>
                                <li>Forward loans (excludes reverse mortgages where reverse_mortgage = 1)</li>
                                <li>1-4 unit properties (total_units IN ('1','2','3','4'))</li>
                            </ul>
                        </p>
                        
                        <p><strong>Data Quality Assurance:</strong> All data used in this report has been downloaded, cleaned, and tested by NCRC Research staff to ensure accuracy and reliability. Users can download the complete raw dataset for their report using the Excel Export feature to verify any claims or statistics presented in the AI-generated narratives. When using AI-generated content, always keep a human in the loop—review AI interpretations against the underlying data and exercise professional judgment in your analysis.</p>
                        
                        <h3>Calculations</h3>
                        
                        <p><strong>Loan Originations:</strong> This report analyzes mortgage loan originations, defined as loans where action taken = 1. Originations represent completed mortgage loans, not applications or denials.</p>
                        
                        <p><strong>Race and Ethnicity Classification:</strong> Race and ethnicity are determined from multiple applicant race and ethnicity fields in the HMDA data. The methodology follows these steps:</p>
                        <ol>
                            <li><strong>Hispanic Classification:</strong> If any ethnicity field (applicant_ethnicity_1 through applicant_ethnicity_5) indicates Hispanic (codes 1, 11, 12, 13, or 14), the borrower is classified as Hispanic, regardless of race codes.</li>
                            <li><strong>Race Classification for Non-Hispanic Borrowers:</strong> For borrowers not classified as Hispanic, the first valid race code is identified from applicant_race_1 through applicant_race_5. Valid race codes exclude codes 6 (Not Provided), 7 (Not Applicable), and 8 (Information not provided).</li>
                            <li><strong>Race Categories:</strong> Based on the first valid race code identified:
                                <ul>
                                    <li>Code 1: Native American</li>
                                    <li>Code 2 or 21-27: Asian</li>
                                    <li>Code 3: Black or African American</li>
                                    <li>Code 4 or 41-44: Hawaiian/Pacific Islander</li>
                                    <li>Code 5: White</li>
                                </ul>
                            </li>
                            <li><strong>Multi-Racial Classification (HMDA):</strong> Borrowers are classified as Multi-Racial if they meet either of the following criteria:
                                <ul>
                                    <li><strong>Hispanic + Non-White Race:</strong> If the borrower reports Hispanic ethnicity (any ethnicity field = 1, 11, 12, 13, or 14) AND reports any race code other than white alone (code 5), they are classified as Multi-Racial.</li>
                                    <li><strong>Non-Hispanic + Multiple Races:</strong> If the borrower does not report Hispanic ethnicity AND reports two or more valid race codes across applicant_race_1 through applicant_race_5, they are classified as Multi-Racial.</li>
                                </ul>
                                Note: HMDA collects race and ethnicity separately, similar to Census data. The "Multi-Racial" category for non-Hispanic borrowers refers to individuals who identify with two or more race categories. Hispanic borrowers who report only white race are classified as Hispanic (not Multi-Racial). Non-Hispanic borrowers with only one race code are classified by that single race category.
                            </li>
                            <li><strong>Percentage Calculations:</strong> Race/ethnicity percentages are calculated as: (group loans / loans with demographic data) × 100, where loans with demographic data = total loans minus loans without race/ethnicity data. Only groups representing ≥1% of all loans are included in demographic overview tables.</li>
                        </ol>
                        
                        <p><strong>Exclusion of Loans Without Demographic Data:</strong> Loans without race/ethnicity data are excluded from the denominator before calculating percentages in the demographic overview table. This ensures that percentages reflect the distribution of loans among borrowers with known race/ethnicity classifications, rather than including loans where this information is missing. The exclusion of these loans from the calculation provides a more accurate representation of lending patterns by race and ethnicity.</p>
                        
                        <p><strong>Population Demographics Data (Census):</strong> Population demographics are obtained from the U.S. Census Bureau, including American Community Survey (ACS) 5-year estimates and Decennial Census data. The data includes three time periods: 2010 Decennial Census, 2020 Decennial Census, and the most recent available ACS 5-year estimates.</p>
                        
                        <p><strong>Multi-Racial Classification (Census):</strong> The Census Bureau defines "Two or more races" as individuals who identify with two or more of the following race categories: White, Black or African American, American Indian or Alaska Native, Asian, Native Hawaiian or Other Pacific Islander, or Some Other Race. In this report, this category is labeled as "Multi-Racial" and includes:
                            <ul>
                                <li><strong>ACS Data:</strong> Variable B03002_009E represents "Two or more races (not Hispanic)" from the ACS Detailed Race/Ethnicity table (B03002).</li>
                                <li><strong>2020 Census:</strong> Variable P2_011N represents "Two or more races (not Hispanic)" from the 2020 Census Redistricting Data (PL94-171).</li>
                                <li><strong>2010 Census:</strong> Variable P005009 represents "Not Hispanic or Latino!!Two or more races" from the 2010 Census Summary File 1 (SF1).</li>
                            </ul>
                            Note: Census collects race and ethnicity separately. Hispanic or Latino is considered an ethnicity that can be reported in combination with any race category. The "Two or more races" category specifically refers to non-Hispanic individuals who identify with multiple race categories. Hispanic individuals who identify with multiple races are included in the Hispanic category in Census data, but may be classified as Multi-Racial in HMDA data based on the methodology described above.
                        </p>
                        
                        <p><strong>Low-to-Moderate Income Borrower (LMIB):</strong> Borrowers are classified as Low-to-Moderate Income when their reported income is below 80% of the area median family income (AMFI) for the Metropolitan Statistical Area (MSA) or Metropolitan Division (MD) in which the property is located. Income thresholds are determined using FFIEC median family income data.</p>
                        
                        <p><strong>Low-to-Moderate Income Census Tract (LMICT):</strong> Census tracts are classified as Low-to-Moderate Income when the tract's median family income is below 80% of the area median family income, as defined by the U.S. Department of Housing and Urban Development (HUD). This designation is based on the census tract where the property securing the loan is located.</p>
                        
                        <p><strong>Majority-Minority Census Tract (MMCT):</strong> Census tracts are classified as Majority-Minority when minority populations represent more than 50% of the total population in the census tract, as defined by the U.S. Census Bureau. This designation is based on the census tract where the property securing the loan is located.</p>
                        
                        <p><strong>2020 Census Boundary Changes:</strong> The 2020 census boundaries that took effect in 2022 resulted in a dramatic increase in the number of middle and upper income majority-minority census tracts nationally. Therefore, it is expected that there would be a dramatic increase in majority-minority mortgage originations between 2021 and 2022. This is a methodological artifact of the census boundary update, not necessarily a reflection of actual lending pattern changes or lender strategy shifts. When analyzing MMCT origination changes between 2021 and 2022, this census boundary change effect should be considered.</p>
                        
                        <p><strong>Change Over Time:</strong> Calculated as the difference between values in the first year and the final year of the analysis period. Positive changes are displayed in blue (NCRC light blue #2fade3), and negative changes are displayed in red. Changes are shown as both count changes and percentage point changes (pp).</p>
                        
                        <p><strong>Top Lenders Selection:</strong> The top 10 lenders are identified based on total number of loan originations in the most recent year of the report. Lenders are sorted in descending order by total loans. For each lender, race/ethnicity percentages use the same methodology as the demographic overview, with denominator = loans with demographic data. Income and neighborhood indicator percentages use denominator = total loans.</p>
                        
                        <p><strong>Geographic Identifiers:</strong> Counties are identified using the 5-digit Federal Information Processing Standards (FIPS) county code. The county code is used to join HMDA data with geographic reference tables to obtain county names and state information.</p>
                        
                        <p><strong>Lender Identification:</strong> Lenders are identified using the Legal Entity Identifier (LEI) and matched to lender names from the HMDA Lenders table (lenders18) using the LEI as the linking field.</p>
                        
                        <h3>Abbreviations and Acronyms</h3>
                        <ul>
                            <li><strong>HMDA:</strong> Home Mortgage Disclosure Act</li>
                            <li><strong>CFPB:</strong> Consumer Financial Protection Bureau</li>
                            <li><strong>NCRC:</strong> National Community Reinvestment Coalition</li>
                            <li><strong>LMI:</strong> Low-to-Moderate Income</li>
                            <li><strong>LMIB:</strong> Low-to-Moderate Income Borrower</li>
                            <li><strong>LMICT:</strong> Low-to-Moderate Income Census Tract</li>
                            <li><strong>MMCT:</strong> Majority-Minority Census Tract</li>
                            <li><strong>AMFI:</strong> Area Median Family Income</li>
                            <li><strong>MSA:</strong> Metropolitan Statistical Area</li>
                            <li><strong>MD:</strong> Metropolitan Division</li>
                            <li><strong>HUD:</strong> U.S. Department of Housing and Urban Development</li>
                            <li><strong>FFIEC:</strong> Federal Financial Institutions Examination Council</li>
                            <li><strong>FIPS:</strong> Federal Information Processing Standards</li>
                            <li><strong>LEI:</strong> Legal Entity Identifier</li>
                            <li><strong>pp:</strong> Percentage Points</li>
                        </ul>
                        
                        <h3>AI Disclosure</h3>
                        <p>This report was generated using AI assistance through Cursor and other language models (primarily Claude Sonnet 4). AI-generated content includes narrative analysis, introductory paragraphs, key findings, and table discussions. All data points, statistics, and figures are pulled directly from NCRC staff-maintained databases—AI is used only to interpret patterns and generate written summaries. All underlying data and calculations are based on HMDA data compiled by NCRC research staff. Users should verify specific claims and data points using the Excel Export, which contains the complete underlying dataset. For official HMDA data and documentation, visit the <a href="https://www.consumerfinance.gov/data-research/hmda/" target="_blank">CFPB HMDA website</a>.</p>
                    </div>
                </div>
            </div>
            

            
        </div>
    </div>
    
    <script>
        // Update download links with job_id from URL
        function updateDownloadLinks() {
            const urlParams = new URLSearchParams(window.location.search);
            const jobId = urlParams.get('job_id');
            
            if (jobId) {
                // Update dropdown download links
                const downloadLinks = document.querySelectorAll('.dropdown-item[href^="/download"]');
                downloadLinks.forEach(link => {
                    const href = link.getAttribute('href');
                    if (href && !href.includes('job_id=')) {
                        const separator = href.includes('?') ? '&' : '?';
                        link.setAttribute('href', `${href}${separator}job_id=${encodeURIComponent(jobId)}`);
                    }
                });
                
                // Update PDF download button
                const pdfBtn = document.getElementById('downloadPdfBtn');
                if (pdfBtn) {
                    const href = pdfBtn.getAttribute('href');
                    if (href && !href.includes('job_id=')) {
                        const separator = href.includes('?') ? '&' : '?';
                        pdfBtn.setAttribute('href', `${href}${separator}job_id=${encodeURIComponent(jobId)}`);
                    }
                }
                
                // Update Excel download button
                const excelBtn = document.getElementById('downloadExcelBtn');
                if (excelBtn) {
                    const href = excelBtn.getAttribute('href');
                    if (href && !href.includes('job_id=')) {
                        const separator = href.includes('?') ? '&' : '?';
                        excelBtn.setAttribute('href', `${href}${separator}job_id=${encodeURIComponent(jobId)}`);
                    }
                }
            }
        }
        
        // Load and display report data
        async function loadReportData() {
            try {
                // Check for job_id in URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const jobId = urlParams.get('job_id');
                
                console.log('Loading report data...', { jobId, url: window.location.href });
                
                // Update download links with job_id
                updateDownloadLinks();
                
                // Build URL with job_id if available
                let url = '/report-data';
                if (jobId) {
                    url += `?job_id=${encodeURIComponent(jobId)}`;
                    console.log('Using job_id from URL:', jobId);
                } else {
                    console.log('No job_id in URL, relying on session');
                }
                
                const response = await fetch(url);
                console.log('Response status:', response.status);
                
                // Check if response is OK
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Response not OK:', response.status, errorText);
                    throw new Error(`Server returned ${response.status}: ${errorText.substring(0, 200)}`);
                }
                
                // Get response text first to check if it's valid JSON
                const responseText = await response.text();
                console.log('Response text length:', responseText.length);
                
                if (!responseText || responseText.trim().length === 0) {
                    throw new Error('Empty response from server. The analysis may still be running or may have failed.');
                }
                
                // Try to parse JSON
                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (jsonError) {
                    console.error('JSON parse error:', jsonError);
                    console.error('Response text preview (first 500 chars):', responseText.substring(0, 500));
                    console.error('Response text preview (last 500 chars):', responseText.substring(Math.max(0, responseText.length - 500)));
                    throw new Error(`Invalid JSON response: ${jsonError.message}. The response may have been truncated.`);
                }
                
                console.log('Response data:', { success: result.success, hasData: !!result.data, dataKeys: result.data ? Object.keys(result.data) : [] });
                console.log('Metadata:', result.metadata ? {
                    counties: result.metadata.counties,
                    years: result.metadata.years,
                    hasCensusData: !!result.metadata.census_data,
                    censusDataKeys: result.metadata.census_data ? Object.keys(result.metadata.census_data) : []
                } : 'No metadata');
                
                if (!result.success) {
                    const errorMsg = result.error || 'Failed to load report data';
                    console.error('Report data error:', errorMsg);
                    throw new Error(errorMsg);
                }
                
                // Check if we have actual data
                if (!result.data || Object.keys(result.data).length === 0) {
                    console.warn('No data in response:', result);
                    throw new Error('No report data available. The analysis may still be running or may have failed.');
                }
                
                // Ensure metadata exists with defaults
                const metadata = result.metadata || {
                    generated_at: new Date().toISOString(),
                    counties: [],
                    years: [],
                    total_records: 0,
                    ai_insights: {}
                };
                
                console.log('Displaying report with metadata:', metadata);
                displayReport(result.data || {}, metadata);
                
            } catch (error) {
                console.error('Error loading report:', error);
                const errorMessage = error.message || 'Failed to load report data';
                if (errorMessage.includes('No analysis') || errorMessage.includes('No analysis session') || errorMessage.includes('No report data')) {
                    showError('No analysis data found. Please run an analysis first by selecting counties and years on the <a href="/">analysis page</a>.');
                } else {
                    showError('Error loading report: ' + errorMessage + '. Please try running a new analysis on the <a href="/">analysis page</a>.');
                }
            }
        }
        
        function displayReport(data, metadata) {
            // Ensure metadata exists
            if (!metadata) {
                console.error('Metadata is missing');
                showError('Report data is incomplete. Please try generating a new report.');
                return;
            }
            
            console.log('Displaying report with metadata:', metadata);
            console.log('Census data in metadata:', metadata.census_data ? {
                counties: Object.keys(metadata.census_data),
                sampleCounty: metadata.census_data[Object.keys(metadata.census_data)[0]]
            } : 'No census_data in metadata');
            
            // Hide loading state
            document.getElementById('loadingState').style.display = 'none';
            
            // Show report content
            document.getElementById('main-content').style.display = 'block';
            
            // Update metadata with safe defaults
            document.getElementById('counties').textContent = 
                (metadata.counties && metadata.counties.length > 0) ? metadata.counties.join(', ') : 'N/A';
            
            // Format years as "2020 through 2024" instead of comma-separated
            const yearsEl = document.getElementById('years');
            if (yearsEl && metadata.years && metadata.years.length > 0) {
                const sortedYears = [...metadata.years].sort((a, b) => a - b);
                if (sortedYears.length === 1) {
                    yearsEl.textContent = sortedYears[0].toString();
                } else {
                    const minYear = sortedYears[0];
                    const maxYear = sortedYears[sortedYears.length - 1];
                    yearsEl.textContent = `${minYear} through ${maxYear}`;
                }
            } else {
                yearsEl.textContent = 'N/A';
            }
            
            // Populate intro paragraph and demographics chart (always show these)
            generateIntroParagraph(metadata);
            populatePopulationDemographicsChart(metadata);
            
            // Populate AI insights if available
            if (metadata.ai_insights) {
                populateAIInsights(metadata.ai_insights, metadata);
            } else {
                // If no AI insights, still show the caption section after demographics table
                const captionSection = document.getElementById('populationDemographicsCaptionSection');
                if (captionSection) {
                    captionSection.style.display = 'block';
                }
            }
            
            // Populate demographic overview table
            try {
                if (data.demographic_overview && data.demographic_overview.length > 0) {
                    populateDemographicOverviewTable(data.demographic_overview, metadata);
                }
            } catch (e) {
                console.error('[ERROR] Error populating demographic overview table:', e);
            }
            
            // Populate income borrowers table (Table 1)
            try {
                if (data.income_borrowers && data.income_borrowers.length > 0) {
                    populateIncomeBorrowersTable(data.income_borrowers, metadata);
                }
            } catch (e) {
                console.error('[ERROR] Error populating income borrowers table:', e);
            }
            
            // Populate income tracts table (Table 2)
            try {
                if (data.income_tracts && data.income_tracts.length > 0) {
                    populateIncomeTractsTable(data.income_tracts, metadata);
                }
            } catch (e) {
                console.error('[ERROR] Error populating income tracts table:', e);
            }
            
            // Populate minority tracts table (Table 3)
            try {
                if (data.minority_tracts && data.minority_tracts.length > 0) {
                    populateMinorityTractsTable(data.minority_tracts, metadata);
                }
            } catch (e) {
                console.error('[ERROR] Error populating minority tracts table:', e);
            }
            
            // Populate income and neighborhood tracts table (legacy - keep for backward compatibility)
            try {
                if (data.income_neighborhood_tracts && data.income_neighborhood_tracts.length > 0) {
                    populateIncomeNeighborhoodTractsTable(data.income_neighborhood_tracts, metadata);
                }
            } catch (e) {
                console.error('[ERROR] Error populating income neighborhood tracts table:', e);
            }
            
            // Populate income and neighborhood indicators table (legacy - keep for backward compatibility)
            try {
                if (data.income_neighborhood_indicators && data.income_neighborhood_indicators.length > 0) {
                    populateIncomeNeighborhoodTable(data.income_neighborhood_indicators, metadata);
                }
            } catch (e) {
                console.error('[ERROR] Error populating income neighborhood indicators table:', e);
            }
            
            // Populate top 10 lenders detailed table
            try {
                if (data.top_lenders_detailed && data.top_lenders_detailed.length > 0) {
                    console.log('[DEBUG] Populating top lenders table with', data.top_lenders_detailed.length, 'rows');
                    populateTopLendersDetailedTable(data.top_lenders_detailed, metadata);
                } else {
                    console.warn('[WARNING] No top_lenders_detailed data available. Data keys:', Object.keys(data));
                }
            } catch (e) {
                console.error('[ERROR] Error populating top lenders table:', e);
            }
            
            // Populate market concentration table and chart
            try {
                if (data.market_concentration && data.market_concentration.length > 0) {
                    console.log('[DEBUG] Populating market concentration with', data.market_concentration.length, 'rows');
                    populateMarketConcentrationTable(data.market_concentration, metadata);
                } else {
                    console.warn('[WARNING] No market_concentration data available. Data keys:', Object.keys(data));
                }
            } catch (e) {
                console.error('[ERROR] Error populating market concentration:', e);
            }
            
            // Populate methodology section with loan purpose information
            populateMethodology(metadata);
        }
        
        function populateMethodology(metadata) {
            // Populate loan purpose coverage text
            const loanPurposeCoverage = document.getElementById('loanPurposeCoverage');
            if (loanPurposeCoverage && metadata.loan_purpose) {
                const loanPurposes = Array.isArray(metadata.loan_purpose) ? metadata.loan_purpose : [metadata.loan_purpose];
                
                // Map loan purpose values to display names
                const purposeMap = {
                    'purchase': 'home purchase loans (loan purpose = 1)',
                    'refinance': 'refinance and cash-out refinance loans (loan purpose IN (31, 32))',
                    'equity': 'home equity lending (loan purpose IN (2, 4))'
                };
                
                // Filter out 'all' if present and get actual purposes
                const selectedPurposes = loanPurposes.filter(p => p !== 'all');
                
                // If all three are selected or 'all' was selected, show all purposes
                if (selectedPurposes.length === 0 || 
                    (selectedPurposes.includes('purchase') && selectedPurposes.includes('refinance') && selectedPurposes.includes('equity')) ||
                    loanPurposes.includes('all')) {
                    loanPurposeCoverage.textContent = 'The analysis includes all loan purposes: home purchase loans (loan purpose = 1), refinance and cash-out refinance loans (loan purpose IN (31, 32)), and home equity lending (loan purpose IN (2, 4)).';
                } else if (selectedPurposes.length === 1) {
                    const purposeName = purposeMap[selectedPurposes[0]] || selectedPurposes[0];
                    loanPurposeCoverage.textContent = `The analysis includes ${purposeName}.`;
                } else {
                    const purposeNames = selectedPurposes.map(p => purposeMap[p] || p);
                    const lastPurpose = purposeNames.pop();
                    const purposesText = purposeNames.length > 0 
                        ? purposeNames.join(', ') + ', and ' + lastPurpose
                        : lastPurpose;
                    loanPurposeCoverage.textContent = `The analysis includes ${purposesText}.`;
                }
            } else if (loanPurposeCoverage) {
                // Default text if no loan purpose info is available
                loanPurposeCoverage.textContent = 'The analysis includes all loan purposes: home purchase loans (loan purpose = 1), refinance and cash-out refinance loans (loan purpose IN (31, 32)), and home equity lending (loan purpose IN (2, 4)).';
            }
            
            // Populate Census data source information
            const censusDataSourceText = document.getElementById('censusDataSourceText');
            if (censusDataSourceText && metadata.census_data) {
                const censusData = metadata.census_data;
                const counties = Object.keys(censusData);
                
                if (counties.length > 0) {
                    // Get the ACS data year from the first county
                    const firstCounty = censusData[counties[0]];
                    const timePeriods = firstCounty.time_periods || {};
                    const acsPeriod = timePeriods.acs;
                    const acsYear = acsPeriod?.data_year || 'the most recent available ACS 5-year estimates';
                    
                    let censusText = `Population demographic data is sourced from the U.S. Census Bureau. `;
                    censusText += `The Population Demographics table shows change over time using three data sources: `;
                    censusText += `(1) the most recent American Community Survey (ACS) 5-year estimates (${acsYear}), `;
                    censusText += `(2) the 2020 Decennial Census, and (3) the 2010 Decennial Census. `;
                    censusText += `Census data is used to provide context about the racial and ethnic composition of the selected geography and how it has changed over time. `;
                    censusText += `For more information about Census data, visit the <a href="https://www.census.gov/data/developers/data-sets.html" target="_blank">U.S. Census Bureau Data API website</a>.`;
                    
                    censusDataSourceText.innerHTML = censusText;
                } else {
                    censusDataSourceText.textContent = 'Population demographic data from the U.S. Census Bureau was not available for the selected geography.';
                }
            } else if (censusDataSourceText) {
                censusDataSourceText.textContent = 'Population demographic data from the U.S. Census Bureau was not available for the selected geography.';
            }
        }
        
        // Store chart instance for potential updates
        let censusChartInstance = null;
        
        function populatePopulationDemographicsChart(metadata) {
            console.log('populatePopulationDemographicsChart called with metadata:', metadata);
            
            if (!metadata) {
                console.warn('No metadata provided to populatePopulationDemographicsChart');
                return;
            }
            
            const censusData = metadata.census_data;
            console.log('Census data object:', censusData);
            console.log('Census data type:', typeof censusData);
            console.log('Census data keys:', censusData ? Object.keys(censusData) : 'null/undefined');
            console.log('Census data length:', censusData ? Object.keys(censusData).length : 0);
            
            if (!censusData || Object.keys(censusData).length === 0) {
                console.warn('No Census data available - showing empty message');
                const section = document.getElementById('introAndCensusSection');
                if (section) {
                    section.style.display = 'block';
                    const chartContainer = section.querySelector('#censusChart').parentElement;
                    chartContainer.innerHTML = '<p style="text-align: center; color: #666; font-style: italic; padding: 40px;">Census demographic data is not available for the selected geography.</p>';
                }
                return;
            }
            
            // Use shared module if available
            if (typeof window.PopulationDemographics !== 'undefined') {
            // Destroy existing chart if it exists
            if (censusChartInstance) {
                censusChartInstance.destroy();
                    censusChartInstance = null;
                }
                
                // Render chart using shared module
                censusChartInstance = window.PopulationDemographics.renderPopulationDemographicsChart(
                    'censusChart',
                    censusData,
                    {
                        chartHeight: 400
                    }
                );
            
            // Show the combined intro and census section
            const section = document.getElementById('introAndCensusSection');
            if (section) {
                section.style.display = 'block';
                console.log('Intro and Census section displayed');
            }
            
            // Update caption (now located below Key Findings)
            const caption = document.getElementById('populationDemographicsCaption');
            if (caption) {
                    const captionText = window.PopulationDemographics.generateSourceCaption(censusData);
                caption.innerHTML = captionText;
            }
            
            // Show the caption section (below Key Findings)
            const captionSection = document.getElementById('populationDemographicsCaptionSection');
            if (captionSection) {
                captionSection.style.display = 'block';
                console.log('Population Demographics caption section displayed');
                }
                
                // Remove total population display below chart (now shown above columns)
                const totalsEl = document.getElementById('censusChartTotals');
                if (totalsEl) {
                    totalsEl.innerHTML = '';
                }
                
                return;
            }
            
            // Fallback: Show error message if shared module not loaded
            console.error('Shared Population Demographics module not loaded');
            const section = document.getElementById('introAndCensusSection');
            if (section) {
                section.style.display = 'block';
                const chartContainer = section.querySelector('#censusChart').parentElement;
                chartContainer.innerHTML = '<p style="text-align: center; color: #666; font-style: italic; padding: 40px;">Census demographic chart unavailable - shared module not loaded.</p>';
            }
        }
        
        function generateIntroParagraph(metadata) {
            if (!metadata) return;
            
            const counties = metadata.counties || [];
            const years = metadata.years || [];
            const loanPurpose = metadata.loan_purpose || ['purchase'];
            
            if (counties.length === 0 || years.length === 0) return;
            
            // Format counties - group by state and avoid repeating state names
            let countiesStr = '';
            
            // Parse counties into {name, state} objects
            const parsedCounties = counties.map(county => {
                // Handle formats like "Richmond County, Virginia" or "Richmond city, Virginia"
                const match = county.match(/^(.+?),\s*(.+)$/);
                if (match) {
                    return { name: match[1].trim(), state: match[2].trim(), full: county };
                }
                // If no comma, assume it's just the name (no state specified)
                return { name: county.trim(), state: null, full: county };
            });
            
            // Group by state
            const byState = {};
            parsedCounties.forEach(item => {
                const state = item.state || 'Unknown';
                if (!byState[state]) {
                    byState[state] = [];
                }
                byState[state].push(item.name);
            });
            
            // Format the string
            const states = Object.keys(byState);
            
            if (counties.length === 1) {
                // Single county - use original format
                countiesStr = counties[0];
            } else if (states.length === 1) {
                // All counties in same state
                const state = states[0];
                const names = byState[state];
                if (names.length === 1) {
                    countiesStr = `${names[0]}, ${state}`;
                } else if (names.length === 2) {
                    countiesStr = `${names[0]} and ${names[1]}, ${state}`;
                } else {
                    const last = names.slice().pop();
                    const rest = names.slice(0, -1);
                    countiesStr = `${rest.join(', ')}, and ${last}, ${state}`;
                }
            } else {
                // Multiple states - format each state group
                const stateGroups = states.map(state => {
                    const names = byState[state];
                    if (names.length === 1) {
                        return `${names[0]}, ${state}`;
                    } else if (names.length === 2) {
                        return `${names[0]} and ${names[1]}, ${state}`;
                    } else {
                        const last = names.slice().pop();
                        const rest = names.slice(0, -1);
                        return `${rest.join(', ')}, and ${last}, ${state}`;
                    }
                });
                
                if (stateGroups.length === 2) {
                    countiesStr = stateGroups.join(' and ');
                } else {
                    const last = stateGroups.pop();
                    countiesStr = `${stateGroups.join(', ')}, and ${last}`;
                }
            }
            
            // Format years
            const yearsStr = years.length > 1 
                ? `${Math.min(...years)} to ${Math.max(...years)}`
                : years[0].toString();
            
            // Format loan purposes
            const purposeMap = {
                'purchase': 'home purchase loans',
                'refinance': 'refinance and cash-out refinance loans',
                'equity': 'home equity lending'
            };
            
            const selectedPurposes = Array.isArray(loanPurpose) 
                ? loanPurpose.filter(p => p !== 'all')
                : [loanPurpose].filter(p => p !== 'all');
            
            let loanPurposeStr = '';
            if (selectedPurposes.length === 0 || 
                (selectedPurposes.includes('purchase') && selectedPurposes.includes('refinance') && selectedPurposes.includes('equity'))) {
                loanPurposeStr = 'all loan purposes (home purchase loans, refinance and cash-out refinance loans, and home equity lending)';
            } else if (selectedPurposes.length === 1) {
                loanPurposeStr = purposeMap[selectedPurposes[0]] || selectedPurposes[0];
            } else {
                const purposeNames = selectedPurposes.map(p => purposeMap[p] || p);
                const lastPurpose = purposeNames.pop();
                loanPurposeStr = purposeNames.join(', ') + ', and ' + lastPurpose;
            }
            
            // Build intro paragraph
            let introText = `This report examines ${loanPurposeStr} in ${countiesStr} from ${yearsStr}. `;
            introText += `The analysis includes only loans that were completed (originations) for owner-occupied properties, which means homes where the borrower actually lives rather than investment properties. `;
            introText += `The data is filtered to include only site-built homes (traditional homes constructed on-site, not manufactured or mobile homes), forward mortgages (regular mortgages where the borrower makes payments to the bank, not reverse mortgages where the bank pays the homeowner), and properties with 1-4 units (single-family homes, duplexes, triplexes, and four-unit buildings). `;
            introText += `It is important to note that shifting census boundaries that took effect in 2022 resulted in a 30% increase in the number of majority-minority census tracts nationally. The vast majority of these newly designated majority-minority tracts are not low-to-moderate income tracts.`;
            
            // Add Census demographic context if available
            if (metadata.census_data) {
                const censusData = metadata.census_data;
                const countiesWithData = Object.keys(censusData).filter(county => {
                    const data = censusData[county];
                    return data && data.demographics && data.demographics.total_population;
                });
                
                if (countiesWithData.length > 0) {
                    // Aggregate demographics for context
                    let totalPop = 0;
                    let whiteSum = 0, hispanicSum = 0, blackSum = 0, asianSum = 0;
                    
                    countiesWithData.forEach(county => {
                        const demo = censusData[county].demographics;
                        const pop = demo.total_population || 0;
                        totalPop += pop;
                        whiteSum += (demo.white_percentage || 0) * pop / 100;
                        hispanicSum += (demo.hispanic_percentage || 0) * pop / 100;
                        blackSum += (demo.black_percentage || 0) * pop / 100;
                        asianSum += (demo.asian_percentage || 0) * pop / 100;
                    });
                    
                    if (totalPop > 0) {
                        const whitePct = (whiteSum / totalPop * 100).toFixed(1);
                        const hispanicPct = (hispanicSum / totalPop * 100).toFixed(1);
                        const blackPct = (blackSum / totalPop * 100).toFixed(1);
                        const asianPct = (asianSum / totalPop * 100).toFixed(1);
                        
                        const parts = [];
                        if (parseFloat(whitePct) > 0) parts.push(`${whitePct}% White`);
                        if (parseFloat(hispanicPct) > 0) parts.push(`${hispanicPct}% Hispanic or Latino`);
                        if (parseFloat(blackPct) > 0) parts.push(`${blackPct}% Black or African American`);
                        if (parseFloat(asianPct) > 0) parts.push(`${asianPct}% Asian`);
                        
                        if (parts.length >= 2) {
                            const lastPart = parts.pop();
                            introText += ` According to recent Census data, the population of ${countiesStr} is approximately ${parts.join(', ')}, and ${lastPart}.`;
                        } else if (parts.length === 1) {
                            introText += ` According to recent Census data, the population of ${countiesStr} is approximately ${parts[0]}.`;
                        }
                    }
                }
            }
            
            // Display intro paragraph in the combined section (without census context)
            const element = document.getElementById('introParagraphContent');
            if (element) {
                // Only show the core intro text (without census demographic context and census boundaries note)
                let coreIntroText = `This report examines ${loanPurposeStr} in ${countiesStr} from ${yearsStr}. `;
                coreIntroText += `The analysis includes only loans that were completed (originations) for owner-occupied properties, which means homes where the borrower actually lives rather than investment properties. `;
                coreIntroText += `The data is filtered to include only site-built homes (traditional homes constructed on-site, not manufactured or mobile homes), forward mortgages (regular mortgages where the borrower makes payments to the bank, not reverse mortgages where the bank pays the homeowner), and properties with 1-4 units (single-family homes, duplexes, triplexes, and four-unit buildings).`;
                element.textContent = coreIntroText;
            }
            
            // Display census boundaries callout
            const calloutElement = document.getElementById('censusBoundariesCallout');
            if (calloutElement) {
                calloutElement.style.display = 'block';
            }
        }
        
        function populateAIInsights(aiInsights, metadata) {
            // Populate intro paragraph (now generated in JavaScript)
            generateIntroParagraph(metadata);
            
            // Populate population demographics chart (after intro, before key findings)
            populatePopulationDemographicsChart(metadata);
            
            console.log('populateAIInsights called with:', {
                hasAiInsights: !!aiInsights,
                aiInsightsKeys: aiInsights ? Object.keys(aiInsights) : [],
                demographic_overview_discussion: aiInsights?.demographic_overview_discussion ? 'present' : 'missing',
                income_neighborhood_discussion: aiInsights?.income_neighborhood_discussion ? 'present' : 'missing',
                top_lenders_detailed_discussion: aiInsights?.top_lenders_detailed_discussion ? 'present' : 'missing',
                ai_insights_enabled: metadata?.ai_insights_enabled
            });
            
            // Check if AI insights are disabled
            const aiDisabled = metadata && metadata.ai_insights_enabled === false;
            const getAIDisabledMessage = () => {
                return '<div class="alert alert-info" style="padding: 15px; margin: 15px 0; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px;"><strong>AI Insights Not Available:</strong> AI-powered analysis is currently disabled. To enable AI insights, please configure the CLAUDE_API_KEY environment variable in your deployment settings.</div>';
            };
            
            if (!aiInsights) {
                console.warn('No AI insights provided to populateAIInsights');
                return;
            }
            
            if (aiInsights.key_findings) {
                const content = aiInsights.key_findings;
                const element = document.getElementById('keyFindingsContent');
                if (element) {
                    element.innerHTML = formatMarkdownContent(content);
                    document.getElementById('aiKeyFindingsSection').style.display = 'block';
                    
                    // Show the Population Demographics caption section after Key Findings
                    const captionSection = document.getElementById('populationDemographicsCaptionSection');
                    if (captionSection) {
                        captionSection.style.display = 'block';
                    }
                }
            }
            
            // Populate demographic overview intro (hardcoded two sentences) and discussion
            const demographicOverviewIntroEl = document.getElementById('demographicOverviewIntro');
            if (demographicOverviewIntroEl && metadata && metadata.years && metadata.years.length > 0) {
                const years = metadata.years;
                const yearRange = years.length > 1 
                    ? `${Math.min(...years)} to ${Math.max(...years)}`
                    : years[0].toString();
                demographicOverviewIntroEl.textContent = `This table shows lending activity by race and ethnicity over the time period ${yearRange}, including the number and percentage of loans to each race and ethnic group. Percentages are calculated using loans with demographic data as the denominator (loans without race/ethnicity data are excluded from the calculation). The table includes a change column showing the increase or decrease of each group over the entire span of years in the report, with positive changes displayed in blue and negative changes in red.`;
            }
            
            if (aiInsights.demographic_overview_discussion) {
                console.log('[DEBUG] Found demographic_overview_discussion, length:', aiInsights.demographic_overview_discussion.length);
                const discussionEl = document.getElementById('demographicOverviewDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.demographic_overview_discussion);
                    discussionEl.style.display = 'block'; // Ensure it's visible
                    console.log('[DEBUG] Populated demographicOverviewDiscussion element');
                    
                    // Show AI caption
                    const aiCaption = document.getElementById('demographicOverviewAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                } else {
                    console.error('[ERROR] Could not find demographicOverviewDiscussion element');
                }
            } else {
                console.warn('[WARNING] demographic_overview_discussion is missing or empty from aiInsights');
                // Show appropriate message based on whether AI is disabled
                const discussionEl = document.getElementById('demographicOverviewDiscussion');
                if (discussionEl) {
                    if (aiDisabled) {
                        discussionEl.innerHTML = getAIDisabledMessage();
                    } else {
                        discussionEl.innerHTML = '<p><em>Analysis narrative is being generated. Please refresh the page in a moment.</em></p>';
                    }
                    discussionEl.style.display = 'block';
                }
            }
            
            // Populate income borrowers discussion (Table 1)
            if (aiInsights.income_borrowers_discussion) {
                const discussionEl = document.getElementById('incomeBorrowersDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.income_borrowers_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('incomeBorrowersAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                }
            } else if (aiInsights.income_neighborhood_discussion) {
                // Fallback to combined discussion if separate one doesn't exist
                const discussionEl = document.getElementById('incomeBorrowersDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.income_neighborhood_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('incomeBorrowersAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                }
            } else if (aiDisabled) {
                const discussionEl = document.getElementById('incomeBorrowersDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = getAIDisabledMessage();
                    discussionEl.style.display = 'block';
                }
            }
            
            // Populate income tracts discussion (Table 2)
            if (aiInsights.income_tracts_discussion) {
                const discussionEl = document.getElementById('incomeTractsDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.income_tracts_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('incomeTractsAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                }
            } else if (aiInsights.income_neighborhood_discussion) {
                // Fallback to combined discussion if separate one doesn't exist
                const discussionEl = document.getElementById('incomeTractsDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.income_neighborhood_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('incomeTractsAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                }
            } else if (aiDisabled) {
                const discussionEl = document.getElementById('incomeTractsDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = getAIDisabledMessage();
                    discussionEl.style.display = 'block';
                }
            }
            
            // Populate minority tracts discussion (Table 3)
            if (aiInsights.minority_tracts_discussion) {
                const discussionEl = document.getElementById('minorityTractsDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.minority_tracts_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('minorityTractsAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                }
            } else if (aiInsights.income_neighborhood_discussion) {
                // Fallback to combined discussion if separate one doesn't exist
                const discussionEl = document.getElementById('minorityTractsDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.income_neighborhood_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('minorityTractsAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                }
            } else if (aiDisabled) {
                const discussionEl = document.getElementById('minorityTractsDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = getAIDisabledMessage();
                    discussionEl.style.display = 'block';
                }
            }
            
            // Legacy: Populate income and neighborhood indicators discussion (for backward compatibility)
            if (aiInsights.income_neighborhood_discussion) {
                const discussionEl = document.getElementById('incomeNeighborhoodDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.income_neighborhood_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('incomeNeighborhoodAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                }
            } else if (aiDisabled) {
                const discussionEl = document.getElementById('incomeNeighborhoodDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = getAIDisabledMessage();
                    discussionEl.style.display = 'block';
                }
            }
            
            // Populate top lenders detailed intro (hardcoded two sentences) and discussion
            const topLendersDetailedIntroEl = document.getElementById('topLendersDetailedIntro');
            if (topLendersDetailedIntroEl && metadata && metadata.years && metadata.years.length > 0) {
                const latestYear = Math.max(...metadata.years);
                let introText = `This table shows the top lenders by total number of loans or applications in ${latestYear} (the most recent year in the report), displayed in descending order by total loans. For each lender, the table shows the share of loans to each race and ethnic group, as well as income and neighborhood indicator variables (LMIB, LMICT, MMCT), using the same calculation methods as the tables above. All columns in this table are sortable by clicking on the column headers.`;
                
                // Add HHI information if available
                if (metadata.hhi && metadata.hhi.hhi !== null && metadata.hhi.hhi !== undefined) {
                    const hhiValue = Math.round(metadata.hhi.hhi);
                    const concentrationLevel = metadata.hhi.concentration_level || 'Unknown';
                    const hhiYear = metadata.hhi.year || latestYear;
                    introText += ` The Herfindahl-Hirschman Index (HHI) for this area in ${hhiYear} is ${hhiValue}, indicating ${concentrationLevel.toLowerCase()}.`;
                }
                
                topLendersDetailedIntroEl.textContent = introText;
            }
            
            if (aiInsights.top_lenders_detailed_discussion) {
                console.log('[DEBUG] Found top_lenders_detailed_discussion, length:', aiInsights.top_lenders_detailed_discussion.length);
                const discussionEl = document.getElementById('topLendersDetailedDiscussion');
                if (discussionEl) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.top_lenders_detailed_discussion);
                    discussionEl.style.display = 'block';
                    console.log('[DEBUG] Populated topLendersDetailedDiscussion element');
                    
                    // Show AI caption
                    const aiCaption = document.getElementById('topLendersDetailedAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                } else {
                    console.error('[ERROR] Could not find topLendersDetailedDiscussion element');
                }
            } else {
                console.warn('[WARNING] top_lenders_detailed_discussion is missing or empty from aiInsights');
                // Show appropriate message based on whether AI is disabled
                const discussionEl = document.getElementById('topLendersDetailedDiscussion');
                if (discussionEl) {
                    if (aiDisabled) {
                        discussionEl.innerHTML = getAIDisabledMessage();
                        discussionEl.style.display = 'block';
                    }
                }
            }
            
            if (aiInsights.bank_strategies) {
                const content = aiInsights.bank_strategies;
                const element = document.getElementById('bankStrategiesContent');
                if (element) {
                    element.innerHTML = formatMarkdownContent(content);
                    document.getElementById('aiBankStrategiesSection').style.display = 'block';
                }
            }
            
            if (aiInsights.community_impact) {
                const content = aiInsights.community_impact;
                const element = document.getElementById('communityImpactContent');
                if (element) {
                    element.innerHTML = formatMarkdownContent(content);
                    document.getElementById('aiCommunityImpactSection').style.display = 'block';
                }
            }
            
            if (aiInsights.trends_analysis) {
                const content = aiInsights.trends_analysis;
                const element = document.getElementById('trendsAnalysisContent');
                if (element) {
                    element.innerHTML = formatMarkdownContent(content);
                    document.getElementById('aiTrendsAnalysisSection').style.display = 'block';
                }
            }
        }
        
        function formatMarkdownContent(content) {
            // Split into paragraphs
            const paragraphs = content.split('\n\n').filter(p => p.trim());
            
            return paragraphs.map(paragraph => {
                let formatted = paragraph.trim();
                
                // Remove lines that start with ## (markdown headers) since we already have section titles
                const lines = formatted.split('\n');
                const filteredLines = lines.filter(line => {
                    const trimmed = line.trim();
                    // Skip lines that start with ## (markdown headers)
                    return !trimmed.startsWith('##');
                });
                formatted = filteredLines.join('\n').trim();
                
                // Skip empty paragraphs after filtering
                if (!formatted) {
                    return '';
                }
                
                // Convert **text** to <strong>text</strong>
                formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                
                // Convert markdown links [text](url) to <a href="url">text</a>
                formatted = formatted.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                
                // Convert bullet points • to proper list items
                if (formatted.includes('•')) {
                    const lines = formatted.split('\n');
                    const listItems = lines.map(line => {
                        if (line.trim().startsWith('•')) {
                            return `<li>${line.trim().substring(1).trim()}</li>`;
                        }
                        return line;
                    });
                    
                    // Check if we have list items
                    const hasListItems = listItems.some(item => item.startsWith('<li>'));
                    if (hasListItems) {
                        // Group consecutive list items
                        let result = '';
                        let inList = false;
                        
                        for (let i = 0; i < listItems.length; i++) {
                            const item = listItems[i];
                            if (item.startsWith('<li>')) {
                                if (!inList) {
                                    result += '<ul>';
                                    inList = true;
                                }
                                result += item;
                            } else {
                                if (inList) {
                                    result += '</ul>';
                                    inList = false;
                                }
                                if (item.trim()) {
                                    result += `<p>${item}</p>`;
                                }
                            }
                        }
                        
                        if (inList) {
                            result += '</ul>';
                        }
                        
                        return result;
                    }
                }
                
                return `<p>${formatted}</p>`;
            }).filter(p => p).join(''); // Filter out empty strings
        }
        
        function populateSummaryCards(rawData) {
            if (!rawData || rawData.length === 0) return;
            
            const cardsContainer = document.getElementById('summaryCards');
            
            // Find the latest year from the data
            const years = [...new Set(rawData.map(row => row['year']))].sort((a, b) => b - a);
            const latestYear = years[0];
            
            // Update the section title with the latest year
            const titleElement = document.getElementById('latestStatsTitle');
            if (titleElement) {
                titleElement.textContent = `Latest Statistics (${latestYear})`;
            }
            
            // Filter data for the latest year only
            const latestYearData = rawData.filter(row => row['year'] === latestYear);
            
            // Compute unique branches by uninumbr for the latest year only
            // Properly dedupe: LMI only, MMCT only, and both
            const uniqueAll = new Set();
            const uniqueLMIOnly = new Set();      // LMI=1, MMCT=0
            const uniqueMMCTOnly = new Set();     // LMI=0, MMCT=1
            const uniqueBoth = new Set();         // LMI=1, MMCT=1
            
            latestYearData.forEach(row => {
                const id = row['uninumbr'];
                if (id !== null && id !== undefined) {
                    uniqueAll.add(id);
                    
                    // Check LMI and MMCT status
                    const isLMI = (row['lmict'] === 1 || row['br_lmi'] === 1);
                    const isMMCT = (row['mmct'] === 1 || row['br_minority'] === 1);
                    
                    if (isLMI && !isMMCT) {
                        uniqueLMIOnly.add(id);
                    } else if (!isLMI && isMMCT) {
                        uniqueMMCTOnly.add(id);
                    } else if (isLMI && isMMCT) {
                        uniqueBoth.add(id);
                    }
                }
            });
            
            const totalBranches = uniqueAll.size;
            const lmiOnlyCount = uniqueLMIOnly.size;
            const mmctOnlyCount = uniqueMMCTOnly.size;
            const bothCount = uniqueBoth.size;
            
            // Calculate percentages
            const lmiOnlyPct = totalBranches > 0 ? ((lmiOnlyCount / totalBranches) * 100).toFixed(1) : '0.0';
            const mmctOnlyPct = totalBranches > 0 ? ((mmctOnlyCount / totalBranches) * 100).toFixed(1) : '0.0';
            const bothPct = totalBranches > 0 ? ((bothCount / totalBranches) * 100).toFixed(1) : '0.0';
            
            cardsContainer.innerHTML = `
                <div class="summary-card">
                    <h3>${totalBranches.toLocaleString()}</h3>
                    <p>Total Branches (${latestYear})</p>
                </div>
                <div class="summary-card">
                    <h3>${lmiOnlyCount.toLocaleString()} <span class="percentage-text">(${lmiOnlyPct}%)</span></h3>
                    <p>LMI Only Branches (${latestYear})</p>
                </div>
                <div class="summary-card">
                    <h3>${mmctOnlyCount.toLocaleString()} <span class="percentage-text">(${mmctOnlyPct}%)</span></h3>
                    <p>MMCT Only Branches (${latestYear})</p>
                </div>
                <div class="summary-card">
                    <h3>${bothCount.toLocaleString()} <span class="percentage-text">(${bothPct}%)</span></h3>
                    <p>Both LMICT/MMCT Branches (${latestYear})</p>
                </div>
            `;
        }
        
        function toggleTable(tableId) {
            const table = document.getElementById(tableId);
            const button = table.previousElementSibling.querySelector('.collapse-btn');
            const icon = button.querySelector('i');
            
            if (table.classList.contains('collapsed')) {
                // Expand table - show all rows
                table.classList.remove('collapsed');
                button.classList.remove('collapsed');
                icon.style.transform = 'rotate(0deg)';
                
                // Show all rows
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => row.style.display = '');
            } else {
                // Collapse table - show only first 3 rows with fade
                table.classList.add('collapsed');
                button.classList.add('collapsed');
                icon.style.transform = 'rotate(-90deg)';
                
                // Hide rows beyond the first 3
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach((row, index) => {
                    if (index >= 3) {
                        row.style.display = 'none';
                    }
                });
            }
        }
        
        function populateTable(tableId, data, metadata = null, tableKey = null) {
            if (!data || data.length === 0) return;
            
            const table = document.getElementById(tableId);
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            // Special handling for summaryTable (transposed structure)
            if (tableId === 'summaryTable') {
                // Get all column names (Variable + years)
                const columns = Object.keys(data[0]);
                const variableCol = 'Variable';
                const yearCols = columns.filter(col => col !== variableCol).sort((a, b) => {
                    // Put "Net Change" at the end
                    if (a === 'Net Change') return 1;
                    if (b === 'Net Change') return -1;
                    // Sort numeric years
                    return parseInt(a) - parseInt(b);
                });
                
                // Build header row
                let headerRow = `<tr><th style="text-align: left;">${variableCol}</th>`;
                yearCols.forEach(year => {
                    headerRow += `<th style="text-align: center;">${year}</th>`;
                });
                headerRow += '</tr>';
                thead.innerHTML = headerRow;
                
                // Build data rows
                tbody.innerHTML = data.map(row => {
                    let cells = `<td style="text-align: left; font-weight: 600;">${row[variableCol]}</td>`;
                    yearCols.forEach(year => {
                        let value = row[year];
                        if (value === null || value === undefined) {
                            value = 0;
                        }
                        // Format as number with commas
                        const formatted = typeof value === 'number' ? value.toLocaleString() : value;
                        
                        // Apply color coding for Net Change column (same as bankTable)
                        if (year === 'Net Change') {
                            const numValue = typeof value === 'number' ? value : parseFloat(value);
                            const color = numValue < 0 ? 'red' : (numValue > 0 ? '#2fade3' : 'black');
                            cells += `<td style="text-align: center; color: ${color}; font-weight: 600;">${formatted}</td>`;
                        } else {
                            cells += `<td style="text-align: center;">${formatted}</td>`;
                        }
                    });
                    return `<tr>${cells}</tr>`;
                }).join('');
                
                // Populate caption with metadata
                if (metadata) {
                    const caption = document.getElementById('summaryTableCaption');
                    if (caption) {
                        const counties = metadata.counties || [];
                        const years = metadata.years || [];
                        const countyCount = counties.length;
                        
                        let captionText = '<strong>Source:</strong> FDIC Summary of Deposits';
                        
                        if (countyCount > 1) {
                            captionText += ` | <strong>Note:</strong> Data for ${countyCount} counties (${counties.join(', ')}) are summed across all years shown.`;
                        } else if (countyCount === 1) {
                            captionText += ` | <strong>County:</strong> ${counties[0]}`;
                        }
                        
                        if (years && years.length > 0) {
                            const yearRange = years.length > 1 
                                ? `${Math.min(...years)}-${Math.max(...years)}`
                                : years[0].toString();
                            captionText += ` | <strong>Years:</strong> ${yearRange}`;
                        }
                        
                        caption.innerHTML = captionText;
                    }
                }
                
                return;
            }
            
            // Standard table population for other tables
            // Get the table headers to determine column order
            const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
            
            tbody.innerHTML = data.map((row, rowIndex) => {
                // Map data to columns in the correct order based on table headers
                const cells = headers.map(header => {
                    let value = row[header];
                    if (value === null || value === undefined) {
                        return '';
                    }
                    
                    // Format based on column type
                    if (header.toLowerCase().includes('year')) {
                        // Years should not have commas
                        return value.toString();
                    } else if (header.includes('%') || header.toLowerCase().includes('percent')) {
                        // Percentage fields
                        if (typeof value === 'number') {
                            return value.toFixed(1) + '%';
                        }
                        return value + '%';
                    } else if (header.toLowerCase().includes('yoy') || header.toLowerCase().includes('change')) {
                        // YoY change fields - add + for positive values
                        if (typeof value === 'number') {
                            if (value > 0) {
                                return '+' + value.toFixed(1) + '%';
                            } else {
                                return value.toFixed(1) + '%';
                            }
                        }
                        return value;
                    } else if (typeof value === 'number') {
                        // Regular numbers with commas
                        return value.toLocaleString();
                    }
                    return value;
                });
                
                // Special handling for bankTable - first column (Bank Name) should be left-aligned
                // Also handle Net Change column with color coding
                if (tableId === 'bankTable') {
                    const bankNameCell = cells[0];
                    const otherCellsArray = cells.slice(1);
                    const otherCells = otherCellsArray.map((cell, idx) => {
                        // Check if this is the Net Change column (last column)
                        // Header may be "Net Change" or "Net Change (YYYY-YYYY)"
                        const headerIndex = idx + 1; // +1 because we sliced off the first cell
                        const headerText = headerIndex < headers.length ? headers[headerIndex] : '';
                        if (headerText && headerText.startsWith('Net Change')) {
                            const netChangeValue = row['Net Change'];
                            if (netChangeValue !== null && netChangeValue !== undefined) {
                                const numValue = typeof netChangeValue === 'number' ? netChangeValue : parseFloat(netChangeValue);
                                const color = numValue < 0 ? 'red' : (numValue > 0 ? '#2fade3' : 'black');
                                const formatted = typeof numValue === 'number' ? numValue.toLocaleString() : numValue;
                                return `<td style="text-align: center; color: ${color}; font-weight: 600;">${formatted}</td>`;
                            }
                        }
                        return `<td style="text-align: center;">${cell}</td>`;
                    });
                    // Hide rows beyond the first 10 (index 0-9)
                    const isHidden = rowIndex >= 10 ? 'style="display: none;"' : '';
                    return `<tr data-index="${rowIndex}" ${isHidden}><td style="text-align: left; font-weight: 600;">${bankNameCell}</td>${otherCells.join('')}</tr>`;
                }
                
                return `<tr>${cells.map(cell => `<td style="text-align: center;">${cell}</td>`).join('')}</tr>`;
            }).join('');
            
            // Populate caption for bankTable
            if (tableId === 'bankTable' && metadata) {
                const caption = document.getElementById('bankTableCaption');
                if (caption) {
                    const years = metadata.years || [];
                    const latestYear = years.length > 0 ? Math.max(...years) : '';
                    let captionText = '<strong>Source:</strong> FDIC Summary of Deposits';
                    if (latestYear) {
                        captionText += ` | <strong>Year:</strong> ${latestYear} (most recent year in report)`;
                    }
                    caption.innerHTML = captionText;
                }
            }
            
            // Populate caption for countyTable
            if (tableId === 'countyTable' && metadata) {
                const caption = document.getElementById('countyTableCaption');
                if (caption) {
                    const years = metadata.years || [];
                    const latestYear = years.length > 0 ? Math.max(...years) : '';
                    const counties = metadata.counties || [];
                    let captionText = '<strong>Source:</strong> FDIC Summary of Deposits';
                    if (latestYear) {
                        captionText += ` | <strong>Year:</strong> ${latestYear} (most recent year in report)`;
                    }
                    if (counties.length > 1) {
                        captionText += ` | <strong>Counties:</strong> ${counties.join(', ')}`;
                    }
                    caption.innerHTML = captionText;
                }
            }
        }
        
        function populateDemographicOverviewTable(data, metadata) {
            if (!data || data.length === 0) return;
            
            console.log('populateDemographicOverviewTable called with:', {
                dataLength: data.length,
                firstRow: data[0],
                hasMetadata: !!metadata,
                hasCensusData: metadata ? !!metadata.census_data : false
            });
            
            const table = document.getElementById('demographicOverviewTable');
            if (!table) {
                console.warn('[WARNING] demographicOverviewTable not found, skipping population');
                return;
            }
            
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            if (!thead || !tbody) {
                console.warn('[WARNING] demographicOverviewTable missing thead or tbody, skipping population');
                return;
            }
            
            // Get all column names (Metric + years + Population Share + Change column)
            const columns = Object.keys(data[0]);
            const metricCol = 'Metric';
            const populationShareCol = 'Population Share (%)';
            
            console.log('Table columns:', columns);
            console.log('Has Population Share column:', columns.includes(populationShareCol));
            
            // Separate columns into categories
            const yearCols = columns.filter(col => {
                return col !== metricCol && 
                       col !== populationShareCol && 
                       !col.startsWith('Change Over Time') &&
                       !isNaN(parseInt(col));
            }).sort((a, b) => parseInt(a) - parseInt(b));
            
            const changeCol = columns.find(col => col.startsWith('Change Over Time'));
            const hasPopulationShare = columns.includes(populationShareCol);
            
            // Build header row with column width styles
            // Metric column: auto-width, no wrapping
            // Population Share column: between Metric and year columns
            // Other columns: fixed width (100px)
            let headerRow = `<tr><th style="text-align: left; white-space: nowrap; width: auto; min-width: 0;">${metricCol}</th>`;
            // Add Population Share column (if available) BETWEEN Metric and year columns
            if (hasPopulationShare) {
                headerRow += `<th style="text-align: center; width: 120px; min-width: 120px;">${populationShareCol}</th>`;
            }
            // Add year columns
            yearCols.forEach(year => {
                headerRow += `<th style="text-align: center; width: 100px; min-width: 100px;">${year}</th>`;
            });
            // Add Change column at the end
            if (changeCol) {
                // Shorten column header to just "Change"
                headerRow += `<th style="text-align: center; width: 100px; min-width: 100px;">Change</th>`;
            }
            headerRow += '</tr>';
            thead.innerHTML = headerRow;
            
            // Build table rows
            // Data format: Total Loans row has integers, race/ethnicity rows have percentages only
            const rowsHtml = data.map((row, rowIndex) => {
                const metric = row[metricCol];
                const isTotalLoans = metric === 'Total Loans';
                
                // Metric column: auto-width, no wrapping
                let cells = `<td style="text-align: left; font-weight: ${isTotalLoans ? '600' : '500'}; white-space: nowrap; width: auto; min-width: 0;">${metric}</td>`;
                
                // Add Population Share column (if available) BEFORE year columns
                if (hasPopulationShare) {
                    let popValue = row[populationShareCol];
                    if (popValue === null || popValue === undefined || popValue === '') {
                        popValue = '';
                    } else if (typeof popValue === 'number') {
                        // Format as percentage if it's a number
                        popValue = popValue.toFixed(1) + '%';
                    }
                    cells += `<td style="text-align: center; ${isTotalLoans ? 'font-weight: 600;' : ''} width: 120px; min-width: 120px;">${popValue}</td>`;
                }
                
                // Add year columns with fixed width
                yearCols.forEach(year => {
                    let value = row[year];
                    if (value === null || value === undefined) {
                        value = isTotalLoans ? '0' : '0.0%';
                    }
                    
                    // Year columns: Total Loans shows integer, others show percentage
                    if (isTotalLoans) {
                        cells += `<td style="text-align: center; font-weight: 600; width: 100px; min-width: 100px;">${value}</td>`;
                    } else {
                        cells += `<td style="text-align: center; width: 100px; min-width: 100px;">${value}</td>`;
                    }
                });
                
                // Add Change Over Time column (if available) with fixed width
                if (changeCol) {
                    let value = row[changeCol];
                    if (value === null || value === undefined) {
                        value = isTotalLoans ? '0.0%' : '0.0pp';
                    }
                    
                    // For Total Loans, ensure it's formatted as percentage if it's not already
                    if (isTotalLoans && value && !String(value).includes('%')) {
                        // If it's a number, format as percentage
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                            value = numValue > 0 ? `+${numValue.toFixed(1)}%` : `${numValue.toFixed(1)}%`;
                        }
                    }
                    
                    // Apply color coding for Change Over Time column
                    const changeStr = String(value);
                    const isPositive = changeStr.startsWith('+');
                    const isNegative = changeStr.startsWith('-') && !changeStr.startsWith('+');
                    
                    // NCRC light blue for positive, red for negative
                    const color = isPositive ? '#2fade3' : (isNegative ? 'red' : 'black');
                    cells += `<td style="text-align: center; color: ${color}; font-weight: 600; width: 100px; min-width: 100px;">${value}</td>`;
                }
                
                // Add border styling for Total Loans row
                let rowStyle = '';
                if (isTotalLoans) {
                    rowStyle = 'border-bottom: 2px solid #e0e0e0;';
                }
                
                return `<tr style="${rowStyle}">${cells}</tr>`;
            }).join('');
            
            tbody.innerHTML = rowsHtml;
            
            // Show the demographic overview section
            const section = document.getElementById('demographicOverviewTableSection');
            if (section) {
                section.style.display = 'block';
            }
            
            // Populate caption with data source and methodology (moved to left under demographic overview)
            if (metadata) {
                const caption = document.getElementById('demographicOverviewCaption');
                if (caption) {
                    const counties = metadata.counties || [];
                    const years = metadata.years || [];
                    const yearRange = years.length > 1 
                        ? `${Math.min(...years)}-${Math.max(...years)}`
                        : years[0] ? years[0].toString() : '';
                    const firstYear = years.length > 0 ? Math.min(...years) : '';
                    const lastYear = years.length > 0 ? Math.max(...years) : '';
                    
                    let captionText = '<strong>Source:</strong> Home Mortgage Disclosure Act (HMDA) data, compiled and maintained in NCRC\'s curated databases. ';
                    captionText += '<strong>Methodology:</strong> Percentages are calculated as (group loans / loans with demographic data) × 100, where loans with demographic data = total loans minus loans without race/ethnicity data. ';
                    captionText += 'Groups representing less than 1% of overall loans are excluded from this table. ';
                    if (firstYear && lastYear) {
                        captionText += `<strong>Note:</strong> The Change column indicates the change over time since ${firstYear} through ${lastYear}.`;
                    }
                    
                    if (counties.length > 0) {
                        captionText += ` | <strong>Counties:</strong> ${counties.join(', ')}`;
                    }
                    if (yearRange) {
                        captionText += ` | <strong>Years:</strong> ${yearRange}`;
                    }
                    
                    caption.innerHTML = captionText;
                }
            }
        }
        
        function populateIncomeNeighborhoodTable(data, metadata) {
            if (!data || data.length === 0) return;
            
            const table = document.getElementById('incomeNeighborhoodTable');
            if (!table) {
                console.warn('[DEBUG] incomeNeighborhoodTable not found, skipping population (legacy table)');
                return;
            }
            
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            if (!thead || !tbody) {
                console.warn('[WARNING] incomeNeighborhoodTable missing thead or tbody, skipping population');
                return;
            }
            
            // Get all column names (Metric + years + Change column)
            const columns = Object.keys(data[0]);
            const metricCol = 'Metric';
            const yearCols = columns.filter(col => col !== metricCol).sort((a, b) => {
                // Put "Change Over Time" at the end
                if (a.startsWith('Change Over Time')) return 1;
                if (b.startsWith('Change Over Time')) return -1;
                // Sort numeric years
                return parseInt(a) - parseInt(b);
            });
            
            // Build header row with column width styles
            // Metric column: auto-width, no wrapping
            // Other columns: fixed width (100px)
            let headerRow = `<tr><th style="text-align: left; white-space: nowrap; width: auto; min-width: 0;">${metricCol}</th>`;
            yearCols.forEach(year => {
                // Shorten "Change Over Time" header to just "Change"
                const headerText = year.startsWith('Change Over Time') ? 'Change' : year;
                headerRow += `<th style="text-align: center; width: 100px; min-width: 100px;">${headerText}</th>`;
            });
            headerRow += '</tr>';
            thead.innerHTML = headerRow;
            
            // Build data rows
            // Data format: "Loans" row has integers, other rows have percentages only
            tbody.innerHTML = data.map((row, rowIndex) => {
                const metric = row[metricCol];
                const isLoansRow = metric === 'Loans';
                
                // Metric column: auto-width, no wrapping
                let cells = `<td style="text-align: left; font-weight: 600; white-space: nowrap; width: auto; min-width: 0;">${metric}</td>`;
                
                yearCols.forEach(year => {
                    let value = row[year];
                    if (value === null || value === undefined) {
                        value = isLoansRow ? '0' : '0.0%';
                    }
                    
                    // Apply color coding for Change Over Time column
                    if (year.startsWith('Change Over Time')) {
                        // For Loans row, ensure it's formatted as percentage if it's not already
                        if (isLoansRow && value && !String(value).includes('%')) {
                            // If it's a number, format as percentage
                            const numValue = parseFloat(value);
                            if (!isNaN(numValue)) {
                                value = numValue > 0 ? `+${numValue.toFixed(1)}%` : `${numValue.toFixed(1)}%`;
                            }
                        }
                        
                        // Parse the change value
                        const changeStr = String(value);
                        const isPositive = changeStr.startsWith('+');
                        const isNegative = changeStr.startsWith('-') && !changeStr.startsWith('+');
                        
                        // NCRC light blue for positive, red for negative
                        const color = isPositive ? '#2fade3' : (isNegative ? 'red' : 'black');
                        cells += `<td style="text-align: center; color: ${color}; font-weight: 600; width: 100px; min-width: 100px;">${value}</td>`;
                    } else {
                        // Year columns: Loans row shows integer, others show percentage
                        if (isLoansRow) {
                            cells += `<td style="text-align: center; font-weight: 600; width: 100px; min-width: 100px;">${value}</td>`;
                        } else {
                            cells += `<td style="text-align: center; width: 100px; min-width: 100px;">${value}</td>`;
                        }
                    }
                });
                
                return `<tr>${cells}</tr>`;
            }).join('');
            
            // Populate caption (moved to left under intro text)
            if (metadata) {
                const caption = document.getElementById('incomeNeighborhoodCaption');
                if (caption) {
                    const counties = metadata.counties || [];
                    const years = metadata.years || [];
                    const yearRange = years.length > 1 
                        ? `${Math.min(...years)}-${Math.max(...years)}`
                        : years[0] ? years[0].toString() : '';
                    const firstYear = years.length > 0 ? Math.min(...years) : '';
                    const lastYear = years.length > 0 ? Math.max(...years) : '';
                    
                    let captionText = '<strong>Source:</strong> Home Mortgage Disclosure Act (HMDA) data, compiled and maintained in NCRC\'s curated databases. ';
                    captionText += '<strong>Methodology:</strong> Percentages are calculated as (category loans / total loans) × 100. ';
                    captionText += 'LMICT = Low to Moderate Income Census Tract. ';
                    captionText += 'LMIB = Low to Moderate Income Borrower. ';
                    captionText += 'MMCT = Majority Minority Census Tract. ';
                    if (firstYear && lastYear) {
                        captionText += `<strong>Note:</strong> The Change column indicates the change over time since ${firstYear} through ${lastYear}.`;
                    }
                    
                    if (counties.length > 0) {
                        captionText += ` | <strong>Counties:</strong> ${counties.join(', ')}`;
                    }
                    if (yearRange) {
                        captionText += ` | <strong>Years:</strong> ${yearRange}`;
                    }
                    
                    caption.innerHTML = captionText;
                }
            }
        }
        
        function populateIncomeBorrowersTable(data, metadata) {
            if (!data || data.length === 0) return;
            
            const table = document.getElementById('incomeBorrowersTable');
            if (!table) {
                console.warn('[WARNING] incomeBorrowersTable not found, skipping population');
                return;
            }
            
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            if (!thead || !tbody) {
                console.warn('[WARNING] incomeBorrowersTable missing thead or tbody, skipping population');
                return;
            }
            
            // Get all column names (Metric + Population Share + years + Change column)
            const columns = Object.keys(data[0]);
            const metricCol = 'Metric';
            const popShareCol = 'Population Share (%)';
            const hasPopShare = columns.includes(popShareCol);
            
            const yearCols = columns.filter(col => col !== metricCol && col !== popShareCol).sort((a, b) => {
                // Put "Change" at the end
                if (a === 'Change') return 1;
                if (b === 'Change') return -1;
                // Sort numeric years
                return parseInt(a) - parseInt(b);
            });
            
            // Build header row: Metric | Population Share (%) | Years | Change
            let headerRow = `<tr><th style="text-align: left; white-space: nowrap; min-width: 280px;">${metricCol}</th>`;
            if (hasPopShare) {
                headerRow += `<th style="text-align: center; width: 120px; min-width: 120px;">${popShareCol}</th>`;
            }
            yearCols.forEach((year, index) => {
                const headerText = year === 'Change' ? 'Change' : year;
                // Add vertical line before 2022 column (after 2021) with 50% opacity
                const is2022 = year === '2022' || (parseInt(year) === 2022);
                const borderLeft = is2022 ? 'border-left: 3px solid rgba(51, 51, 51, 0.5);' : '';
                headerRow += `<th style="text-align: center; width: 100px; min-width: 100px; ${borderLeft}">${headerText}</th>`;
            });
            headerRow += '</tr>';
            // Add label row above header if 2022 column exists
            const has2022 = yearCols.some(year => year === '2022' || parseInt(year) === 2022);
            if (has2022) {
                let labelRow = `<tr><th colspan="${hasPopShare ? 2 : 1}" style="border: none; height: 20px;"></th>`;
                yearCols.forEach((year, index) => {
                    const is2022 = year === '2022' || (parseInt(year) === 2022);
                    if (is2022) {
                        labelRow += `<th colspan="1" style="text-align: center; font-size: 0.75em; color: #666; font-weight: normal; padding-bottom: 5px; border-left: 3px solid rgba(51, 51, 51, 0.5); white-space: nowrap;">New Census Boundaries</th>`;
                    } else {
                        labelRow += `<th style="border: none;"></th>`;
                    }
                });
                labelRow += '</tr>';
                thead.innerHTML = labelRow + headerRow;
            } else {
                thead.innerHTML = headerRow;
            }
            
            // Build data rows
            tbody.innerHTML = data.map((row) => {
                const metric = row[metricCol];
                const isTotalLoans = metric === 'Total Loans';
                let cells = `<td style="text-align: left; font-weight: 600; white-space: nowrap; min-width: 280px;">${metric}</td>`;
                
                // Add Population Share column if present
                if (hasPopShare) {
                    const popShare = row[popShareCol] || '';
                    cells += `<td style="text-align: center; width: 120px; min-width: 120px;">${popShare}</td>`;
                }
                
                yearCols.forEach((year, index) => {
                    let value = row[year];
                    if (value === null || value === undefined) {
                        value = isTotalLoans ? '0' : '0.0%';
                    }
                    
                    // Add vertical line before 2022 column (after 2021) with 50% opacity
                    const is2022 = year === '2022' || (parseInt(year) === 2022);
                    const borderLeft = is2022 ? 'border-left: 3px solid rgba(51, 51, 51, 0.5);' : '';
                    
                    // Apply color coding for Change column
                    if (year === 'Change') {
                        const changeStr = String(value);
                        const isPositive = changeStr.startsWith('+');
                        const isNegative = changeStr.startsWith('-') && !changeStr.startsWith('+');
                        const color = isPositive ? '#2fade3' : (isNegative ? 'red' : 'black');
                        cells += `<td style="text-align: center; color: ${color}; font-weight: 600; width: 100px; min-width: 100px; ${borderLeft}">${value}</td>`;
                    } else {
                        // Total Loans row shows integers, other rows show percentages
                        if (isTotalLoans && !value.toString().includes('%')) {
                            // Already formatted as integer with commas
                            cells += `<td style="text-align: center; font-weight: 600; width: 100px; min-width: 100px; ${borderLeft}">${value}</td>`;
                        } else {
                            cells += `<td style="text-align: center; width: 100px; min-width: 100px; ${borderLeft}">${value}</td>`;
                        }
                    }
                });
                
                return `<tr>${cells}</tr>`;
            }).join('');
        }
        
        function populateIncomeTractsTable(data, metadata) {
            if (!data || data.length === 0) return;
            
            const table = document.getElementById('incomeTractsTable');
            if (!table) return;
            
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            // Get all column names (Metric + Population Share + years + Change column)
            const columns = Object.keys(data[0]);
            const metricCol = 'Metric';
            const popShareCol = 'Population Share (%)';
            const hasPopShare = columns.includes(popShareCol);
            
            const yearCols = columns.filter(col => col !== metricCol && col !== popShareCol).sort((a, b) => {
                // Put "Change" at the end
                if (a === 'Change') return 1;
                if (b === 'Change') return -1;
                // Sort numeric years
                return parseInt(a) - parseInt(b);
            });
            
            // Build header row: Metric | Population Share (%) | Years | Change
            let headerRow = `<tr><th style="text-align: left; white-space: nowrap; min-width: 350px;">${metricCol}</th>`;
            if (hasPopShare) {
                headerRow += `<th style="text-align: center; width: 120px; min-width: 120px;">${popShareCol}</th>`;
            }
            yearCols.forEach((year, index) => {
                const headerText = year === 'Change' ? 'Change' : year;
                // Add vertical line before 2022 column (after 2021) with 50% opacity
                const is2022 = year === '2022' || (parseInt(year) === 2022);
                const borderLeft = is2022 ? 'border-left: 3px solid rgba(51, 51, 51, 0.5);' : '';
                headerRow += `<th style="text-align: center; width: 100px; min-width: 100px; ${borderLeft}">${headerText}</th>`;
            });
            headerRow += '</tr>';
            // Add label row above header if 2022 column exists
            const has2022 = yearCols.some(year => year === '2022' || parseInt(year) === 2022);
            if (has2022) {
                let labelRow = `<tr><th colspan="${hasPopShare ? 2 : 1}" style="border: none; height: 20px;"></th>`;
                yearCols.forEach((year, index) => {
                    const is2022 = year === '2022' || (parseInt(year) === 2022);
                    if (is2022) {
                        labelRow += `<th colspan="1" style="text-align: center; font-size: 0.75em; color: #666; font-weight: normal; padding-bottom: 5px; border-left: 3px solid rgba(51, 51, 51, 0.5); white-space: nowrap;">New Census Boundaries</th>`;
                    } else {
                        labelRow += `<th style="border: none;"></th>`;
                    }
                });
                labelRow += '</tr>';
                thead.innerHTML = labelRow + headerRow;
            } else {
                thead.innerHTML = headerRow;
            }
            
            // Track if we need to add asterisk note to caption
            let hasLowIncomeAsterisk = false;
            
            // Build data rows
            tbody.innerHTML = data.map((row) => {
                const metric = row[metricCol];
                const isTotalLoans = metric === 'Total Loans';
                // Check if metric has asterisk (indicates missing tracts)
                if (metric.includes('Low Income Census Tracts*')) {
                    hasLowIncomeAsterisk = true;
                }
                
                let cells = `<td style="text-align: left; font-weight: 600; white-space: nowrap; min-width: 350px;">${metric}</td>`;
                
                // Add Population Share column if present
                if (hasPopShare) {
                    const popShare = row[popShareCol] || '';
                    cells += `<td style="text-align: center; width: 120px; min-width: 120px;">${popShare}</td>`;
                }
                
                yearCols.forEach((year, index) => {
                    let value = row[year];
                    if (value === null || value === undefined) {
                        value = isTotalLoans ? '0' : '0.0%';
                    }
                    
                    // Add vertical line before 2022 column (after 2021) with 50% opacity
                    const is2022 = year === '2022' || (parseInt(year) === 2022);
                    const borderLeft = is2022 ? 'border-left: 3px solid rgba(51, 51, 51, 0.5);' : '';
                    
                    // Apply color coding for Change column
                    if (year === 'Change') {
                        const changeStr = String(value);
                        const isPositive = changeStr.startsWith('+');
                        const isNegative = changeStr.startsWith('-') && !changeStr.startsWith('+');
                        const color = isPositive ? '#2fade3' : (isNegative ? 'red' : 'black');
                        cells += `<td style="text-align: center; color: ${color}; font-weight: 600; width: 100px; min-width: 100px; ${borderLeft}">${value}</td>`;
                    } else {
                        // Total Loans row shows integers, other rows show percentages
                        if (isTotalLoans && !value.toString().includes('%')) {
                            // Already formatted as integer with commas
                            cells += `<td style="text-align: center; font-weight: 600; width: 100px; min-width: 100px; ${borderLeft}">${value}</td>`;
                        } else {
                            cells += `<td style="text-align: center; width: 100px; min-width: 100px; ${borderLeft}">${value}</td>`;
                        }
                    }
                });
                
                return `<tr>${cells}</tr>`;
            }).join('');
            
            // Update caption with asterisk note if needed
            if (hasLowIncomeAsterisk && metadata && metadata.counties && metadata.counties.length > 0) {
                const countyName = metadata.counties[0];
                const asteriskNote = document.getElementById('section2AsteriskNote');
                if (asteriskNote) {
                    asteriskNote.innerHTML = ` <strong>Note:</strong> Columns marked with an asterisk * show 0% because ${countyName} has no census tracts classified as Low Income based on Area Median Income (AMI).`;
                    asteriskNote.style.display = 'inline';
                }
            }
        }
        
        function populateMinorityTractsTable(data, metadata) {
            if (!data || data.length === 0) return;
            
            const table = document.getElementById('minorityTractsTable');
            if (!table) return;
            
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            // Get all column names (Metric + Population Share + years + Change column)
            const columns = Object.keys(data[0]);
            const metricCol = 'Metric';
            const popShareCol = 'Population Share (%)';
            const hasPopShare = columns.includes(popShareCol);
            
            const yearCols = columns.filter(col => col !== metricCol && col !== popShareCol).sort((a, b) => {
                // Put "Change" at the end
                if (a === 'Change') return 1;
                if (b === 'Change') return -1;
                // Sort numeric years
                return parseInt(a) - parseInt(b);
            });
            
            // Build header row: Metric | Population Share (%) | Years | Change
            let headerRow = `<tr><th style="text-align: left; white-space: nowrap; min-width: 350px;">${metricCol}</th>`;
            if (hasPopShare) {
                headerRow += `<th style="text-align: center; width: 120px; min-width: 120px;">${popShareCol}</th>`;
            }
            yearCols.forEach((year, index) => {
                const headerText = year === 'Change' ? 'Change' : year;
                // Add vertical line before 2022 column (after 2021) with 50% opacity
                const is2022 = year === '2022' || (parseInt(year) === 2022);
                const borderLeft = is2022 ? 'border-left: 3px solid rgba(51, 51, 51, 0.5);' : '';
                headerRow += `<th style="text-align: center; width: 100px; min-width: 100px; ${borderLeft}">${headerText}</th>`;
            });
            headerRow += '</tr>';
            // Add label row above header if 2022 column exists
            const has2022 = yearCols.some(year => year === '2022' || parseInt(year) === 2022);
            if (has2022) {
                let labelRow = `<tr><th colspan="${hasPopShare ? 2 : 1}" style="border: none; height: 20px;"></th>`;
                yearCols.forEach((year, index) => {
                    const is2022 = year === '2022' || (parseInt(year) === 2022);
                    if (is2022) {
                        labelRow += `<th colspan="1" style="text-align: center; font-size: 0.75em; color: #666; font-weight: normal; padding-bottom: 5px; border-left: 3px solid rgba(51, 51, 51, 0.5); white-space: nowrap;">New Census Boundaries</th>`;
                    } else {
                        labelRow += `<th style="border: none;"></th>`;
                    }
                });
                labelRow += '</tr>';
                thead.innerHTML = labelRow + headerRow;
            } else {
                thead.innerHTML = headerRow;
            }
            
            // Track if we need to add asterisk note to caption
            let hasMMCTAsterisk = false;
            
            // Build data rows
            tbody.innerHTML = data.map((row) => {
                const metric = row[metricCol];
                const isTotalLoans = metric === 'Total Loans';
                // Check if metric has asterisk (indicates missing tracts)
                if (metric.includes('Majority Minority Census Tracts*')) {
                    hasMMCTAsterisk = true;
                }
                
                let cells = `<td style="text-align: left; font-weight: 600; white-space: nowrap; min-width: 350px;">${metric}</td>`;
                
                // Add Population Share column if present
                if (hasPopShare) {
                    const popShare = row[popShareCol] || '';
                    cells += `<td style="text-align: center; width: 120px; min-width: 120px;">${popShare}</td>`;
                }
                
                yearCols.forEach((year, index) => {
                    let value = row[year];
                    if (value === null || value === undefined) {
                        value = isTotalLoans ? '0' : '0.0%';
                    }
                    
                    // Add vertical line before 2022 column (after 2021) with 50% opacity
                    const is2022 = year === '2022' || (parseInt(year) === 2022);
                    const borderLeft = is2022 ? 'border-left: 3px solid rgba(51, 51, 51, 0.5);' : '';
                    
                    // Apply color coding for Change column
                    if (year === 'Change') {
                        const changeStr = String(value);
                        const isPositive = changeStr.startsWith('+');
                        const isNegative = changeStr.startsWith('-') && !changeStr.startsWith('+');
                        const color = isPositive ? '#2fade3' : (isNegative ? 'red' : 'black');
                        cells += `<td style="text-align: center; color: ${color}; font-weight: 600; width: 100px; min-width: 100px; ${borderLeft}">${value}</td>`;
                    } else {
                        // Total Loans row shows integers, other rows show percentages
                        if (isTotalLoans && !value.toString().includes('%')) {
                            // Already formatted as integer with commas
                            cells += `<td style="text-align: center; font-weight: 600; width: 100px; min-width: 100px; ${borderLeft}">${value}</td>`;
                        } else {
                            cells += `<td style="text-align: center; width: 100px; min-width: 100px; ${borderLeft}">${value}</td>`;
                        }
                    }
                });
                
                return `<tr>${cells}</tr>`;
            }).join('');
            
            // Update caption with asterisk note if needed
            if (hasMMCTAsterisk && metadata && metadata.counties && metadata.counties.length > 0) {
                const countyName = metadata.counties[0];
                const asteriskNote = document.getElementById('section2AsteriskNote');
                if (asteriskNote) {
                    const existingNote = asteriskNote.innerHTML;
                    const mmctNote = ` <strong>Note:</strong> The asterisk * following "Majority Minority Census Tracts" indicates that ${countyName} has no census tracts that meet the qualifications (≥50% minority population).`;
                    asteriskNote.innerHTML = existingNote + (existingNote ? ' ' : '') + mmctNote;
                    asteriskNote.style.display = 'inline';
                }
            }
        }
        
        function populateIncomeNeighborhoodTractsTable(data, metadata) {
            if (!data || data.length === 0) return;
            
            const table = document.getElementById('incomeNeighborhoodTractsTable');
            if (!table) {
                console.warn('[WARNING] incomeNeighborhoodTractsTable not found, skipping population');
                return;
            }
            
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            if (!thead || !tbody) {
                console.warn('[WARNING] incomeNeighborhoodTractsTable missing thead or tbody, skipping population');
                return;
            }
            
            // Get all column names (Metric + years + Change column)
            const columns = Object.keys(data[0]);
            const metricCol = 'Metric';
            const yearCols = columns.filter(col => col !== metricCol).sort((a, b) => {
                // Put "Change" at the end
                if (a === 'Change') return 1;
                if (b === 'Change') return -1;
                // Sort numeric years
                return parseInt(a) - parseInt(b);
            });
            
            // Build header row
            let headerRow = `<tr><th style="text-align: left; white-space: nowrap; min-width: 350px;">${metricCol}</th>`;
            yearCols.forEach(year => {
                const headerText = year === 'Change' ? 'Change' : year;
                headerRow += `<th style="text-align: center; width: 100px; min-width: 100px;">${headerText}</th>`;
            });
            headerRow += '</tr>';
            thead.innerHTML = headerRow;
            
            // Build data rows (all rows show percentages)
            tbody.innerHTML = data.map((row) => {
                const metric = row[metricCol];
                let cells = `<td style="text-align: left; font-weight: 600; white-space: nowrap; min-width: 350px;">${metric}</td>`;
                
                yearCols.forEach(year => {
                    let value = row[year];
                    if (value === null || value === undefined) {
                        value = '0.0%';
                    }
                    
                    // Apply color coding for Change column
                    if (year === 'Change') {
                        const changeStr = String(value);
                        const isPositive = changeStr.startsWith('+');
                        const isNegative = changeStr.startsWith('-') && !changeStr.startsWith('+');
                        const color = isPositive ? '#2fade3' : (isNegative ? 'red' : 'black');
                        cells += `<td style="text-align: center; color: ${color}; font-weight: 600; width: 100px; min-width: 100px;">${value}</td>`;
                    } else {
                        cells += `<td style="text-align: center; width: 100px; min-width: 100px;">${value}</td>`;
                    }
                });
                
                return `<tr>${cells}</tr>`;
            }).join('');
        }
        
        function populateTopLendersDetailedTable(data, metadata) {
            if (!data || data.length === 0) {
                console.warn('No top lenders data available.');
                return;
            }
            
            const table = document.getElementById('topLendersDetailedTable');
            if (!table) {
                console.warn('[WARNING] topLendersDetailedTable not found, skipping population');
                return;
            }
            
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            if (!thead || !tbody) {
                console.warn('[WARNING] topLendersDetailedTable missing thead or tbody, skipping population');
                return;
            }
            
            // Get all column names (excluding Lender Name, Lender Type, and Total Loans)
            const columns = Object.keys(data[0]);
            const baseCols = ['Lender Name', 'Lender Type', 'Total Loans'];
            const dataCols = columns.filter(col => !baseCols.includes(col));
            
            // Sort data columns: race/ethnicity first, then income/neighborhood indicators
            // Note: Only columns >= 1% overall are included (determined in Python)
            const raceCols = dataCols.filter(col => col.includes('Hispanic') || col.includes('Black') || 
                                                    col.includes('White') || col.includes('Asian') || 
                                                    col.includes('Native American') || col.includes('Hawaiian'));
            const indicatorCols = dataCols.filter(col => col.includes('LMIB') || col.includes('LMICT') || col.includes('MMCT'));
            
            // Sort race columns in a consistent order
            const raceOrder = ['Hispanic (%)', 'Black (%)', 'White (%)', 'Asian (%)', 'Native American (%)', 'Hawaiian/Pacific Islander (%)'];
            const sortedRaceCols = raceOrder.filter(col => raceCols.includes(col));
            const otherRaceCols = raceCols.filter(col => !raceOrder.includes(col));
            const finalRaceCols = [...sortedRaceCols, ...otherRaceCols];
            
            // Sort indicator columns
            const indicatorOrder = ['LMIB (%)', 'LMICT (%)', 'MMCT (%)'];
            const sortedIndicatorCols = indicatorOrder.filter(col => indicatorCols.includes(col));
            const otherIndicatorCols = indicatorCols.filter(col => !indicatorOrder.includes(col));
            const finalIndicatorCols = [...sortedIndicatorCols, ...otherIndicatorCols];
            
            // Function to abbreviate column names for display (remove percentage signs)
            function abbreviateColumnName(col) {
                // Remove (%) from all column names
                let displayName = col.replace(' (%)', '');
                if (displayName === 'Native American') return 'Native Am.';
                if (displayName === 'Hawaiian/Pacific Islander') return 'Hawaiian/PI';
                return displayName;
            }
            
            // Build header row with uniform width for data columns and sorting functionality
            // Lender Name column: narrower but still fits long names like "UNITED SHORE FINANCIAL SERVICES" (35 chars)
            // Using smaller font or tighter spacing, but keeping white-space: nowrap
            let headerRow = `<tr>
                <th style="text-align: left; cursor: pointer; user-select: none; white-space: nowrap; min-width: 280px; max-width: 280px; width: 280px; font-size: 0.9em;" onclick="sortTable('topLendersDetailedTable', 0, 'text')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();sortTable('topLendersDetailedTable', 0, 'text');}" tabindex="0" role="button" aria-label="Sort by Lender Name">
                    Lender Name <span class="sort-indicator" id="sort-indicator-0"></span>
                </th>
                <th style="text-align: center; cursor: pointer; user-select: none; width: 90px; min-width: 90px; max-width: 90px; white-space: nowrap;" onclick="sortTable('topLendersDetailedTable', 1, 'text')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();sortTable('topLendersDetailedTable', 1, 'text');}" tabindex="0" role="button" aria-label="Sort by Lender Type">
                    Type <span class="sort-indicator" id="sort-indicator-1"></span>
                </th>
                <th style="text-align: center; cursor: pointer; user-select: none; vertical-align: middle; width: 90px; min-width: 90px; max-width: 90px;" onclick="sortTable('topLendersDetailedTable', 2, 'number')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();sortTable('topLendersDetailedTable', 2, 'number');}" tabindex="0" role="button" aria-label="Sort by Total Loans">
                    Total <span class="sort-indicator" id="sort-indicator-2"></span>
                </th>`;
            
            let colIndex = 3;
            // All data columns (race/ethnicity and indicators) use uniform width
            const uniformColWidth = '90px';
            finalRaceCols.forEach(col => {
                const displayName = abbreviateColumnName(col);
                headerRow += `<th style="text-align: center; vertical-align: middle; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth}; cursor: pointer; user-select: none;" onclick="sortTable('topLendersDetailedTable', ${colIndex}, 'number')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();sortTable('topLendersDetailedTable', ${colIndex}, 'number');}" tabindex="0" role="button" aria-label="Sort by ${displayName}">
                    ${displayName} <span class="sort-indicator" id="sort-indicator-${colIndex}"></span>
                </th>`;
                colIndex++;
            });
            
            finalIndicatorCols.forEach(col => {
                const displayName = abbreviateColumnName(col);
                headerRow += `<th style="text-align: center; vertical-align: middle; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth}; cursor: pointer; user-select: none;" onclick="sortTable('topLendersDetailedTable', ${colIndex}, 'number')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();sortTable('topLendersDetailedTable', ${colIndex}, 'number');}" tabindex="0" role="button" aria-label="Sort by ${displayName}">
                    ${displayName} <span class="sort-indicator" id="sort-indicator-${colIndex}"></span>
                </th>`;
                colIndex++;
            });
            
            headerRow += '</tr>';
            thead.innerHTML = headerRow;
            
            // Store original data for filtering
            window.topLendersData = data;
            // Store column structure for rebuilding table
            window.topLendersRaceCols = finalRaceCols;
            window.topLendersIndicatorCols = finalIndicatorCols;
            
            // Build data rows
            // Use uniform column width for all data columns (uniformColWidth already declared above)
            tbody.innerHTML = data.map((row, rowIndex) => {
                let cells = `<td style="text-align: left; font-weight: 600; white-space: nowrap; min-width: 280px; max-width: 280px; width: 280px; font-size: 0.9em;">${row['Lender Name']}</td>`;
                cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth}; white-space: nowrap;">${row['Lender Type'] || ''}</td>`;
                cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${row['Total Loans']}</td>`;
                
                finalRaceCols.forEach(col => {
                    const value = row[col] || '';
                    cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${value}</td>`;
                });
                
                finalIndicatorCols.forEach(col => {
                    const value = row[col] || '';
                    cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${value}</td>`;
                });
                
                // Hide rows beyond the first 10 (index 0-9) if there are more than 10 lenders
                const isHidden = (data.length > 10 && rowIndex >= 10) ? 'style="display: none;"' : '';
                return `<tr data-index="${rowIndex}" ${isHidden}>${cells}</tr>`;
            }).join('');
            
            // Show expand button only if there are more than 10 lenders
            if (data.length > 10) {
                const expandBtn = document.getElementById('expandTopLendersBtn');
                if (expandBtn) {
                    expandBtn.style.display = 'inline-block';
                }
            }
            
            // Populate caption
            if (metadata) {
                const caption = document.getElementById('topLendersDetailedCaption');
                if (caption) {
                    const years = metadata.years || [];
                    const latestYear = years.length > 0 ? Math.max(...years) : '';
                    const counties = metadata.counties || [];
                    
                    let captionText = '<strong>Source:</strong> Home Mortgage Disclosure Act (HMDA) data, compiled and maintained in NCRC\'s curated databases. ';
                    captionText += '<strong>Year:</strong> ' + latestYear + ' (most recent year in report). ';
                    captionText += '<strong>Methodology:</strong> Lenders are sorted in descending order by total loans. ';
                    captionText += 'Race/ethnicity percentages use denominator = loans with demographic data. ';
                    captionText += 'Income and neighborhood indicator percentages use denominator = total loans. ';
                    captionText += 'Only race/ethnicity groups representing ≥1% of overall lending are included. ';
                    captionText += '<strong>Note:</strong> All categories are in percentages. ';
                    captionText += '<strong>Abbreviations:</strong> Native Am. = Native American; Hawaiian/PI = Hawaiian/Pacific Islander.';
                    
                    if (counties.length > 0) {
                        captionText += ` | <strong>Counties:</strong> ${counties.join(', ')}`;
                    }
                    
                    caption.innerHTML = captionText;
                }
            }
        }
        
        function showError(message) {
            document.getElementById('loadingState').style.display = 'none';
            document.getElementById('errorState').style.display = 'block';
            const errorElement = document.getElementById('errorMessage');
            // Allow HTML in error messages (for links)
            errorElement.innerHTML = message;
        }
        
        // Function to expand/collapse bank table to show all banks or just top 10
        function expandBankTable() {
            const table = document.getElementById('bankTable');
            const rows = table.querySelectorAll('tbody tr');
            const expandBtn = document.getElementById('expandBankTableBtn');
            const icon = expandBtn.querySelector('i');
            
            // Check if currently showing all (rows 10+ are visible)
            const isExpanded = rows.length > 10 && rows[10].style.display !== 'none';
            
            if (isExpanded) {
                // Collapse to top 10
                rows.forEach((row, index) => {
                    if (index >= 10) {
                        row.style.display = 'none';
                    }
                });
                expandBtn.innerHTML = '<i class="fas fa-chevron-down"></i> Show All Banks';
            } else {
                // Expand to show all
                rows.forEach((row) => {
                    row.style.display = '';
                });
                expandBtn.innerHTML = '<i class="fas fa-chevron-up"></i> Show Top 10 Only';
            }
        }
        
        // Function to filter lenders by type and show top 10 of that type
        function filterLendersByType() {
            const filterValue = document.getElementById('lenderTypeFilter').value;
            const table = document.getElementById('topLendersDetailedTable');
            const tbody = table.querySelector('tbody');
            
            if (!window.topLendersData) {
                console.warn('No top lenders data available for filtering');
                return;
            }
            
            // Filter data by lender type
            let filteredData = window.topLendersData;
            if (filterValue !== 'all') {
                filteredData = window.topLendersData.filter(row => row['Lender Type'] === filterValue);
            }
            
            // Sort by Total Loans (descending) - parse the value to handle comma-separated numbers
            filteredData = filteredData.sort((a, b) => {
                const aTotal = parseInt(String(a['Total Loans']).replace(/,/g, '')) || 0;
                const bTotal = parseInt(String(b['Total Loans']).replace(/,/g, '')) || 0;
                return bTotal - aTotal;
            });
            
            // Always take top 10 (or fewer if less than 10) of the filtered/sorted data
            const topLenders = filteredData.slice(0, 10);
            
            // Get column structure from existing table
            const thead = table.querySelector('thead');
            const headerRow = thead.querySelector('tr');
            const columns = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim().split(' ')[0]);
            
            // Rebuild table rows with top lenders
            const uniformColWidth = '90px';
            const raceCols = window.topLendersRaceCols || [];
            const indicatorCols = window.topLendersIndicatorCols || [];
            
            // Build all rows (not just top 10) but hide rows beyond 10
            tbody.innerHTML = filteredData.map((row, rowIndex) => {
                let cells = `<td style="text-align: left; font-weight: 600; white-space: nowrap; min-width: 280px; max-width: 280px; width: 280px; font-size: 0.9em;">${row['Lender Name']}</td>`;
                cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth}; white-space: nowrap;">${row['Lender Type'] || ''}</td>`;
                cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${row['Total Loans']}</td>`;
                
                raceCols.forEach(col => {
                    const value = row[col] || '';
                    cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${value}</td>`;
                });
                
                indicatorCols.forEach(col => {
                    const value = row[col] || '';
                    cells += `<td style="text-align: center; width: ${uniformColWidth}; min-width: ${uniformColWidth}; max-width: ${uniformColWidth};">${value}</td>`;
                });
                
                // Hide rows beyond the first 10 (index 0-9) if there are more than 10 lenders
                const isHidden = (filteredData.length > 10 && rowIndex >= 10) ? 'style="display: none;"' : '';
                return `<tr data-index="${rowIndex}" ${isHidden}>${cells}</tr>`;
            }).join('');
            
            // Update expand button - show it if there are more than 10 lenders, hide otherwise
            const expandBtn = document.getElementById('expandTopLendersBtn');
            if (expandBtn) {
                if (filteredData.length > 10) {
                    expandBtn.style.display = 'inline-block';
                    expandBtn.innerHTML = '<i class="fas fa-chevron-down"></i> Show All Lenders';
                } else {
                    expandBtn.style.display = 'none';
                }
            }
        }
        
        // Function to expand/collapse top lenders table to show all lenders or just top 10
        function expandTopLendersTable() {
            const table = document.getElementById('topLendersDetailedTable');
            const rows = Array.from(table.querySelectorAll('tbody tr')).filter(row => row.style.display !== 'none');
            const expandBtn = document.getElementById('expandTopLendersBtn');
            
            // Only proceed if there are more than 10 visible lenders
            if (rows.length <= 10) {
                return;
            }
            
            // Check if currently showing all (rows 10+ are visible)
            const visibleRows = rows.filter(row => row.style.display !== 'none');
            const isExpanded = visibleRows.length > 10 && visibleRows[10].style.display !== 'none';
            
            if (isExpanded) {
                // Collapse to top 10
                rows.forEach((row, index) => {
                    if (index >= 10) {
                        row.style.display = 'none';
                    }
                });
                expandBtn.innerHTML = '<i class="fas fa-chevron-down"></i> Show All Lenders';
            } else {
                // Expand to show all visible
                rows.forEach((row) => {
                    if (row.style.display !== 'none') {
                        row.style.display = '';
                    }
                });
                expandBtn.innerHTML = '<i class="fas fa-chevron-up"></i> Show Top 10 Only';
            }
        }
        
        // Chart instance for HHI chart (global to allow destruction)
        let hhiChartInstance = null;
        
        function populateMarketConcentrationTable(data, metadata) {
            if (!data || data.length === 0) {
                console.warn('No market concentration data available.');
                const section = document.getElementById('marketConcentrationSection');
                if (section) {
                    section.style.display = 'none';
                }
                return;
            }

            const section = document.getElementById('marketConcentrationSection');
            if (section) {
                section.style.display = 'block';
            }

            // Find "All Loans" row or use first row
            const allLoansRow = data.find(row => row['Loan Purpose'] === 'All Loans') || data[0];
            if (!allLoansRow) {
                console.error('No market concentration row found');
                return;
            }
            
            const table = document.getElementById('marketConcentrationTable');
            if (!table) {
                console.warn('[WARNING] marketConcentrationTable not found, skipping population');
                return;
            }
            
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            if (!thead || !tbody) {
                console.warn('[WARNING] marketConcentrationTable missing thead or tbody, skipping population');
                return;
            }
            
            const years = metadata && metadata.years ? metadata.years : [];
            if (years.length === 0) {
                console.warn('No years in metadata for market concentration');
                return;
            }

            // Sort years numerically
            const sortedYears = [...years].sort((a, b) => a - b);

            // Transform data to Year | HHI format (like Branch Report)
            // The data structure has year columns as strings (e.g., '2020', '2021')
            const hhiByYear = sortedYears.map(year => {
                const yearStr = year.toString();
                const hhiValue = allLoansRow[yearStr] !== undefined ? allLoansRow[yearStr] : (allLoansRow[year] !== undefined ? allLoansRow[year] : 0);
                return {
                    year: yearStr,
                    hhi_value: hhiValue
                };
            });
            
            // Populate the HHI table (reuse existing tbody variable)
            if (tbody) {
                tbody.innerHTML = hhiByYear.map(item => {
                    const hhiNum = parseFloat(item.hhi_value) || 0;
                    return `<tr>
                        <td style="text-align: left;">${item.year}</td>
                        <td style="text-align: center;">${Math.round(hhiNum).toLocaleString()}</td>
                    </tr>`;
                }).join('');
            }

            // Create Chart.js bar chart with threshold lines
            const hhiCanvas = document.getElementById('hhiChart');
            if (hhiCanvas && typeof Chart !== 'undefined') {
                const ctx = hhiCanvas.getContext('2d');

                // Destroy existing chart if it exists
                if (hhiChartInstance) {
                    hhiChartInstance.destroy();
                }

                const yearsLabels = hhiByYear.map(d => d.year);
                // Ensure HHI values are actual numbers, not percentages
                const hhiValues = hhiByYear.map(d => {
                    let value = parseFloat(d.hhi_value || 0);
                    // If value is > 100, it's likely already in HHI format (0-10,000)
                    // If value is <= 100, it might be a percentage - convert to HHI (multiply by 100)
                    // But actually, HHI should already be in 0-10,000 format from backend
                    // So we just ensure it's a number
                    return isNaN(value) ? 0 : value;
                });

                // Calculate max value for y-axis range
                const maxHHI = Math.max(...hhiValues, 2500); // Ensure we show at least up to 2,500
                const yMax = Math.min(Math.max(maxHHI * 1.15, 3000), 10000); // Cap at 10,000 (max HHI value)

                // Register annotation plugin if available
                if (typeof Chart !== 'undefined' && Chart.register) {
                    try {
                        const annotationPlugin = window.chartjsPluginAnnotation;
                        if (annotationPlugin) {
                            Chart.register(annotationPlugin);
                        }
                    } catch (e) {
                        console.warn('Chart.js annotation plugin not available');
                    }
                }

                hhiChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: yearsLabels,
                        datasets: [{
                            label: 'HHI',
                            data: hhiValues,
                            backgroundColor: '#034ea0', // NCRC Dark Blue
                            borderColor: '#034ea0',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                top: 10,
                                bottom: 10,
                                left: 10,
                                right: 10
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            title: {
                                display: true,
                                text: 'Market Concentration (HHI) by Year',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const value = context.parsed.y;
                                        return 'HHI: ' + Math.round(value).toLocaleString();
                                    }
                                }
                            },
                            annotation: {
                                annotations: {
                                    moderateLine: {
                                        type: 'line',
                                        yMin: 1500,
                                        yMax: 1500,
                                        borderColor: 'rgba(255, 165, 0, 0.8)', // Orange for moderate
                                        borderWidth: 2,
                                        borderDash: [5, 5],
                                        label: {
                                            content: 'Moderate (1,500)',
                                            enabled: true,
                                            position: 'end',
                                            backgroundColor: 'rgba(255, 165, 0, 0.9)',
                                            color: 'white',
                                            font: {
                                                size: 11,
                                                weight: 'bold'
                                            },
                                            padding: 4
                                        }
                                    },
                                    highLine: {
                                        type: 'line',
                                        yMin: 2500,
                                        yMax: 2500,
                                        borderColor: 'rgba(255, 0, 0, 0.8)', // Red for high
                                        borderWidth: 2,
                                        borderDash: [5, 5],
                                        label: {
                                            content: 'High (2,500)',
                                            enabled: true,
                                            position: 'end',
                                            backgroundColor: 'rgba(255, 0, 0, 0.9)',
                                            color: 'white',
                                            font: {
                                                size: 11,
                                                weight: 'bold'
                                            },
                                            padding: 4
                                        }
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: yMax,
                                title: {
                                    display: true,
                                    text: 'HHI',
                                    font: {
                                        size: 12,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toLocaleString();
                                    },
                                    font: {
                                        size: 10
                                    }
                                },
                                grid: {
                                    drawOnChartArea: true
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Year',
                                    font: {
                                        size: 12,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    font: {
                                        size: 10
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Remove the table (no longer needed) - reuse existing table variable
            if (table && table.parentElement) {
                table.parentElement.remove();
            }
            
            // Populate AI discussion if available
            const aiInsights = metadata.ai_insights;
            const aiDisabled = metadata && metadata.ai_insights_enabled === false;
            const getAIDisabledMessage = () => {
                return '<div class="alert alert-info" style="padding: 15px; margin: 15px 0; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px;"><strong>AI Insights Not Available:</strong> AI-powered analysis is currently disabled. To enable AI insights, please configure the CLAUDE_API_KEY environment variable in your deployment settings.</div>';
            };

            const discussionEl = document.getElementById('marketConcentrationDiscussion');
            if (discussionEl) {
                if (aiInsights && aiInsights.market_concentration_discussion) {
                    discussionEl.innerHTML = formatMarkdownContent(aiInsights.market_concentration_discussion);
                    discussionEl.style.display = 'block';
                    const aiCaption = document.getElementById('marketConcentrationAICaption');
                    if (aiCaption) {
                        aiCaption.style.display = 'block';
                    }
                } else {
                    if (aiDisabled) {
                        discussionEl.innerHTML = getAIDisabledMessage();
                    } else {
                        discussionEl.innerHTML = '<p><em>Analysis narrative is being generated. Please refresh the page in a moment.</em></p>';
                    }
                    discussionEl.style.display = 'block';
                }
            }
        }
        
        // Table sorting function
        let currentSortColumn = -1;
        let currentSortDirection = 'asc';
        
        function sortTable(tableId, columnIndex, dataType) {
            const table = document.getElementById(tableId);
            if (!table) return;
            
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Clear all sort indicators
            table.querySelectorAll('.sort-indicator').forEach(indicator => {
                indicator.textContent = '';
            });
            
            // Determine sort direction
            if (currentSortColumn === columnIndex) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = columnIndex;
                currentSortDirection = 'asc';
            }
            
            // Sort rows
            rows.sort((a, b) => {
                const aCell = a.cells[columnIndex];
                const bCell = b.cells[columnIndex];
                
                if (!aCell || !bCell) return 0;
                
                let aValue = aCell.textContent.trim();
                let bValue = bCell.textContent.trim();
                
                if (dataType === 'number') {
                    // Extract numeric value (remove % and commas)
                    aValue = parseFloat(aValue.replace(/[%,]/g, '')) || 0;
                    bValue = parseFloat(bValue.replace(/[%,]/g, '')) || 0;
                } else {
                    // Text comparison (case-insensitive)
                    aValue = aValue.toLowerCase();
                    bValue = bValue.toLowerCase();
                }
                
                if (aValue < bValue) return currentSortDirection === 'asc' ? -1 : 1;
                if (aValue > bValue) return currentSortDirection === 'asc' ? 1 : -1;
                return 0;
            });
            
            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
            
            // Update sort indicator
            const indicator = document.getElementById(`sort-indicator-${columnIndex}`);
            if (indicator) {
                indicator.textContent = currentSortDirection === 'asc' ? ' ▲' : ' ▼';
                indicator.setAttribute('aria-label', `Sorted ${currentSortDirection === 'asc' ? 'ascending' : 'descending'}`);
            }
        }
        
        // Update download links immediately (in case DOM is already loaded)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                updateDownloadLinks();
                setupPdfButton();
            });
        } else {
            updateDownloadLinks();
            setupPdfButton();
        }
        
        // Setup PDF button click handler
        function setupPdfButton() {
            const pdfBtn = document.getElementById('downloadPdfBtn');
            console.log('Setting up PDF button, found:', !!pdfBtn);
            if (pdfBtn) {
                // Remove any existing listeners by cloning and replacing
                const newBtn = pdfBtn.cloneNode(true);
                pdfBtn.parentNode.replaceChild(newBtn, pdfBtn);
                
                // Get job_id from URL
                const urlParams = new URLSearchParams(window.location.search);
                const jobId = urlParams.get('job_id');
                
                if (jobId) {
                    // Update href with job_id if not already present
                    let href = newBtn.getAttribute('href');
                    if (href && !href.includes('job_id=')) {
                        const separator = href.includes('?') ? '&' : '?';
                        href = `${href}${separator}job_id=${encodeURIComponent(jobId)}`;
                        newBtn.setAttribute('href', href);
                    }
                }
                
                // Add click handler
                newBtn.addEventListener('click', function(e) {
                    console.log('PDF download button clicked!');
                    const currentHref = this.getAttribute('href');
                    console.log('Current href:', currentHref);
                    // Let the default link behavior proceed
                });
                
                console.log('PDF button setup complete, href:', newBtn.getAttribute('href'));
            } else {
                console.error('PDF button not found!');
            }
        }
        
        // Load report data when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadReportData);
        } else {
            // DOM is already loaded, call immediately
            loadReportData();
        }
    </script>
    
    <!-- Footer -->
    <footer class="footer" style="margin-top: 40px;">
        <div class="footer-bottom">
            &copy; 2025 JustData - LendSight. Powered by AI and BigQuery.<br>
            <span class="version-text">Version {{ version }}</span>
        </div>
    </footer>
</body>
</html>
