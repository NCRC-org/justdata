<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BranchMapper - Bank Branch Location Map</title>
    <meta name="description" content="Interactive map showing bank branch locations with demographic and deposit data.">
    
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16x16.png">
    <!-- Font Awesome for icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Mapbox GL JS CSS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet" />
    <!-- Mapbox GL Draw CSS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.css" rel="stylesheet" />
    
    <!-- Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    
    <!-- Shared CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    
    <style>
        /* Branch Mapper specific styles - Mobile-first responsive design */

        /* Main container - simple flexbox layout */
        .container {
            display: flex !important;
            flex-direction: column !important;
            max-width: 1400px !important;
            margin: 0 auto !important;
            padding: 15px !important;
            gap: 15px !important;
        }

        /* Controls sidebar - appears above map on all screen sizes */
        .controls-sidebar {
            width: 100% !important;
            max-width: 100% !important;
            order: 1;
        }

        /* Content wrapper with map */
        .content-wrapper {
            width: 100% !important;
            max-width: 100% !important;
            min-width: 0;
            overflow: hidden;
            order: 2;
        }

        .mapper-container {
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            padding: 0;
            box-sizing: border-box;
        }

        .map-container {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        #branchMap {
            width: 100%;
            height: 500px;
            box-sizing: border-box;
            border-radius: 8px;
        }

        /* Desktop layout - side by side */
        @media (min-width: 992px) {
            .container {
                flex-direction: row !important;
                align-items: flex-start !important;
            }

            .controls-sidebar {
                width: 300px !important;
                min-width: 300px !important;
                max-width: 300px !important;
                position: sticky !important;
                top: 20px !important;
                order: 1;
                max-height: calc(100vh - 40px);
                overflow-y: auto;
            }

            .content-wrapper {
                flex: 1 !important;
                order: 2;
            }

            #branchMap {
                height: 600px;
            }
        }

        /* Tablet layout */
        @media (min-width: 768px) and (max-width: 991px) {
            .controls-sidebar {
                display: flex;
                flex-wrap: wrap;
                gap: 15px;
            }

            .controls-sidebar .mapper-controls {
                flex: 1;
                min-width: 280px;
            }

            #branchMap {
                height: 450px;
            }
        }

        /* Mobile layout */
        @media (max-width: 767px) {
            .container {
                padding: 10px !important;
                gap: 10px !important;
            }

            #branchMap {
                height: 350px;
            }

            .mapper-controls {
                padding: 10px !important;
            }

            .control-group label {
                font-size: 0.8rem;
            }

            .control-group select {
                font-size: 0.9rem;
                padding: 8px;
            }

            .map-actions button {
                padding: 10px 12px;
                font-size: 0.85rem;
            }
        }

        /* Hide any right sidebar completely */
        .sidebar:not(.controls-sidebar) {
            display: none !important;
        }
        
        .mapper-controls {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            padding: 12px;
            margin-bottom: 12px;
        }
        
        /* Left sidebar controls - single column layout */
        .sidebar-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        /* Remove the old 3-column grid */
        .controls-grid {
            display: none;
        }
        
        .map-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }
        
        .map-actions button {
            width: 100%;
            padding: 8px 14px;
            background: var(--ncrc-primary-blue);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: background 0.2s;
        }
        
        .map-actions button:hover {
            background: var(--ncrc-dark-blue);
        }
        
        .map-actions button.secondary {
            background: #6c757d;
        }
        
        .map-actions button.secondary:hover {
            background: #5a6268;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group label {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--ncrc-dark-blue);
        }
        
        .control-group select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.85rem;
            background: white;
        }
        
        .control-group select[multiple] {
            min-height: 150px;
            max-height: 200px;
            padding: 6px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 0.85rem;
        }
        
        .control-group select[multiple]:focus {
            border-color: var(--ncrc-primary-blue);
            outline: none;
            box-shadow: 0 0 0 3px rgba(3, 78, 160, 0.1);
        }
        
        .bank-select-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .bank-select-help {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .selected-banks-display {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .selected-bank-tag {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            background: var(--ncrc-light-blue);
            color: var(--ncrc-dark-blue);
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        .selected-bank-tag .remove-btn {
            cursor: pointer;
            color: var(--ncrc-dark-blue);
            font-weight: bold;
            padding: 0 2px;
        }
        
        .selected-bank-tag .remove-btn:hover {
            color: #e82e2e;
        }

        /* Bank chip styles */
        .bank-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
            color: white;
        }

        .bank-chip .chip-remove {
            cursor: pointer;
            font-weight: bold;
            padding: 0 2px;
            opacity: 0.8;
        }

        .bank-chip .chip-remove:hover {
            opacity: 1;
        }

        /* Hide mapbox-gl-draw default toolbar (we use our own sidebar buttons) */
        .mapboxgl-ctrl-group.mapbox-gl-draw_ctrl-draw-btn {
            display: none !important;
        }
        .mapbox-gl-draw_ctrl-draw-btn {
            display: none !important;
        }

        /* Show All Banks button active state */
        #showAllBanksBtn.active {
            background: var(--ncrc-primary-blue) !important;
            cursor: pointer !important;
            opacity: 1 !important;
        }

        #showAllBanksBtn:not(:disabled):hover {
            background: var(--ncrc-dark-blue) !important;
        }

        /* Search results dropdown items */
        .bank-search-item {
            padding: 6px 10px;
            cursor: pointer;
            font-size: 0.85rem;
            border-bottom: 1px solid #f0f0f0;
        }

        .bank-search-item:hover {
            background: #e6f2ff;
        }

        .bank-search-item:last-child {
            border-bottom: none;
        }

        .control-group small {
            font-size: 0.7rem;
            color: #666;
            margin-top: 2px;
        }
        
        
        .map-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            padding: 12px;
            margin-bottom: 12px;
        }
        
        #branchMap {
            height: 600px;
            width: 100%;
            border: 2px solid #ddd;
            border-radius: 6px;
        }
        
        
        .info-panel {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 8px 12px;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #666;
        }
        
        .info-panel strong {
            color: var(--ncrc-dark-blue);
        }
        
        /* Custom marker popup styles */
        .mapboxgl-popup-content {
            min-width: 200px;
            padding: 12px;
            border-radius: 8px;
        }
        .mapboxgl-popup-close-button {
            font-size: 18px;
            padding: 4px 8px;
        }
        
        .popup-content {
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .popup-content .bank-name-header {
            color: #000;
            font-size: 1.15rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .popup-content .branch-info {
            margin: 5px 0;
        }

        .popup-content .branch-info strong {
            color: var(--ncrc-primary-blue);
        }
        
        .popup-content .branch-tags {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }
        
        .tag {
            display: inline-block;
            padding: 3px 8px;
            background: #e6f2ff;
            color: var(--ncrc-primary-blue);
            border-radius: 4px;
            font-size: 0.8rem;
            margin-right: 5px;
            margin-top: 5px;
        }
        
        .tag.lmi {
            background: #fff3cd;
            color: #856404;
        }
        
        .tag.minority {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .report-problem-btn {
            margin-top: 12px;
            padding: 8px 16px;
            background: #e82e2e;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            text-align: center;
            transition: background 0.2s;
            text-decoration: none;
            display: inline-block;
        }
        
        .report-problem-btn:hover {
            background: #c41e1e;
            color: white;
            text-decoration: none;
        }
        
        .report-problem-btn i {
            margin-right: 6px;
        }
        
        /* Explicitly hide any version text in footer */
        .footer .version-text,
        .footer-bottom .version-text,
        footer .version-text {
            display: none !important;
            visibility: hidden !important;
        }

        /* View Mode Toggle */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            border: 2px solid var(--ncrc-primary-blue);
            border-radius: 6px;
            overflow: hidden;
        }

        .mode-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            background: white;
            color: var(--ncrc-dark-blue);
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .mode-btn.active {
            background: var(--ncrc-primary-blue);
            color: white;
        }

        .mode-btn:hover:not(.active) {
            background: #e6f2ff;
        }

        .oscr-event-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .oscr-event-tag.opening {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .oscr-event-tag.closing {
            background: #ffebee;
            color: #c62828;
        }

        /* Census Tract Toggle (3-button group) */
        .tract-overlay-toggle {
            display: flex;
            gap: 0;
            border: 2px solid #ddd;
            border-radius: 6px;
            overflow: hidden;
        }

        .tract-btn {
            flex: 1;
            padding: 6px 8px;
            border: none;
            background: white;
            color: #666;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .tract-btn.active {
            background: var(--ncrc-primary-blue);
            color: white;
        }

        .tract-btn:hover:not(.active) {
            background: #e6f2ff;
        }

        /* County boundary layer styling */
        .county-boundary-label {
            font-size: 11px;
            font-weight: 600;
            color: #333;
        }

        /* Mobile responsive: Tablet (768-1024px) */
        @media (min-width: 768px) and (max-width: 1024px) {
            .container {
                flex-direction: column !important;
            }
            .controls-sidebar {
                width: 100% !important;
                max-width: 100% !important;
                min-width: 0 !important;
                position: relative !important;
                top: auto !important;
            }
            .sidebar-controls {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            .sidebar-controls .map-actions,
            .sidebar-controls #column2Legend {
                grid-column: 1 / -1;
            }
        }

        /* Mobile (<768px) */
        @media (max-width: 767px) {
            #branchMap {
                height: 60vh;
            }
            .controls-sidebar {
                position: relative !important;
                top: auto !important;
            }
            .mapper-controls {
                padding: 10px !important;
            }
        }

        /* Small mobile (<480px) */
        @media (max-width: 480px) {
            #branchMap {
                height: 50vh;
            }
            .control-group label {
                font-size: 0.78rem;
            }
            .control-group select,
            .control-group input[type="text"] {
                font-size: 0.82rem;
                padding: 5px 8px;
            }
            .map-actions button {
                padding: 8px 10px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    {% set app_name = "BranchMapper" %}{% set app_logo = url_for('static', filename='img/branchmapper-logo.png') %}{% include "shared_header.html" %}

    <div class="container">
        <!-- Left Controls Sidebar -->
        <aside class="controls-sidebar">
            <div class="mapper-controls">
                <h3 style="margin-bottom: 12px; color: var(--ncrc-dark-blue); font-size: 1rem; border-bottom: 2px solid var(--ncrc-primary-blue); padding-bottom: 8px;">
                    <i class="fas fa-map-marked-alt"></i> Map Controls
                </h3>

                <div class="sidebar-controls">
                    <!-- View Mode Toggle -->
                    <div class="control-group">
                        <label><i class="fas fa-exchange-alt"></i> View Mode</label>
                        <div class="view-mode-toggle">
                            <button id="btnSODMode" class="mode-btn active" onclick="setViewMode('sod')">
                                <i class="fas fa-building"></i> Branch Network
                            </button>
                            <button id="btnOSCRMode" class="mode-btn" onclick="setViewMode('oscr')">
                                <i class="fas fa-exchange-alt"></i> Recent Changes
                            </button>
                        </div>
                    </div>

                    <!-- Bank Search -->
                    <div class="control-group">
                        <label for="bankSearchInput">
                            <i class="fas fa-university"></i> Search Banks
                        </label>
                        <div style="position: relative;">
                            <input type="text" id="bankSearchInput" placeholder="Type bank name..."
                                   autocomplete="off"
                                   style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85rem; width: 100%; box-sizing: border-box;">
                            <div id="bankSearchResults" style="display: none; position: absolute; top: 100%; left: 0; right: 0;
                                background: white; border: 1px solid #ddd; border-top: none; border-radius: 0 0 6px 6px;
                                max-height: 200px; overflow-y: auto; z-index: 100; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                            </div>
                        </div>
                        <div id="bankChipsContainer" style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px;">
                        </div>
                        <small style="color: #888;">Select up to 3 banks to compare</small>
                    </div>

                    <!-- Show All Banks Button -->
                    <button id="showAllBanksBtn" onclick="toggleShowAllBanks()" disabled
                            style="width: 100%; padding: 8px 14px; background: #adb5bd; color: white; border: none;
                            border-radius: 6px; cursor: not-allowed; font-size: 0.85rem; font-weight: 600;
                            transition: background 0.15s, color 0.15s, box-shadow 0.3s, opacity 0.3s; opacity: 0.4;">
                        <i class="fas fa-eye"></i> Show All Banks in View
                    </button>

                    <!-- Divider -->
                    <hr style="border: none; border-top: 1px solid #ddd; margin: 4px 0;">

                    <!-- OSCR-specific controls -->
                    <div id="oscrControls" style="display: none;">
                        <div class="control-group">
                            <label for="dateRangeSelect">
                                <i class="fas fa-calendar-alt"></i> Date Range
                            </label>
                            <select id="dateRangeSelect">
                                <option value="since_sod">Since Last SOD (June 30, 2025)</option>
                                <option value="12months">Last 12 Months</option>
                                <option value="3years" selected>Last 3 Years</option>
                                <option value="custom">Custom Range</option>
                            </select>
                        </div>

                        <!-- Custom date range (hidden by default) -->
                        <div id="customDateRange" style="display: none;">
                            <div class="control-group">
                                <label for="startDate">Start Date</label>
                                <input type="date" id="startDate" value="2023-02-01"
                                       style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85rem;">
                            </div>
                            <div class="control-group">
                                <label for="endDate">End Date</label>
                                <input type="date" id="endDate"
                                       style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85rem;">
                            </div>
                        </div>

                        <!-- Event Type Filter -->
                        <div class="control-group">
                            <label><i class="fas fa-filter"></i> Event Types</label>
                            <div style="display: flex; flex-direction: column; gap: 4px; padding: 4px 0;">
                                <label style="font-weight: normal; font-size: 0.85rem; display: flex; align-items: center; gap: 6px;">
                                    <input type="checkbox" id="filterOpenings" checked>
                                    <span style="color: #2e7d32;">&#9679;</span> Openings
                                </label>
                                <label style="font-weight: normal; font-size: 0.85rem; display: flex; align-items: center; gap: 6px;">
                                    <input type="checkbox" id="filterClosings" checked>
                                    <span style="color: #c62828;">&#10005;</span> Closings
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Census Tract Toggle (shown at zoom >= 9 in SOD mode) -->
                    <div id="censusToggleGroup" class="control-group">
                        <label><i class="fas fa-layer-group"></i> Census Overlay</label>
                        <div class="tract-overlay-toggle">
                            <button class="tract-btn active" data-census="off" onclick="setCensusOverlay('off')">Off</button>
                            <button class="tract-btn" data-census="income" onclick="setCensusOverlay('income')">Income</button>
                            <button class="tract-btn" data-census="minority" onclick="setCensusOverlay('minority')">Minority</button>
                        </div>
                    </div>

                    <!-- Draw Area -->
                    <div class="control-group">
                        <label><i class="fas fa-draw-polygon"></i> Draw Area</label>
                        <div id="drawControls">
                            <button id="drawStartBtn" onclick="startDrawing()" style="width: 100%; padding: 8px; background: var(--ncrc-primary-blue); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 600;">
                                <i class="fas fa-pencil-alt"></i> Draw Boundary
                            </button>
                            <div id="drawActiveControls" style="display: none;">
                                <p style="font-size: 0.75rem; color: #666; margin: 6px 0;">Click on the map to draw a polygon. Double-click to finish.</p>
                                <button onclick="cancelDrawing()" style="width: 100%; padding: 6px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                    <i class="fas fa-times"></i> Cancel
                                </button>
                            </div>
                            <div id="drawResultControls" style="display: none; margin-top: 6px;">
                                <div id="drawAreaSummary" style="font-size: 0.8rem; color: #333; padding: 6px 8px; background: #e8f4fd; border-radius: 4px; margin-bottom: 6px;"></div>
                                <div style="display: flex; gap: 6px;">
                                    <button onclick="saveDrawnArea()" style="flex: 1; padding: 6px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                        <i class="fas fa-save"></i> Save
                                    </button>
                                    <button onclick="clearDrawnArea()" style="flex: 1; padding: 6px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                        <i class="fas fa-trash"></i> Clear
                                    </button>
                                </div>
                            </div>
                            <div id="savedAreasContainer" style="margin-top: 6px;"></div>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="map-actions">
                        <div style="display: flex; gap: 8px;">
                            <button onclick="resetMap()" class="secondary" style="flex: 1;">
                                <i class="fas fa-undo"></i> Reset
                            </button>
                            <button onclick="exportMapAndData()" class="secondary" style="flex: 1;">
                                <i class="fas fa-download"></i> Export
                            </button>
                        </div>
                    </div>

                    <!-- Dynamic Legend (keep existing income/minority legends) -->
                    <div id="column2Legend" style="padding: 10px; background: #f9f9f9; border-radius: 6px; border: 1px solid #ddd; margin-top: 8px; display: none;">
                        <!-- Income Levels Legend -->
                        <div id="column2IncomeLegend" style="display: none;">
                            <strong style="font-size: 0.85rem; color: var(--ncrc-dark-blue);">Income Levels:</strong>
                            <div style="display: flex; flex-direction: column; gap: 6px; margin-top: 6px; font-size: 0.75rem; color: #666;">
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #333333; border: 1px solid #333;"></span>
                                    <span>Low (&le;50%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #666666; border: 1px solid #333;"></span>
                                    <span>Moderate (&le;80%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #999999; border: 1px solid #333;"></span>
                                    <span>Middle (&le;120%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #cccccc; border: 1px solid #333;"></span>
                                    <span>Upper (&gt;120%)</span>
                                </div>
                            </div>
                        </div>
                        <!-- Minority Population Legend -->
                        <div id="column2MinorityLegend" style="display: none;">
                            <strong style="font-size: 0.85rem; color: var(--ncrc-dark-blue);">Minority Population:</strong>
                            <div style="display: flex; flex-direction: column; gap: 6px; margin-top: 6px; font-size: 0.75rem; color: #666;">
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #1a1a1a; border: 1px solid #333;"></span>
                                    <span>Q4 (Highest 25%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #666666; border: 1px solid #333;"></span>
                                    <span>Q3 (50-75%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #999999; border: 1px solid #333;"></span>
                                    <span>Q2 (25-50%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #cccccc; border: 1px solid #333;"></span>
                                    <span>Q1 (Lowest 25%)</span>
                                </div>
                            </div>
                            <div style="margin-top: 4px; font-style: italic; color: #999; font-size: 0.7rem;">
                                Minority = All non-Hispanic White excluded<br>
                                Categories based on quartiles of minority % within county
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </aside>
        
        <!-- Main Content -->
        <div class="content-wrapper">
    <div class="mapper-container">
        <!-- Map Controls Header (simplified) -->
        <div class="mapper-controls" style="margin-bottom: 12px;">
            <h2 style="margin-bottom: 10px; color: var(--ncrc-dark-blue); font-size: 1.1rem;">
                <i class="fas fa-map-marked-alt"></i> Branch Location Map
            </h2>
            
            <!-- Dynamic Context Bar -->
            <div id="mapContextBar" class="data-description" style="background: #e6f2ff; padding: 6px 10px; border-radius: 4px; margin-bottom: 10px; border-left: 3px solid var(--ncrc-primary-blue);">
                <p style="margin: 0; color: #333; line-height: 1.4; font-size: 0.8rem;">
                    <i class="fas fa-info-circle"></i>
                    <strong>About:</strong> Data from <strong>Summary of Deposits</strong> (June 30, 2025). Use the left sidebar to select state/county and load the map.
                </p>
            </div>
        </div>
        
        <!-- Map Container -->
        <div class="map-container" style="position: relative;">
            <!-- Onboarding Overlay -->
            <div id="branchMap"></div>
        </div>
        
        <!-- Info Panel -->
        <div class="info-panel" id="infoPanel">
            <strong>Instructions:</strong><br>
            • Select a state and county to view 2025 bank branch locations<br>
            • Use the bank selector to filter by specific banks (select up to 3)<br>
            • Click on markers to see branch details<br>
            • Use the "Get Support" button in popups for help via Slack
        </div>
        </div>
        </div>
        
        <!-- Right Info Sidebar -->
    </div>
    
    <!-- Mapbox GL JS -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
    <!-- Mapbox GL Draw -->
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.js"></script>
    <!-- Turf.js for point-in-polygon -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    
    <script>
        // Base URL for API calls (handles blueprint prefix)
        const APP_BASE_URL = '{{ app_base_url|default("/branchmapper") }}';

        // Mapbox configuration
        const MAPBOX_TOKEN = '{{ mapbox_token|default("pk.eyJ1IjoiamVkbGViaSIsImEiOiJjanhhc3M4NnYwMmxsM3lyODlxYTFhOGRxIn0.746AmyW45uwRPeUy1PczOg", true) }}';
        const MAPBOX_STYLE = '{{ mapbox_style|default("mapbox://styles/jedlebi/cltg2vre600wz01p02c3jf3h3", true) }}';

        let branchMap = null;
        let currentPopup = null;
        let incomeLayerVisible = false;
        let minorityLayerVisible = false;
        let incomeLayerAbortController = null;
        let minorityLayerAbortController = null;
        let relocationLines = [];
        let countyBoundaryIds = [];
        let cachedUserType = null;

        // Legacy compat
        let oscrMarkers = [];

        // Phase 2 state
        let selectedBanks = [];          // [{name, color, branches, oscrEvents, _layerIds}]
        let showAllBanksActive = false;
        let allBanksInView = [];
        let loadedBounds = null;         // {sw:{lat,lng}, ne:{lat,lng}}
        let currentViewMode = 'sod';
        let currentZoom = 4;
        let allBankNames = [];
        let viewportCounties = [];

        const BANK_COLORS = ['#1a8fc9', '#e67e22', '#8e44ad'];
        const METRO_ZOOM_THRESHOLD = 6;
        const CENSUS_TILESET_ID = 'editengine.census-tracts';
        const CENSUS_SOURCE_LAYER = 'census_tracts';

        // Draw area state
        let drawControl = null;
        let isDrawing = false;
        let drawnPolygon = null;       // Current active polygon GeoJSON
        let activeDrawFilter = null;   // Turf polygon used to filter all markers
        let savedAreas = [];           // [{name, polygon, color}]
        let savedAreaCounter = 0;
        const DRAW_COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'];

        // Fetch user type and open appropriate Slack support channel
        async function openSlackSupport(event) {
            event.preventDefault();

            // Fetch user type if not cached
            if (!cachedUserType) {
                try {
                    const response = await fetch('/api/auth/status');
                    if (response.ok) {
                        const data = await response.json();
                        cachedUserType = data.user_type || 'public_anonymous';
                    } else {
                        cachedUserType = 'public_anonymous';
                    }
                } catch (error) {
                    console.log('Could not fetch user type, defaulting to public');
                    cachedUserType = 'public_anonymous';
                }
            }

            const isInternalUser = ['staff', 'senior_executive', 'admin'].includes(cachedUserType);

            // Staff channel for internal users, public support channel for everyone else
            const slackChannelUrl = isInternalUser
                ? 'https://ncrcgroup.slack.com/app_redirect?channel=C0A0BBWRT36'  // justdata_staff
                : 'https://ncrcgroup.slack.com/app_redirect?channel=C0AAHCK98A0'; // public support

            window.open(slackChannelUrl, '_blank');
        }

        // State center coordinates and zoom levels (approximate)
        const stateCenters = {
            '01': { lat: 32.806671, lng: -86.791130, zoom: 7 }, // Alabama
            '04': { lat: 34.048928, lng: -111.093731, zoom: 7 }, // Arizona
            '06': { lat: 36.116203, lng: -119.681564, zoom: 6 }, // California
            '10': { lat: 39.318523, lng: -75.507141, zoom: 8 }, // Delaware
            '12': { lat: 27.766279, lng: -81.686783, zoom: 7 }, // Florida
            '13': { lat: 33.040619, lng: -83.643074, zoom: 7 }, // Georgia
            '17': { lat: 40.349457, lng: -88.986137, zoom: 7 }, // Illinois
            '24': { lat: 39.063946, lng: -76.802101, zoom: 7 }, // Maryland
            '26': { lat: 43.326618, lng: -84.536095, zoom: 7 }, // Michigan
            '36': { lat: 42.165726, lng: -74.948051, zoom: 7 }, // New York
            '39': { lat: 40.388783, lng: -82.764915, zoom: 7 }, // Ohio
            '42': { lat: 40.590752, lng: -77.209755, zoom: 7 }, // Pennsylvania
            '48': { lat: 31.054487, lng: -97.563461, zoom: 6 }, // Texas
            '53': { lat: 47.400902, lng: -121.490494, zoom: 7 }  // Washington
        };
        
        // ===== Phase 2: View Mode & Bank Search =====

        // Unified popup builder for all marker types
        function buildPopupHTML(data) {
            // data: { bank_name, branch_name, branch_type, address, city, state, zip,
            //         lmi, minority, deposits, lat, lng, change_type, effective_date }
            const lines = [];

            // Bank name header
            lines.push(`<div class="bank-name-header" style="font-weight: 700; font-size: 1rem; margin-bottom: 6px;">${data.bank_name || 'Unknown'}</div>`);

            // Change type badge (if OSCR event)
            if (data.change_type) {
                const isOpen = data.change_type === 'opening';
                const color = isOpen ? '#2e7d32' : '#c62828';
                const label = isOpen ? 'Opening' : 'Closing';
                lines.push(`<div style="display: inline-block; background: ${color}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-bottom: 6px;">${label}</div>`);
            }

            lines.push('<div class="branch-info" style="font-size: 0.85rem; line-height: 1.5;">');

            if (data.branch_name) lines.push(`<strong>Branch:</strong> ${data.branch_name}<br>`);
            if (data.branch_type) lines.push(`<strong>Type:</strong> ${data.branch_type}<br>`);

            // Address
            const addr = data.address || '';
            const cityStateZip = [data.city, data.state].filter(Boolean).join(', ') + (data.zip ? ' ' + data.zip : '');
            if (addr || cityStateZip) {
                lines.push(`<strong>Address:</strong> ${addr}<br>${cityStateZip}<br>`);
            }

            // Deposits
            if (data.deposits) {
                lines.push(`<strong>Deposits:</strong> $${Number(data.deposits).toLocaleString('en-US')}<br>`);
            }

            // Date (OSCR events) — normalize to YYYY-MM-DD
            if (data.effective_date) {
                let dateStr = data.effective_date;
                // If it contains 'T', strip time portion
                if (dateStr.includes('T')) dateStr = dateStr.split('T')[0];
                // If MM/DD/YYYY format, convert to YYYY-MM-DD
                const mdyMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                if (mdyMatch) dateStr = `${mdyMatch[3]}-${mdyMatch[1].padStart(2,'0')}-${mdyMatch[2].padStart(2,'0')}`;
                lines.push(`<strong>Date:</strong> ${dateStr}<br>`);
            }

            // Tract tags
            const tags = [];
            if (data.lmi) tags.push('<span style="background: #e65100; color: white; padding: 1px 6px; border-radius: 3px; font-size: 0.7rem; font-weight: 600;">LMI</span>');
            if (data.minority) tags.push('<span style="background: #4a148c; color: white; padding: 1px 6px; border-radius: 3px; font-size: 0.7rem; font-weight: 600;">Majority-Minority</span>');
            if (tags.length > 0) lines.push(`<div style="margin-top: 4px;">${tags.join(' ')}</div>`);

            // Google Maps link
            if (data.lat && data.lng) {
                const q = encodeURIComponent(`${addr}, ${cityStateZip}`.trim().replace(/^,\s*/, ''));
                lines.push(`<a href="https://www.google.com/maps/search/?api=1&query=${data.lat},${data.lng}" target="_blank" rel="noopener" style="display: inline-block; margin-top: 6px; color: #1a73e8; font-size: 0.8rem; text-decoration: none;"><i class="fas fa-map-marker-alt"></i> View on Google Maps</a>`);
            }

            lines.push('</div>');
            return `<div class="popup-content">${lines.join('')}</div>`;
        }

        // Helper: get simplified branch type from service_type code
        function getSimplifiedBranchType(serviceType) {
            if (!serviceType) return null;
            const st = String(serviceType).trim();
            if (['11', '12'].includes(st) || /^full service/i.test(st)) return 'Full Service';
            if (st === '13' || /cyber/i.test(st)) return 'Cyber Office';
            if (['21', '22', '23', '24', '25', '26', '27', '28', '29', '30'].includes(st) || /^limited service/i.test(st)) return 'Limited Service';
            if (/loan production/i.test(st)) return 'Loan Production';
            if (/atm/i.test(st)) return 'ATM';
            if (/mobile/i.test(st)) return 'Mobile';
            return st;
        }

        function showOnboardingOverlay() {
            const modal = document.getElementById('welcomeModal');
            if (modal) modal.style.display = 'flex';
        }

        function hideOnboardingOverlay() {
            const modal = document.getElementById('welcomeModal');
            if (modal) modal.style.display = 'none';
        }

        // ===== Bank Search =====
        async function initializeBankSearch() {
            try {
                const response = await fetch(`${APP_BASE_URL}/api/bank-list`);
                if (response.ok) {
                    const data = await response.json();
                    allBankNames = data.banks || [];
                    console.log('Loaded', allBankNames.length, 'bank names');
                    const input = document.getElementById('bankSearchInput');
                    if (allBankNames.length > 0) {
                        input.placeholder = `Search ${allBankNames.length} banks...`;
                    } else {
                        input.placeholder = 'Bank list unavailable';
                    }
                }
            } catch (err) {
                console.error('Failed to load bank list:', err);
            }

            const input = document.getElementById('bankSearchInput');
            let debounceTimer = null;

            input.addEventListener('input', function() {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    const query = this.value.trim();
                    if (query.length < 2) {
                        hideSearchResults();
                        return;
                    }
                    showSearchResults(query);
                }, 150);
            });

            input.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') hideSearchResults();
            });

            // Close search results on click outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('#bankSearchInput') && !e.target.closest('#bankSearchResults')) {
                    hideSearchResults();
                }
            });
        }

        function showSearchResults(query) {
            const container = document.getElementById('bankSearchResults');
            const lowerQuery = query.toLowerCase();
            const alreadySelected = selectedBanks.map(b => b.name);
            const filtered = allBankNames
                .filter(name => name.toLowerCase().includes(lowerQuery) && !alreadySelected.includes(name))
                .slice(0, 20);

            if (filtered.length === 0) {
                container.innerHTML = '<div class="bank-search-item" style="color: #999;">No matches found</div>';
            } else {
                container.innerHTML = filtered.map(name =>
                    `<div class="bank-search-item" onclick="addBank('${name.replace(/'/g, "\\'")}')">${name}</div>`
                ).join('');
            }
            container.style.display = 'block';
        }

        function hideSearchResults() {
            document.getElementById('bankSearchResults').style.display = 'none';
        }

        async function addBank(bankName) {
            if (selectedBanks.length >= 3) {
                updateInfoPanel('Maximum 3 banks can be compared at once.');
                return;
            }
            if (selectedBanks.find(b => b.name === bankName)) return;

            hideSearchResults();
            document.getElementById('bankSearchInput').value = '';
            hideOnboardingOverlay();

            const isFirst = selectedBanks.length === 0;
            const color = BANK_COLORS[selectedBanks.length];

            const bank = {
                name: bankName,
                color: color,
                branches: [],
                oscrEvents: [],
                _layerIds: []
            };
            selectedBanks.push(bank);

            renderBankChips();
            updateContextBar();
            updateShowAllButton();

            // Load data
            if (currentViewMode === 'sod') {
                await loadBankBranches(bank);
                renderBankSODMarkers(bank);
            } else {
                await loadBankOSCREvents(bank);
                renderBankOSCRMarkers(bank);
            }

            const count = currentViewMode === 'sod' ? bank.branches.length : bank.oscrEvents.length;
            updateInfoPanel(`${bankName}: ${count} branches nationwide`);
        }

        function removeBank(bankName) {
            const idx = selectedBanks.findIndex(b => b.name === bankName);
            if (idx === -1) return;

            const bank = selectedBanks[idx];

            // Remove this bank's layers
            bank._layerIds.forEach(id => {
                if (branchMap.getLayer(id)) branchMap.removeLayer(id);
                if (branchMap.getSource(id)) branchMap.removeSource(id);
            });

            // Remove OSCR markers if any
            if (bank._oscrMarkers) {
                bank._oscrMarkers.forEach(m => m.remove());
            }

            selectedBanks.splice(idx, 1);

            // Reassign colors
            selectedBanks.forEach((b, i) => {
                const oldLayerIds = [...b._layerIds];
                oldLayerIds.forEach(id => {
                    if (branchMap.getLayer(id)) branchMap.removeLayer(id);
                    if (branchMap.getSource(id)) branchMap.removeSource(id);
                });
                if (b._oscrMarkers) b._oscrMarkers.forEach(m => m.remove());
                b.color = BANK_COLORS[i];
                b._layerIds = [];
                b._oscrMarkers = [];
            });

            // Re-render all
            renderAllSelectedBankMarkers();
            renderBankChips();
            updateContextBar();
            updateShowAllButton();

            if (selectedBanks.length === 0) {
                showOnboardingOverlay();
            }
        }

        function renderBankChips() {
            const container = document.getElementById('bankChipsContainer');
            container.innerHTML = selectedBanks.map(bank => {
                const count = currentViewMode === 'sod' ? bank.branches.length : bank.oscrEvents.length;
                return `<span class="bank-chip" style="background: ${bank.color};">
                    ${bank.name} (${count})
                    <span class="chip-remove" onclick="removeBank('${bank.name.replace(/'/g, "\\'")}')">&times;</span>
                </span>`;
            }).join('');
        }

        async function loadBankBranches(bank) {
            try {
                const response = await fetch(
                    `${APP_BASE_URL}/api/branches-by-bank?bank_name=${encodeURIComponent(bank.name)}&year=2025`
                );
                const data = await response.json();
                if (data.success) {
                    bank.branches = data.branches || [];
                }
            } catch (err) {
                console.error(`Error loading branches for ${bank.name}:`, err);
            }
        }

        async function loadBankOSCREvents(bank) {
            try {
                const dateRange = getOSCRDateRange();
                const response = await fetch(
                    `${APP_BASE_URL}/api/oscr-events-by-bank?bank_name=${encodeURIComponent(bank.name)}` +
                    `&start_date=${dateRange.start}&end_date=${dateRange.end}`
                );
                const data = await response.json();
                if (data.success) {
                    bank.oscrEvents = data.events || [];
                }
            } catch (err) {
                console.error(`Error loading OSCR events for ${bank.name}:`, err);
            }
        }

        function renderBankSODMarkers(bank) {
            const sourceId = `bank-${bank.name.replace(/\W/g, '_')}`;
            const features = [];

            // Store branch data for popups
            if (!window.branchDataMap) window.branchDataMap = {};

            bank.branches.forEach(branch => {
                let lat = branch.latitude, lng = branch.longitude;
                if (typeof lat === 'string') lat = parseFloat(lat);
                if (typeof lng === 'string') lng = parseFloat(lng);
                if (isNaN(lat) || isNaN(lng) || lat === 0 || lng === 0) return;

                // Apply draw filter if active
                if (activeDrawFilter && !turf.booleanPointInPolygon(turf.point([lng, lat]), activeDrawFilter)) return;

                const branchId = `${branch.uninumbr || ''}_${lat}_${lng}`;
                window.branchDataMap[branchId] = branch;

                features.push({
                    type: 'Feature',
                    properties: {
                        id: branchId,
                        bank_name: branch.bank_name || bank.name,
                        branch_name: branch.branch_name || 'Branch',
                        color: bank.color
                    },
                    geometry: { type: 'Point', coordinates: [lng, lat] }
                });
            });

            if (features.length === 0) return;

            if (branchMap.getSource(sourceId)) {
                branchMap.getSource(sourceId).setData({ type: 'FeatureCollection', features });
            } else {
                branchMap.addSource(sourceId, {
                    type: 'geojson',
                    data: { type: 'FeatureCollection', features }
                });
            }

            const layerId = sourceId + '-fill';
            if (!branchMap.getLayer(layerId)) {
                branchMap.addLayer({
                    id: layerId,
                    type: 'circle',
                    source: sourceId,
                    paint: {
                        'circle-radius': 6,
                        'circle-color': bank.color,
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#ffffff'
                    }
                });

                // Click handler
                branchMap.on('click', layerId, function(e) {
                    if (!e.features || e.features.length === 0) return;
                    const feature = e.features[0];
                    const coords = feature.geometry.coordinates.slice();
                    const props = feature.properties;
                    const branch = window.branchDataMap[props.id] || {};
                    const html = buildPopupHTML({
                        bank_name: props.bank_name,
                        branch_name: props.branch_name,
                        branch_type: getSimplifiedBranchType(branch.service_type) || branch.branch_type,
                        address: branch.address,
                        city: branch.city,
                        state: branch.state_abbrv || branch.state,
                        zip: branch.zip,
                        lmi: branch.lmict,
                        minority: branch.mmct,
                        deposits: branch.total_deposits,
                        lat: coords[1],
                        lng: coords[0]
                    });
                    if (currentPopup) currentPopup.remove();
                    currentPopup = new mapboxgl.Popup({ maxWidth: '300px' }).setLngLat(coords).setHTML(html).addTo(branchMap);
                });

                branchMap.on('mouseenter', layerId, () => branchMap.getCanvas().style.cursor = 'pointer');
                branchMap.on('mouseleave', layerId, () => branchMap.getCanvas().style.cursor = '');
            }

            bank._layerIds = [sourceId, layerId];
        }

        function renderBankOSCRMarkers(bank) {
            // Use individual DOM markers for OSCR events (existing pattern)
            if (!bank._oscrMarkers) bank._oscrMarkers = [];
            bank._oscrMarkers.forEach(m => m.remove());
            bank._oscrMarkers = [];

            const showOpenings = document.getElementById('filterOpenings').checked;
            const showClosings = document.getElementById('filterClosings').checked;

            const filtered = bank.oscrEvents.filter(e => {
                if (e.display_type === 'opening' && !showOpenings) return false;
                if (e.display_type === 'closing' && !showClosings) return false;
                return true;
            });

            let validEvents = filtered.filter(e => e.latitude && e.longitude);

            // Apply draw filter if active
            if (activeDrawFilter) {
                validEvents = validEvents.filter(e => {
                    const lat = parseFloat(e.latitude), lng = parseFloat(e.longitude);
                    return !isNaN(lat) && !isNaN(lng) && turf.booleanPointInPolygon(turf.point([lng, lat]), activeDrawFilter);
                });
            }

            validEvents.forEach(event => {
                const el = document.createElement('div');
                if (event.display_type === 'opening') {
                    el.style.cssText = `width: 18px; height: 18px; background-color: #2e7d32; border: 2px solid ${bank.color}; border-radius: 50%; cursor: pointer;`;
                } else {
                    el.style.cssText = `width: 18px; height: 18px; background-color: #c62828; border: 2px solid ${bank.color}; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px;`;
                    el.textContent = '\u2715';
                }

                const marker = new mapboxgl.Marker({ element: el })
                    .setLngLat([event.longitude, event.latitude])
                    .addTo(branchMap);

                // Add click popup
                el.addEventListener('click', function(e) {
                    e.stopPropagation();
                    if (currentPopup) currentPopup.remove();
                    const html = buildPopupHTML({
                        bank_name: event.institution || bank.name,
                        branch_name: event.branch_name,
                        branch_type: getSimplifiedBranchType(event.service_type),
                        address: event.address,
                        city: event.city,
                        state: event.state,
                        zip: event.zip,
                        deposits: null,
                        lmi: false,
                        minority: false,
                        lat: event.latitude,
                        lng: event.longitude,
                        change_type: event.display_type,
                        effective_date: event.effective_date || event.processed_date
                    });
                    currentPopup = new mapboxgl.Popup({ maxWidth: '300px' })
                        .setLngLat([event.longitude, event.latitude])
                        .setHTML(html)
                        .addTo(branchMap);
                });

                bank._oscrMarkers.push(marker);
            });
        }

        function renderAllSelectedBankMarkers() {
            selectedBanks.forEach(bank => {
                if (currentViewMode === 'sod') {
                    renderBankSODMarkers(bank);
                } else {
                    renderBankOSCRMarkers(bank);
                }
            });
        }

        function reRenderAllMarkers() {
            renderAllSelectedBankMarkers();
            if (showAllBanksActive) {
                if (currentViewMode === 'sod') {
                    renderAllBanksInView();
                } else {
                    renderAllBanksInViewOSCR();
                }
            }
        }

        // ===== Show All Banks =====
        function updateShowAllButton() {
            const btn = document.getElementById('showAllBanksBtn');
            if (currentZoom >= METRO_ZOOM_THRESHOLD) {
                btn.disabled = false;
                btn.style.cursor = 'pointer';
                btn.style.opacity = '1';
                if (showAllBanksActive) {
                    btn.style.background = 'var(--ncrc-primary-blue)';
                    btn.style.boxShadow = '0 0 8px rgba(26, 143, 201, 0.5)';
                } else {
                    // Bright purple when enabled but not active
                    btn.style.background = '#8e44ad';
                    btn.style.boxShadow = '0 0 6px rgba(142, 68, 173, 0.4)';
                }
            } else {
                btn.disabled = true;
                btn.style.cursor = 'not-allowed';
                btn.style.opacity = '0.4';
                btn.style.background = '#adb5bd';
                btn.style.boxShadow = 'none';
            }
        }

        function toggleShowAllBanks() {
            if (currentZoom < METRO_ZOOM_THRESHOLD) return;
            // Flash effect on click
            const btn = document.getElementById('showAllBanksBtn');
            btn.style.background = '#ffffff';
            btn.style.color = '#8e44ad';
            setTimeout(() => {
                btn.style.color = 'white';
                if (showAllBanksActive) {
                    deactivateShowAll();
                } else {
                    activateShowAll();
                }
            }, 150);
        }

        async function activateShowAll() {
            showAllBanksActive = true;
            updateShowAllButton();
            await loadAllBanksInView();
        }

        function deactivateShowAll() {
            showAllBanksActive = false;
            loadedBounds = null;
            clearGrayMarkers();
            updateShowAllButton();
        }

        async function loadAllBanksInView() {
            if (!branchMap) return;
            const bounds = branchMap.getBounds();
            const sw = bounds.getSouthWest();
            const ne = bounds.getNorthEast();

            // Pad bounds by 10%
            const latPad = (ne.lat - sw.lat) * 0.1;
            const lngPad = (ne.lng - sw.lng) * 0.1;
            const padded = {
                sw: { lat: sw.lat - latPad, lng: sw.lng - lngPad },
                ne: { lat: ne.lat + latPad, lng: ne.lng + lngPad }
            };

            // Check if within loaded bounds
            if (loadedBounds && isWithinBounds(
                { sw: { lat: sw.lat, lng: sw.lng }, ne: { lat: ne.lat, lng: ne.lng } },
                loadedBounds
            )) {
                return; // Already loaded this area
            }

            updateInfoPanel('Loading all banks in view...');

            try {
                if (currentViewMode === 'sod') {
                    const response = await fetch(
                        `${APP_BASE_URL}/api/branches-in-bounds?sw_lat=${padded.sw.lat}&sw_lng=${padded.sw.lng}` +
                        `&ne_lat=${padded.ne.lat}&ne_lng=${padded.ne.lng}&year=2025`
                    );
                    const data = await response.json();
                    if (data.success) {
                        allBanksInView = data.branches || [];
                        renderAllBanksInView();
                        updateInfoPanel(`Showing ${allBanksInView.length} branches from all banks in view`);
                    }
                } else {
                    const dateRange = getOSCRDateRange();
                    const response = await fetch(
                        `${APP_BASE_URL}/api/oscr-events-in-bounds?sw_lat=${padded.sw.lat}&sw_lng=${padded.sw.lng}` +
                        `&ne_lat=${padded.ne.lat}&ne_lng=${padded.ne.lng}` +
                        `&start_date=${dateRange.start}&end_date=${dateRange.end}`
                    );
                    const data = await response.json();
                    if (data.success) {
                        allBanksInView = data.events || [];
                        renderAllBanksInViewOSCR();
                        updateInfoPanel(`Showing ${allBanksInView.length} events from all banks in view`);
                    }
                }
                loadedBounds = padded;
            } catch (err) {
                console.error('Error loading all banks in view:', err);
                updateInfoPanel(`Error: ${err.message}`);
            }
        }

        function renderAllBanksInView() {
            clearGrayMarkers();
            if (!window.branchDataMap) window.branchDataMap = {};

            const selectedNames = selectedBanks.map(b => b.name);
            const features = [];

            allBanksInView.forEach(branch => {
                // Skip branches from selected banks
                if (selectedNames.some(n => (branch.bank_name || '').includes(n))) return;

                let lat = branch.latitude, lng = branch.longitude;
                if (typeof lat === 'string') lat = parseFloat(lat);
                if (typeof lng === 'string') lng = parseFloat(lng);
                if (isNaN(lat) || isNaN(lng) || lat === 0 || lng === 0) return;

                // Apply draw filter if active
                if (activeDrawFilter && !turf.booleanPointInPolygon(turf.point([lng, lat]), activeDrawFilter)) return;

                const branchId = `gray_${branch.uninumbr || ''}_${lat}_${lng}`;
                window.branchDataMap[branchId] = branch;

                features.push({
                    type: 'Feature',
                    properties: {
                        id: branchId,
                        bank_name: branch.bank_name || 'Unknown',
                        branch_name: branch.branch_name || 'Branch'
                    },
                    geometry: { type: 'Point', coordinates: [lng, lat] }
                });
            });

            if (features.length === 0) return;

            const sourceId = 'gray-all-banks';
            if (branchMap.getSource(sourceId)) {
                branchMap.getSource(sourceId).setData({ type: 'FeatureCollection', features });
            } else {
                branchMap.addSource(sourceId, {
                    type: 'geojson',
                    data: { type: 'FeatureCollection', features }
                });

                branchMap.addLayer({
                    id: 'gray-all-banks-fill',
                    type: 'circle',
                    source: sourceId,
                    paint: {
                        'circle-radius': 4,
                        'circle-color': '#000000',
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#ffffff',
                        'circle-opacity': 1
                    }
                }, selectedBanks.length > 0 ? selectedBanks[0]._layerIds[1] : undefined);

                // Click handler for gray markers
                branchMap.on('click', 'gray-all-banks-fill', function(e) {
                    if (!e.features || e.features.length === 0) return;
                    const feature = e.features[0];
                    const coords = feature.geometry.coordinates.slice();
                    const props = feature.properties;
                    const branch = window.branchDataMap[props.id] || {};
                    const html = buildPopupHTML({
                        bank_name: props.bank_name,
                        branch_name: props.branch_name,
                        branch_type: getSimplifiedBranchType(branch.service_type) || branch.branch_type,
                        address: branch.address,
                        city: branch.city,
                        state: branch.state_abbrv || branch.state,
                        zip: branch.zip,
                        lmi: branch.lmict,
                        minority: branch.mmct,
                        deposits: branch.total_deposits,
                        lat: coords[1],
                        lng: coords[0]
                    });
                    if (currentPopup) currentPopup.remove();
                    currentPopup = new mapboxgl.Popup({ maxWidth: '300px' }).setLngLat(coords).setHTML(html).addTo(branchMap);
                });

                branchMap.on('mouseenter', 'gray-all-banks-fill', () => branchMap.getCanvas().style.cursor = 'pointer');
                branchMap.on('mouseleave', 'gray-all-banks-fill', () => branchMap.getCanvas().style.cursor = '');
            }
        }

        function renderAllBanksInViewOSCR() {
            // For OSCR view, render gray OSCR markers for non-selected banks
            clearGrayMarkers();
            // Store gray OSCR markers on window for cleanup
            window._grayOscrMarkers = [];

            const selectedNames = selectedBanks.map(b => b.name);
            const showOpenings = document.getElementById('filterOpenings').checked;
            const showClosings = document.getElementById('filterClosings').checked;

            allBanksInView.forEach(event => {
                if (selectedNames.some(n => (event.institution || '').includes(n))) return;
                if (!event.latitude || !event.longitude) return;
                if (event.display_type === 'opening' && !showOpenings) return;
                if (event.display_type === 'closing' && !showClosings) return;

                // Apply draw filter if active
                if (activeDrawFilter) {
                    const lat = parseFloat(event.latitude), lng = parseFloat(event.longitude);
                    if (isNaN(lat) || isNaN(lng) || !turf.booleanPointInPolygon(turf.point([lng, lat]), activeDrawFilter)) return;
                }

                const el = document.createElement('div');
                if (event.display_type === 'opening') {
                    el.style.cssText = 'width: 12px; height: 12px; background: #2e7d32; border: 1px solid #fff; border-radius: 50%; opacity: 0.7; cursor: pointer;';
                } else {
                    el.style.cssText = 'width: 12px; height: 12px; background: #c62828; border: 1px solid #fff; border-radius: 2px; opacity: 0.7; cursor: pointer; display: flex; align-items: center; justify-content: center; color: white; font-size: 8px; font-weight: bold;';
                    el.textContent = '\u2715';
                }

                const marker = new mapboxgl.Marker({ element: el })
                    .setLngLat([event.longitude, event.latitude])
                    .addTo(branchMap);

                // Add click popup
                el.addEventListener('click', function(e) {
                    e.stopPropagation();
                    if (currentPopup) currentPopup.remove();
                    const html = buildPopupHTML({
                        bank_name: event.institution || 'Unknown',
                        branch_name: event.branch_name,
                        branch_type: getSimplifiedBranchType(event.service_type),
                        address: event.address,
                        city: event.city,
                        state: event.state,
                        zip: event.zip,
                        deposits: null,
                        lmi: false,
                        minority: false,
                        lat: event.latitude,
                        lng: event.longitude,
                        change_type: event.display_type,
                        effective_date: event.effective_date || event.processed_date
                    });
                    currentPopup = new mapboxgl.Popup({ maxWidth: '300px' })
                        .setLngLat([event.longitude, event.latitude])
                        .setHTML(html)
                        .addTo(branchMap);
                });

                window._grayOscrMarkers.push(marker);
            });
        }

        function clearGrayMarkers() {
            // Clear GeoJSON gray layer
            if (branchMap.getLayer('gray-all-banks-fill')) branchMap.removeLayer('gray-all-banks-fill');
            if (branchMap.getSource('gray-all-banks')) branchMap.removeSource('gray-all-banks');

            // Clear gray OSCR markers
            if (window._grayOscrMarkers) {
                window._grayOscrMarkers.forEach(m => m.remove());
                window._grayOscrMarkers = [];
            }
        }

        function clearAllMarkers() {
            // Clear selected bank markers
            selectedBanks.forEach(bank => {
                bank._layerIds.forEach(id => {
                    if (branchMap.getLayer(id)) branchMap.removeLayer(id);
                    if (branchMap.getSource(id)) branchMap.removeSource(id);
                });
                if (bank._oscrMarkers) bank._oscrMarkers.forEach(m => m.remove());
                bank._layerIds = [];
                bank._oscrMarkers = [];
            });

            // Clear gray markers
            clearGrayMarkers();

            // Clear relocation lines
            relocationLines.forEach(id => {
                if (branchMap.getLayer(id)) branchMap.removeLayer(id);
                if (branchMap.getSource(id)) branchMap.removeSource(id);
            });
            relocationLines = [];

            if (currentPopup) { currentPopup.remove(); currentPopup = null; }
        }

        function isWithinBounds(inner, outer) {
            return inner.sw.lat >= outer.sw.lat && inner.sw.lng >= outer.sw.lng &&
                   inner.ne.lat <= outer.ne.lat && inner.ne.lng <= outer.ne.lng;
        }

        function fitMapToAllSelectedBanks() {
            const bounds = new mapboxgl.LngLatBounds();
            let hasPoints = false;

            selectedBanks.forEach(bank => {
                bank.branches.forEach(b => {
                    let lat = b.latitude, lng = b.longitude;
                    if (typeof lat === 'string') lat = parseFloat(lat);
                    if (typeof lng === 'string') lng = parseFloat(lng);
                    if (!isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0) {
                        bounds.extend([lng, lat]);
                        hasPoints = true;
                    }
                });
            });

            if (hasPoints && !bounds.isEmpty()) {
                branchMap.fitBounds(bounds, { padding: 50 });
            }
        }

        // ===== View Mode =====
        function setViewMode(mode) {
            currentViewMode = mode;

            document.getElementById('btnSODMode').classList.toggle('active', mode === 'sod');
            document.getElementById('btnOSCRMode').classList.toggle('active', mode === 'oscr');
            document.getElementById('oscrControls').style.display = mode === 'oscr' ? 'block' : 'none';

            // Census toggle always visible (tileset handles zoom levels)
            const censusGroup = document.getElementById('censusToggleGroup');
            if (censusGroup) censusGroup.style.display = 'block';

            // Clear all markers (not map position!) but preserve census layers
            clearAllMarkers();

            // Load data for all selected banks in new mode
            (async () => {
                for (const bank of selectedBanks) {
                    if (mode === 'sod') {
                        if (bank.branches.length === 0) await loadBankBranches(bank);
                        renderBankSODMarkers(bank);
                    } else {
                        if (bank.oscrEvents.length === 0) await loadBankOSCREvents(bank);
                        renderBankOSCRMarkers(bank);
                    }
                }
                renderBankChips();

                if (showAllBanksActive) {
                    loadedBounds = null;
                    await loadAllBanksInView();
                }

                if (mode === 'oscr') showOSCRLegend();
                else hideOSCRLegend();
            })();

            updateContextBar();
        }

        function updateContextBar(html) {
            const ctx = document.getElementById('mapContextBar');
            if (html) {
                ctx.innerHTML = html;
                return;
            }
            if (selectedBanks.length === 0) {
                ctx.innerHTML = '<p style="margin: 0; color: #333; line-height: 1.4; font-size: 0.8rem;"><i class="fas fa-info-circle"></i> <strong>About:</strong> Search a bank to get started.</p>';
            } else {
                const bankList = selectedBanks.map(b => {
                    const count = currentViewMode === 'sod' ? b.branches.length : b.oscrEvents.length;
                    return `<span style="color: ${b.color}; font-weight: 600;">${b.name}</span> (${count})`;
                }).join(' | ');
                const modeLabel = currentViewMode === 'sod' ? 'SOD June 30, 2025' : 'FDIC structural changes';
                ctx.innerHTML = `<p style="margin: 0; color: #333; line-height: 1.4; font-size: 0.8rem;"><i class="fas fa-info-circle"></i> ${bankList} &mdash; ${modeLabel}</p>`;
            }
        }

        function setCensusOverlay(type) {
            document.querySelectorAll('.tract-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.census === type);
            });

            const column2Legend = document.getElementById('column2Legend');
            const column2IncomeLegend = document.getElementById('column2IncomeLegend');
            const column2MinorityLegend = document.getElementById('column2MinorityLegend');

            // Hide all census tileset layers first
            ['census-income-fill', 'census-income-outline', 'census-minority-fill', 'census-minority-outline'].forEach(id => {
                if (branchMap.getLayer(id)) branchMap.setLayoutProperty(id, 'visibility', 'none');
            });
            // Also remove any legacy GeoJSON census layers
            removeSourceAndLayers('income-tracts');
            removeSourceAndLayers('minority-tracts');
            incomeLayerVisible = false;
            minorityLayerVisible = false;

            if (column2Legend) column2Legend.style.display = 'none';
            if (column2IncomeLegend) column2IncomeLegend.style.display = 'none';
            if (column2MinorityLegend) column2MinorityLegend.style.display = 'none';

            if (type === 'off') return;

            // Move census layers below bank markers
            const firstBankLayer = selectedBanks.length > 0 && selectedBanks[0]._layerIds && selectedBanks[0]._layerIds.length > 1
                ? selectedBanks[0]._layerIds[1] : undefined;
            const beforeLayer = branchMap.getLayer('gray-all-banks-fill') ? 'gray-all-banks-fill' : firstBankLayer;

            if (type === 'income') {
                if (beforeLayer) {
                    branchMap.moveLayer('census-income-fill', beforeLayer);
                    branchMap.moveLayer('census-income-outline', beforeLayer);
                }
                branchMap.setLayoutProperty('census-income-fill', 'visibility', 'visible');
                branchMap.setLayoutProperty('census-income-outline', 'visibility', 'visible');
                incomeLayerVisible = true;
                if (column2Legend) column2Legend.style.display = 'block';
                if (column2IncomeLegend) column2IncomeLegend.style.display = 'block';
            } else if (type === 'minority') {
                if (beforeLayer) {
                    branchMap.moveLayer('census-minority-fill', beforeLayer);
                    branchMap.moveLayer('census-minority-outline', beforeLayer);
                }
                branchMap.setLayoutProperty('census-minority-fill', 'visibility', 'visible');
                branchMap.setLayoutProperty('census-minority-outline', 'visibility', 'visible');
                minorityLayerVisible = true;
                if (column2Legend) column2Legend.style.display = 'block';
                if (column2MinorityLegend) column2MinorityLegend.style.display = 'block';
            }
        }

        // ── Draw Area Functions ──

        function initDrawControl() {
            drawControl = new MapboxDraw({
                displayControlsDefault: false,
                defaultMode: 'simple_select',
                styles: [
                    // Polygon fill
                    { id: 'gl-draw-polygon-fill', type: 'fill', filter: ['all', ['==', '$type', 'Polygon']],
                      paint: { 'fill-color': '#e74c3c', 'fill-opacity': 0.15 } },
                    // Polygon outline
                    { id: 'gl-draw-polygon-stroke', type: 'line', filter: ['all', ['==', '$type', 'Polygon']],
                      paint: { 'line-color': '#e74c3c', 'line-width': 2.5, 'line-dasharray': [2, 2] } },
                    // Vertices
                    { id: 'gl-draw-point', type: 'circle', filter: ['all', ['==', '$type', 'Point'], ['==', 'meta', 'vertex']],
                      paint: { 'circle-radius': 5, 'circle-color': '#e74c3c' } },
                    // Midpoints
                    { id: 'gl-draw-point-mid', type: 'circle', filter: ['all', ['==', '$type', 'Point'], ['==', 'meta', 'midpoint']],
                      paint: { 'circle-radius': 3, 'circle-color': '#e74c3c' } },
                    // Active line (while drawing)
                    { id: 'gl-draw-line', type: 'line', filter: ['all', ['==', '$type', 'LineString']],
                      paint: { 'line-color': '#e74c3c', 'line-width': 2, 'line-dasharray': [2, 2] } }
                ]
            });
            branchMap.addControl(drawControl, 'top-right');

            branchMap.on('draw.create', onDrawCreate);
            branchMap.on('draw.update', onDrawUpdate);
        }

        function startDrawing() {
            if (!drawControl) initDrawControl();
            isDrawing = true;
            drawControl.changeMode('draw_polygon');
            document.getElementById('drawStartBtn').style.display = 'none';
            document.getElementById('drawActiveControls').style.display = 'block';
            document.getElementById('drawResultControls').style.display = 'none';
            updateInfoPanel('Click on the map to draw a polygon boundary. Double-click to finish.');
        }

        function cancelDrawing() {
            if (drawControl) {
                drawControl.deleteAll();
                drawControl.changeMode('simple_select');
            }
            isDrawing = false;
            drawnPolygon = null;
            document.getElementById('drawStartBtn').style.display = 'block';
            document.getElementById('drawActiveControls').style.display = 'none';
            document.getElementById('drawResultControls').style.display = 'none';
            updateInfoPanel('Drawing cancelled.');
        }

        function onDrawCreate(e) {
            isDrawing = false;
            const feature = e.features[0];
            drawnPolygon = feature;

            document.getElementById('drawActiveControls').style.display = 'none';
            document.getElementById('drawResultControls').style.display = 'block';

            // Set the active filter polygon (used by all render functions)
            activeDrawFilter = feature.geometry
                ? turf.polygon(feature.geometry.coordinates)
                : turf.polygon(feature.coordinates);

            // Count branches inside polygon BEFORE re-rendering
            const stats = countBranchesInPolygon(feature);
            const summary = document.getElementById('drawAreaSummary');
            const area = turf.area(feature);
            const areaSqMi = (area / 2589988).toFixed(1);
            let html = `<strong>${stats.total} branches</strong> in drawn area (${areaSqMi} sq mi)`;
            if (stats.byBank.length > 0) {
                html += '<br>' + stats.byBank.map(b => `<span style="color:${b.color};font-weight:600;">${b.name}</span>: ${b.count}`).join(', ');
            }
            if (stats.grayCount > 0) {
                html += `<br><span style="color:#666;">Other banks: ${stats.grayCount}</span>`;
            }
            summary.innerHTML = html;

            // Re-render all markers with the filter active — hides everything outside
            reRenderAllMarkers();
            updateInfoPanel(`Filtered to drawn area: ${stats.total} branches in ${areaSqMi} sq mi.`);
        }

        function onDrawUpdate(e) {
            if (e.features.length > 0) {
                drawnPolygon = e.features[0];
                onDrawCreate(e);
            }
        }

        function countBranchesInPolygon(polygon) {
            let total = 0;
            let grayCount = 0;
            const byBank = [];

            // Ensure polygon is a proper Turf polygon
            const turfPoly = polygon.geometry ? turf.polygon(polygon.geometry.coordinates) : turf.polygon(polygon.coordinates);
            console.log('Draw polygon coords:', turfPoly.geometry.coordinates[0].length, 'vertices');

            // Count selected bank branches
            for (const bank of selectedBanks) {
                const data = currentViewMode === 'sod' ? bank.branches : bank.oscrEvents;
                let count = 0;
                console.log(`Checking ${data.length} branches for ${bank.name}`);
                for (const b of data) {
                    const lat = parseFloat(b.latitude);
                    const lng = parseFloat(b.longitude);
                    if (!isNaN(lat) && !isNaN(lng) && turf.booleanPointInPolygon(turf.point([lng, lat]), turfPoly)) {
                        count++;
                    }
                }
                if (count > 0) byBank.push({ name: bank.name, color: bank.color, count });
                total += count;
            }

            // Count gray "show all" branches
            if (showAllBanksActive && allBanksInView.length > 0) {
                const selectedNames = new Set(selectedBanks.map(b => b.name));
                let checked = 0;
                for (const b of allBanksInView) {
                    if (selectedNames.has(b.bank_name)) continue;
                    const lat = parseFloat(b.latitude);
                    const lng = parseFloat(b.longitude);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        checked++;
                        if (turf.booleanPointInPolygon(turf.point([lng, lat]), turfPoly)) {
                            grayCount++;
                        }
                    }
                }
                console.log(`Checked ${checked} gray branches, ${grayCount} inside polygon`);
                total += grayCount;
            }

            console.log(`Total in polygon: ${total} (${byBank.length} banks, ${grayCount} gray)`);
            return { total, byBank, grayCount };
        }

        function saveDrawnArea() {
            if (!drawnPolygon) return;

            savedAreaCounter++;
            const color = DRAW_COLORS[(savedAreaCounter - 1) % DRAW_COLORS.length];
            const name = `Area ${savedAreaCounter}`;
            const stats = countBranchesInPolygon(drawnPolygon);
            const area = turf.area(drawnPolygon);
            const areaSqMi = (area / 2589988).toFixed(1);

            const savedArea = {
                id: `saved-area-${savedAreaCounter}`,
                name,
                polygon: JSON.parse(JSON.stringify(drawnPolygon)),
                color,
                stats,
                areaSqMi
            };
            savedAreas.push(savedArea);

            // Remove draw control polygon and add as a permanent layer
            if (drawControl) {
                drawControl.deleteAll();
                drawControl.changeMode('simple_select');
            }

            // Add saved polygon as permanent map layer
            branchMap.addSource(savedArea.id, {
                type: 'geojson',
                data: savedArea.polygon
            });
            branchMap.addLayer({
                id: `${savedArea.id}-fill`, type: 'fill', source: savedArea.id,
                paint: { 'fill-color': color, 'fill-opacity': 0.1 }
            });
            branchMap.addLayer({
                id: `${savedArea.id}-outline`, type: 'line', source: savedArea.id,
                paint: { 'line-color': color, 'line-width': 2.5 }
            });
            branchMap.addLayer({
                id: `${savedArea.id}-label`, type: 'symbol', source: savedArea.id,
                layout: {
                    'text-field': name,
                    'text-size': 12,
                    'text-anchor': 'center',
                    'text-allow-overlap': true
                },
                paint: { 'text-color': color, 'text-halo-color': '#ffffff', 'text-halo-width': 2 }
            });

            drawnPolygon = null;
            activeDrawFilter = null;
            document.getElementById('drawStartBtn').style.display = 'block';
            document.getElementById('drawResultControls').style.display = 'none';
            renderSavedAreas();
            // Restore all markers after saving (filter released)
            reRenderAllMarkers();
            updateInfoPanel(`Saved "${name}" — ${stats.total} branches, ${areaSqMi} sq mi.`);
        }

        function clearDrawnArea() {
            if (drawControl) {
                drawControl.deleteAll();
                drawControl.changeMode('simple_select');
            }
            isDrawing = false;
            drawnPolygon = null;
            activeDrawFilter = null;
            document.getElementById('drawStartBtn').style.display = 'block';
            document.getElementById('drawActiveControls').style.display = 'none';
            document.getElementById('drawResultControls').style.display = 'none';
            // Re-render all markers without the filter
            reRenderAllMarkers();
            updateInfoPanel('Filter cleared — showing all branches.');
        }

        function deleteSavedArea(areaId) {
            removeSourceAndLayers(areaId);
            savedAreas = savedAreas.filter(a => a.id !== areaId);
            renderSavedAreas();
        }

        function clearAllSavedAreas() {
            for (const area of savedAreas) {
                removeSourceAndLayers(area.id);
            }
            savedAreas = [];
            savedAreaCounter = 0;
            renderSavedAreas();
        }

        function renderSavedAreas() {
            const container = document.getElementById('savedAreasContainer');
            if (savedAreas.length === 0) {
                container.innerHTML = '';
                return;
            }
            let html = '<div style="font-size: 0.75rem; color: #666; margin-top: 4px;">';
            for (const area of savedAreas) {
                html += `<div style="display: flex; align-items: center; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #eee;">
                    <span><span style="display:inline-block;width:10px;height:10px;background:${area.color};border-radius:2px;margin-right:4px;"></span>
                    <strong>${area.name}</strong> — ${area.stats.total} branches, ${area.areaSqMi} sq mi</span>
                    <button onclick="deleteSavedArea('${area.id}')" style="background:none;border:none;color:#dc3545;cursor:pointer;font-size:0.8rem;padding:2px 4px;" title="Remove">
                        <i class="fas fa-times"></i>
                    </button>
                </div>`;
            }
            if (savedAreas.length > 1) {
                html += `<button onclick="clearAllSavedAreas()" style="margin-top:4px;width:100%;padding:4px;background:#6c757d;color:white;border:none;border-radius:4px;cursor:pointer;font-size:0.75rem;">Clear All Areas</button>`;
            }
            html += '</div>';
            container.innerHTML = html;
        }

        // ── End Draw Area Functions ──

        async function loadCountyBoundariesForViewport() {
            if (!branchMap || currentZoom < METRO_ZOOM_THRESHOLD) return;

            const bounds = branchMap.getBounds();
            const sw = bounds.getSouthWest();
            const ne = bounds.getNorthEast();

            try {
                const response = await fetch(
                    `${APP_BASE_URL}/api/counties-in-bounds?sw_lat=${sw.lat}&sw_lng=${sw.lng}&ne_lat=${ne.lat}&ne_lng=${ne.lng}`
                );
                const data = await response.json();
                if (data.success) {
                    viewportCounties = data.counties || [];
                    // Load boundaries for new counties
                    const newFips = viewportCounties
                        .map(c => c.geoid5)
                        .filter(Boolean)
                        .filter(f => !countyBoundaryIds.includes(`county-boundary-${f}`));
                    if (newFips.length > 0) addCountyBoundaries(newFips);
                }
            } catch (err) {
                console.warn('Failed to load counties for viewport:', err);
            }
        }

        function resetMap() {
            clearAllMarkers();
            clearCountyBoundaries();
            hideOSCRLegend();
            clearAllSavedAreas();
            cancelDrawing();

            selectedBanks = [];
            showAllBanksActive = false;
            allBanksInView = [];
            loadedBounds = null;
            viewportCounties = [];

            // Hide census tileset layers
            ['census-income-fill', 'census-income-outline', 'census-minority-fill', 'census-minority-outline'].forEach(id => {
                if (branchMap && branchMap.getLayer(id)) branchMap.setLayoutProperty(id, 'visibility', 'none');
            });
            removeSourceAndLayers('income-tracts');
            removeSourceAndLayers('minority-tracts');
            incomeLayerVisible = false;
            minorityLayerVisible = false;

            document.getElementById('bankSearchInput').value = '';
            document.getElementById('bankChipsContainer').innerHTML = '';

            currentViewMode = 'sod';
            document.getElementById('btnSODMode').classList.add('active');
            document.getElementById('btnOSCRMode').classList.remove('active');
            document.getElementById('oscrControls').style.display = 'none';
            document.getElementById('censusToggleGroup').style.display = 'none';

            document.querySelectorAll('.tract-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.census === 'off');
            });

            const column2Legend = document.getElementById('column2Legend');
            if (column2Legend) column2Legend.style.display = 'none';

            updateShowAllButton();

            if (branchMap) {
                branchMap.flyTo({ center: [-98.5, 38.0], zoom: 3 });
            }

            showOnboardingOverlay();
            updateContextBar();
            updateInfoPanel('Map reset. Search a bank to get started.');
        }

        function refilterOSCR() {
            if (currentViewMode !== 'oscr') return;

            // Re-render selected banks' OSCR markers
            selectedBanks.forEach(bank => {
                if (bank._oscrMarkers) bank._oscrMarkers.forEach(m => m.remove());
                bank._oscrMarkers = [];
                renderBankOSCRMarkers(bank);
            });

            // Re-render gray OSCR if active
            if (showAllBanksActive && allBanksInView.length > 0) {
                renderAllBanksInViewOSCR();
            }
        }

        async function addCountyBoundaries(fipsList) {
            clearCountyBoundaries();
            if (!branchMap || !fipsList || fipsList.length === 0) return;

            fipsList.forEach(fips => {
                const sourceId = `county-boundary-${fips}`;
                const stateFips = fips.substring(0, 2);
                const countyFips = fips.substring(2);

                // TIGERweb REST service for county boundaries
                const tigerUrl = `https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/tigerWMS_Current/MapServer/86/query?where=STATE%3D%27${stateFips}%27+AND+COUNTY%3D%27${countyFips}%27&outFields=*&outSR=4326&f=geojson`;

                fetch(tigerUrl)
                    .then(r => r.json())
                    .then(geojson => {
                        if (!geojson.features || geojson.features.length === 0) return;
                        if (branchMap.getSource(sourceId)) return;

                        branchMap.addSource(sourceId, { type: 'geojson', data: geojson });
                        branchMap.addLayer({
                            id: sourceId + '-outline',
                            type: 'line',
                            source: sourceId,
                            paint: {
                                'line-color': '#1e3a5f',
                                'line-width': 2,
                                'line-opacity': 0.6,
                                'line-dasharray': [3, 2]
                            }
                        });
                        countyBoundaryIds.push(sourceId);
                    })
                    .catch(err => console.warn('Failed to load county boundary for', fips, err));
            });
        }

        function clearCountyBoundaries() {
            countyBoundaryIds.forEach(id => {
                if (branchMap && branchMap.getLayer(id + '-outline')) branchMap.removeLayer(id + '-outline');
                if (branchMap && branchMap.getSource(id)) branchMap.removeSource(id);
            });
            countyBoundaryIds = [];
        }

        function getOSCRDateRange() {
            const selection = document.getElementById('dateRangeSelect').value;
            const today = new Date().toISOString().split('T')[0];

            switch (selection) {
                case 'since_sod':
                    return { start: '2025-06-30', end: today };
                case '12months':
                    const oneYearAgo = new Date();
                    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
                    return { start: oneYearAgo.toISOString().split('T')[0], end: today };
                case '3years':
                    const threeYearsAgo = new Date();
                    threeYearsAgo.setFullYear(threeYearsAgo.getFullYear() - 3);
                    return { start: threeYearsAgo.toISOString().split('T')[0], end: today };
                case 'custom':
                    return {
                        start: document.getElementById('startDate').value,
                        end: document.getElementById('endDate').value || today
                    };
                default:
                    const defaultStart = new Date();
                    defaultStart.setFullYear(defaultStart.getFullYear() - 3);
                    return { start: defaultStart.toISOString().split('T')[0], end: today };
            }
        }

        // Geocode an address using Mapbox Geocoding API
        async function geocodeAddress(address, city, state, zip) {
            const query = `${address}, ${city}, ${state} ${zip}`;
            try {
                const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${MAPBOX_TOKEN}&limit=1&country=US`;
                const resp = await fetch(url);
                if (resp.ok) {
                    const data = await resp.json();
                    if (data.features && data.features.length > 0) {
                        const [lng, lat] = data.features[0].center;
                        return { latitude: lat, longitude: lng };
                    }
                }
            } catch (e) {
                console.warn('Geocoding failed for:', query, e.message);
            }
            return null;
        }

        // Geocode events that are missing coordinates (batched with delay)
        async function geocodeOSCREvents(events) {
            let geocoded = 0;
            for (const event of events) {
                if (event.latitude && event.longitude) continue;
                if (!event.address || !event.city) continue;

                const coords = await geocodeAddress(event.address, event.city, event.state, event.zip);
                if (coords) {
                    event.latitude = coords.latitude;
                    event.longitude = coords.longitude;
                    geocoded++;
                }

                // Small delay to avoid rate limits (Mapbox allows ~600/min)
                if (geocoded % 10 === 0) {
                    await new Promise(r => setTimeout(r, 100));
                }
            }
            if (geocoded > 0) {
                console.log(`Geocoded ${geocoded} events via Mapbox`);
            }
        }

        function renderOSCRMarkers(events, fitBoundsToMarkers) {
            if (fitBoundsToMarkers === undefined) fitBoundsToMarkers = true;
            const validEvents = events.filter(e => e.latitude && e.longitude);

            // Format ISO datetime to date only
            const fmtDate = (d) => {
                if (!d) return 'N/A';
                return d.split('T')[0];
            };

            // Group co-located events (same address) so hover shows all events at that spot
            const COLOCATE_THRESHOLD = 0.0003; // ~33 meters
            const groups = [];
            const assigned = new Set();
            validEvents.forEach((evt, i) => {
                if (assigned.has(i)) return;
                const group = [evt];
                assigned.add(i);
                for (let j = i + 1; j < validEvents.length; j++) {
                    if (assigned.has(j)) continue;
                    if (Math.abs(evt.latitude - validEvents[j].latitude) < COLOCATE_THRESHOLD &&
                        Math.abs(evt.longitude - validEvents[j].longitude) < COLOCATE_THRESHOLD) {
                        group.push(validEvents[j]);
                        assigned.add(j);
                    }
                }
                groups.push(group);
            });

            // Helper to build popup HTML for one event
            function buildEventHTML(event) {
                let html = `
                    <div style="margin-bottom: 6px;">
                        <div class="bank-name-header">${event.institution || 'Unknown'}</div>
                        <div class="branch-info"><strong>Branch:</strong> ${event.branch_name || 'N/A'}</div>
                        <div class="branch-info"><strong>Address:</strong> ${event.address || ''}, ${event.city || ''}, ${event.state || ''} ${event.zip || ''}</div>
                        <div class="branch-info"><strong>Event:</strong> ${event.display_type === 'opening' ? 'Branch Opening' : 'Branch Closing'}${event.is_relocation ? ' (Relocation)' : ''}</div>
                        ${event.service_type ? `<div class="branch-info"><strong>Service Type:</strong> ${event.service_type}</div>` : ''}
                        <div class="branch-info"><strong>Effective Date:</strong> ${fmtDate(event.effective_date)}</div>
                        <div class="branch-info"><strong>Processed Date:</strong> ${fmtDate(event.processed_date)}</div>
                `;
                if (event.is_relocation && event.relocation_pair_address) {
                    const label = event.display_type === 'closing' ? 'Relocated to' : 'Relocated from';
                    html += `<div class="branch-info" style="margin-top: 4px;"><strong>${label}:</strong> ${event.relocation_pair_address}</div>`;
                }
                html += `</div>`;
                return html;
            }

            groups.forEach(group => {
                // Build combined popup for all events at this location
                const mapsQuery = encodeURIComponent(`${group[0].address}, ${group[0].city}, ${group[0].state} ${group[0].zip}`);
                let popupHTML = '<div class="popup-content">';
                group.forEach((event, idx) => {
                    if (idx > 0) popupHTML += '<hr style="margin: 6px 0; border: none; border-top: 1px solid #ddd;">';
                    popupHTML += buildEventHTML(event);
                });
                popupHTML += `
                    <div style="margin-top: 8px;">
                        <a href="https://www.google.com/maps/search/?api=1&query=${mapsQuery}"
                           target="_blank" style="color: var(--ncrc-primary-blue); font-size: 0.85rem;">
                           <i class="fas fa-external-link-alt"></i> View in Google Maps
                        </a>
                    </div>
                </div>`;

                // Popup: hover to preview, click to pin, X to close
                const popup = new mapboxgl.Popup({
                    offset: 15,
                    maxWidth: '350px',
                    closeButton: true,
                    closeOnClick: false
                }).setHTML(popupHTML);

                let pinned = false;
                let hideTimer = null;

                function showPopup(lngLat) {
                    clearTimeout(hideTimer);
                    if (!popup.isOpen()) {
                        popup.setLngLat(lngLat).addTo(branchMap);
                    }
                    // Listen on the popup DOM element so hovering the popup keeps it alive
                    const popupEl = popup.getElement();
                    if (popupEl && !popupEl._oscrListeners) {
                        popupEl._oscrListeners = true;
                        popupEl.addEventListener('mouseenter', () => clearTimeout(hideTimer));
                        popupEl.addEventListener('mouseleave', () => { if (!pinned) scheduleHide(); });
                    }
                }

                function scheduleHide() {
                    if (pinned) return;
                    clearTimeout(hideTimer);
                    hideTimer = setTimeout(() => { if (!pinned) popup.remove(); }, 300);
                }

                popup.on('close', () => { pinned = false; });

                function wireEvents(el, lngLat) {
                    el.addEventListener('mouseenter', () => showPopup(lngLat));
                    el.addEventListener('mouseleave', () => { if (!pinned) scheduleHide(); });
                    el.addEventListener('click', () => {
                        clearTimeout(hideTimer);
                        pinned = true;
                        showPopup(lngLat);
                    });
                }

                if (group.length > 1) {
                    // Multiple events at same location — combined marker
                    const el = document.createElement('div');
                    el.style.cssText = `display: flex; align-items: center; gap: 2px; cursor: pointer;`;

                    const sorted = [...group].sort((a, b) => {
                        if (a.display_type === 'closing' && b.display_type === 'opening') return -1;
                        if (a.display_type === 'opening' && b.display_type === 'closing') return 1;
                        return 0;
                    });

                    sorted.forEach(event => {
                        const icon = document.createElement('div');
                        if (event.display_type === 'opening') {
                            icon.style.cssText = `width: 16px; height: 16px; background-color: #2e7d32; border: 1px solid #000000; border-radius: 50%;`;
                        } else {
                            icon.style.cssText = `width: 16px; height: 16px; background-color: #c62828; border: 1px solid #000000; border-radius: 3px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 10px; line-height: 1;`;
                            icon.textContent = '\u2715';
                        }
                        el.appendChild(icon);
                    });

                    const lngLat = [group[0].longitude, group[0].latitude];
                    const marker = new mapboxgl.Marker({ element: el, anchor: 'center' })
                        .setLngLat(lngLat)
                        .addTo(branchMap);

                    wireEvents(el, lngLat);
                    oscrMarkers.push(marker);
                } else {
                    // Single event
                    const event = group[0];
                    const el = document.createElement('div');
                    if (event.display_type === 'opening') {
                        el.style.cssText = `width: 18px; height: 18px; background-color: #2e7d32; border: 1px solid #000000; border-radius: 50%; cursor: pointer;`;
                    } else {
                        el.style.cssText = `width: 18px; height: 18px; background-color: #c62828; border: 1px solid #000000; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px; line-height: 1;`;
                        el.textContent = '\u2715';
                    }

                    const lngLat = [event.longitude, event.latitude];
                    const marker = new mapboxgl.Marker({ element: el })
                        .setLngLat(lngLat)
                        .addTo(branchMap);

                    wireEvents(el, lngLat);
                    oscrMarkers.push(marker);
                }
            });

            // Fit map to markers (only if requested)
            if (fitBoundsToMarkers && oscrMarkers.length > 0) {
                const bounds = new mapboxgl.LngLatBounds();
                oscrMarkers.forEach(m => bounds.extend(m.getLngLat()));
                branchMap.fitBounds(bounds, { padding: 50 });
            }
        }

        function renderRelocationLines(events) {
            // Draw one line per pair — use closing side only to avoid duplicates
            const closingRelocs = events.filter(e =>
                e.is_relocation &&
                e.display_type === 'closing' &&
                e.relocation_pair_lat && e.relocation_pair_lng &&
                e.latitude && e.longitude &&
                (Math.abs(e.latitude - e.relocation_pair_lat) > 0.0005 ||
                 Math.abs(e.longitude - e.relocation_pair_lng) > 0.0005)
            );

            closingRelocs.forEach(closing => {
                const sourceId = `relocation-line-${closing.cert}-${closing.effective_date}`;
                if (branchMap.getSource(sourceId)) return;

                branchMap.addSource(sourceId, {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: [
                                [closing.longitude, closing.latitude],
                                [closing.relocation_pair_lng, closing.relocation_pair_lat]
                            ]
                        }
                    }
                });

                branchMap.addLayer({
                    id: sourceId,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': '#E67E22',
                        'line-width': 2,
                        'line-dasharray': [4, 4]
                    }
                });

                relocationLines.push(sourceId);
            });
        }

        function clearOSCRMarkers() {
            oscrMarkers.forEach(m => m.remove());
            oscrMarkers = [];

            relocationLines.forEach(id => {
                if (branchMap && branchMap.getLayer(id)) branchMap.removeLayer(id);
                if (branchMap && branchMap.getSource(id)) branchMap.removeSource(id);
            });
            relocationLines = [];

        }

        function showOSCRLegend() {
            const existingLegend = document.getElementById('oscrLegend');
            if (existingLegend) existingLegend.remove();

            const legend = document.createElement('div');
            legend.id = 'oscrLegend';
            legend.style.cssText = `
                position: absolute; bottom: 30px; left: 10px; z-index: 1000;
                background: rgba(255,255,255,0.92); padding: 8px 10px;
                border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.15);
                font-size: 0.75rem; display: flex; flex-direction: column; gap: 4px;
                max-width: 200px;
            `;
            legend.innerHTML = `
                <div style="font-weight: 600; color: var(--ncrc-dark-blue); margin-bottom: 2px;">Legend</div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="display: inline-block; width: 14px; height: 14px; background: #2e7d32; border: 1px solid #000; border-radius: 50%;"></span>
                    Branch Opening
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="display: inline-flex; align-items: center; justify-content: center; width: 14px; height: 14px; background: #c62828; border: 1px solid #000; border-radius: 3px; color: white; font-size: 9px; font-weight: bold;">\u2715</span>
                    Branch Closing
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="display: inline-block; width: 20px; border-top: 2px dashed #E67E22;"></span>
                    Inferred Relocation
                </div>
                <div style="margin-top: 4px; font-size: 0.7rem; color: #666; border-top: 1px solid #ddd; padding-top: 4px; line-height: 1.3;">
                    Relocations inferred when the same institution closes and opens a branch within 2 miles and 90 days of each other.
                </div>
            `;

            const mapContainer = document.getElementById('branchMap').parentElement;
            mapContainer.style.position = 'relative';
            mapContainer.appendChild(legend);
        }

        function hideOSCRLegend() {
            const legend = document.getElementById('oscrLegend');
            if (legend) legend.remove();
        }

        // Initialize map using Mapbox GL JS
        function initMap() {
            if (branchMap) {
                branchMap.remove();
            }
            
            // Set access token
            mapboxgl.accessToken = MAPBOX_TOKEN;
            
            // Create Mapbox GL JS map - centered on continental US
            branchMap = new mapboxgl.Map({
                container: 'branchMap',
                style: MAPBOX_STYLE,
                center: [-98.5, 38.0], // [lng, lat] centered to show all US including Hawaii/Alaska
                zoom: 3 // Show full US including Hawaii and Alaska
            });
            
            // Add navigation controls
            branchMap.addControl(new mapboxgl.NavigationControl(), 'top-right');
            
            // Wait for map to load before adding census tileset layers
            branchMap.on('load', function() {
                console.log('Mapbox GL JS map loaded');

                // Add census tileset as vector source
                // Use direct tile URLs with editengine's token for cross-account access
                const CENSUS_TILE_TOKEN = 'pk.eyJ1IjoiZWRpdGVuZ2luZSIsImEiOiJjaWd1MzVtNXMwYjh3dXNtMWExY25vOGpvIn0.cJpymrK-LK18dB8hZ66T8Q';
                branchMap.addSource('census-tileset', {
                    type: 'vector',
                    tiles: [
                        `https://a.tiles.mapbox.com/v4/${CENSUS_TILESET_ID}/{z}/{x}/{y}.vector.pbf?access_token=${CENSUS_TILE_TOKEN}`,
                        `https://b.tiles.mapbox.com/v4/${CENSUS_TILESET_ID}/{z}/{x}/{y}.vector.pbf?access_token=${CENSUS_TILE_TOKEN}`
                    ],
                    minzoom: 5,
                    maxzoom: 12
                });

                // Income fill layer (hidden by default)
                branchMap.addLayer({
                    id: 'census-income-fill',
                    type: 'fill',
                    source: 'census-tileset',
                    'source-layer': CENSUS_SOURCE_LAYER,
                    paint: {
                        'fill-color': getIncomeColorExpression(),
                        'fill-opacity': 0.5
                    },
                    layout: { visibility: 'none' }
                });
                branchMap.addLayer({
                    id: 'census-income-outline',
                    type: 'line',
                    source: 'census-tileset',
                    'source-layer': CENSUS_SOURCE_LAYER,
                    paint: { 'line-color': '#666666', 'line-width': 0.5, 'line-opacity': 0.4 },
                    layout: { visibility: 'none' }
                });

                // Minority fill layer (hidden by default)
                branchMap.addLayer({
                    id: 'census-minority-fill',
                    type: 'fill',
                    source: 'census-tileset',
                    'source-layer': CENSUS_SOURCE_LAYER,
                    paint: {
                        'fill-color': getMinorityColorExpression(),
                        'fill-opacity': 0.5
                    },
                    layout: { visibility: 'none' }
                });
                branchMap.addLayer({
                    id: 'census-minority-outline',
                    type: 'line',
                    source: 'census-tileset',
                    'source-layer': CENSUS_SOURCE_LAYER,
                    paint: { 'line-color': '#666666', 'line-width': 0.5, 'line-opacity': 0.4 },
                    layout: { visibility: 'none' }
                });

                // Click popup for income layer
                branchMap.on('click', 'census-income-fill', function(e) {
                    if (!e.features || e.features.length === 0) return;
                    const props = e.features[0].properties;
                    const fmt = (v) => v ? '$' + Math.round(parseFloat(v)).toLocaleString('en-US') : 'N/A';
                    new mapboxgl.Popup({ maxWidth: '280px' })
                        .setLngLat(e.lngLat)
                        .setHTML(`<div style="min-width:200px;">
                            <strong>${props.NAME || 'Census Tract'}</strong><br><hr style="margin:8px 0;">
                            <strong>Income Category:</strong> ${props.income_category || 'Unknown'}<br>
                            <strong>Tract Median Income:</strong> ${fmt(props.median_family_income)}<br>
                            <strong>State Median:</strong> ${fmt(props.baseline_median_income)}<br>
                            ${props.income_ratio ? `<strong>Ratio:</strong> ${parseFloat(props.income_ratio).toFixed(2)}x<br>` : ''}
                            <hr style="margin:8px 0;">
                            <small style="color:#666;">Low (≤50%), Moderate (≤80%), Middle (≤120%), Upper (>120%)</small>
                        </div>`)
                        .addTo(branchMap);
                });

                // Click popup for minority layer
                branchMap.on('click', 'census-minority-fill', function(e) {
                    if (!e.features || e.features.length === 0) return;
                    const props = e.features[0].properties;
                    const pct = props.minority_percentage != null ? parseFloat(props.minority_percentage).toFixed(1) + '%' : 'N/A';
                    const pop = props.total_population ? Math.round(parseFloat(props.total_population)).toLocaleString() : 'N/A';
                    new mapboxgl.Popup({ maxWidth: '280px' })
                        .setLngLat(e.lngLat)
                        .setHTML(`<div style="min-width:200px;">
                            <strong>${props.NAME || 'Census Tract'}</strong><br><hr style="margin:8px 0;">
                            <strong>Category:</strong> ${props.minority_category || 'Unknown'}<br>
                            <strong>Minority Pop:</strong> ${pct}<br>
                            <strong>Total Pop:</strong> ${pop}<br>
                            <hr style="margin:8px 0;">
                            <small style="color:#666;">Based on quartile distribution within state</small>
                        </div>`)
                        .addTo(branchMap);
                });

                // Hover cursors
                ['census-income-fill', 'census-minority-fill'].forEach(id => {
                    branchMap.on('mouseenter', id, () => branchMap.getCanvas().style.cursor = 'pointer');
                    branchMap.on('mouseleave', id, () => branchMap.getCanvas().style.cursor = '');
                });
            });

            branchMap.on('zoomend', function() {
                const prevZoom = currentZoom;
                currentZoom = branchMap.getZoom();
                updateShowAllButton();

                // Deactivate show-all if zoomed out
                if (currentZoom < METRO_ZOOM_THRESHOLD && showAllBanksActive) {
                    deactivateShowAll();
                }

                // Census toggle always visible (tileset handles zoom)
                const censusGroup = document.getElementById('censusToggleGroup');
                if (censusGroup) censusGroup.style.display = 'block';

                // Load county boundaries at metro zoom
                if (currentZoom >= METRO_ZOOM_THRESHOLD && prevZoom < METRO_ZOOM_THRESHOLD) {
                    loadCountyBoundariesForViewport();
                } else if (currentZoom < METRO_ZOOM_THRESHOLD) {
                    clearCountyBoundaries();
                }
            });

            branchMap.on('moveend', function() {
                if (showAllBanksActive && currentZoom >= METRO_ZOOM_THRESHOLD) {
                    loadAllBanksInView();
                }
                if (currentZoom >= METRO_ZOOM_THRESHOLD) {
                    loadCountyBoundariesForViewport();
                }
            });

        }
        
        // Helper function to remove a source and its layers
        function removeSourceAndLayers(sourceId) {
            if (!branchMap) return;
            
            // Remove layers first
            const layerIds = [sourceId + '-fill', sourceId + '-outline'];
            layerIds.forEach(function(layerId) {
                if (branchMap.getLayer(layerId)) {
                    branchMap.removeLayer(layerId);
                }
            });
            
            // Then remove source
            if (branchMap.getSource(sourceId)) {
                branchMap.removeSource(sourceId);
            }
        }
        
        // Get gray shade for income category (darker = lower income)
        function getIncomeColor(category) {
            switch(category) {
                case 'Low':
                    return '#333333';      // Dark gray - Low income
                case 'Moderate':
                    return '#666666';     // Medium-dark gray - Moderate income
                case 'Middle':
                    return '#999999';     // Medium gray - Middle income
                case 'Upper':
                    return '#cccccc';     // Light gray - Upper income
                default:
                    return '#e0e0e0';      // Very light gray - Unknown
            }
        }
        
        // Get gray shade for minority category (darker = higher minority percentage quartile)
        function getMinorityColor(category) {
            switch(category) {
                case 'Q4 (Highest 25%)':
                    return '#1a1a1a';      // Very dark gray - Highest quartile
                case 'Q3 (50-75%)':
                    return '#666666';      // Medium-dark gray - Third quartile
                case 'Q2 (25-50%)':
                    return '#999999';      // Medium gray - Second quartile
                case 'Q1 (Lowest 25%)':
                    return '#cccccc';      // Light gray - Lowest quartile
                // Legacy support for old categories
                case 'Very High':
                    return '#1a1a1a';
                case 'High':
                    return '#333333';
                case 'Above Average':
                    return '#666666';
                case 'Average':
                    return '#999999';
                case 'Below Average':
                    return '#cccccc';
                default:
                    return '#e0e0e0';      // Very light gray - Unknown
            }
        }
        
        // Get fill color expression for income layer (Mapbox GL JS style)
        function getIncomeColorExpression() {
            return [
                'match',
                ['get', 'income_category'],
                'Low', '#333333',
                'Moderate', '#666666',
                'Middle', '#999999',
                'Upper', '#cccccc',
                '#e0e0e0' // default
            ];
        }
        
        // Get fill color expression for minority layer (Mapbox GL JS style)
        function getMinorityColorExpression() {
            return [
                'match',
                ['get', 'minority_category'],
                'Q4 (Highest 25%)', '#1a1a1a',
                'Q3 (50-75%)', '#666666',
                'Q2 (25-50%)', '#999999',
                'Q1 (Lowest 25%)', '#cccccc',
                'Very High', '#1a1a1a',
                'High', '#333333',
                'Above Average', '#666666',
                'Average', '#999999',
                'Below Average', '#cccccc',
                '#e0e0e0' // default
            ];
        }
        
        // Load income layer for one or more states, merge features, render as single layer
        async function loadIncomeLayerByStates(stateFipsList) {
            if (!branchMap) { initMap(); return; }
            if (incomeLayerAbortController) incomeLayerAbortController.abort();
            incomeLayerAbortController = new AbortController();
            const signal = incomeLayerAbortController.signal;

            removeSourceAndLayers('income-tracts');
            incomeLayerVisible = false;

            try {
                updateInfoPanel(`Loading census income data for ${stateFipsList.length} state(s)...`);
                const allFeatures = [];
                let totalTracts = 0;

                const fetches = stateFipsList.map(async (fips) => {
                    const url = `${APP_BASE_URL}/api/census-tracts-by-state/${fips}?income=true&minority=false`;
                    const resp = await fetch(url, { signal });
                    if (!resp.ok) { console.warn(`Census state ${fips} failed: ${resp.status}`); return; }
                    const data = await resp.json();
                    if (data.success && data.geojson && data.geojson.features) {
                        allFeatures.push(...data.geojson.features);
                        totalTracts += data.tract_count || data.geojson.features.length;
                    }
                });
                await Promise.all(fetches);

                if (allFeatures.length === 0) {
                    updateInfoPanel('No census income data available for this area.');
                    return;
                }

                const mergedGeojson = { type: 'FeatureCollection', features: allFeatures };

                branchMap.addSource('income-tracts', { type: 'geojson', data: mergedGeojson });

                const firstBankLayer = selectedBanks.length > 0 && selectedBanks[0]._layerIds.length > 1
                    ? selectedBanks[0]._layerIds[1] : undefined;
                const beforeLayer = branchMap.getLayer('gray-all-banks-fill') ? 'gray-all-banks-fill' : firstBankLayer;

                branchMap.addLayer({
                    id: 'income-tracts-fill', type: 'fill', source: 'income-tracts',
                    paint: { 'fill-color': getIncomeColorExpression(), 'fill-opacity': 0.5 }
                }, beforeLayer);

                branchMap.addLayer({
                    id: 'income-tracts-outline', type: 'line', source: 'income-tracts',
                    paint: { 'line-color': '#666666', 'line-width': 1, 'line-opacity': 0.6 }
                }, beforeLayer);

                incomeLayerVisible = true;

                branchMap.on('click', 'income-tracts-fill', function(e) {
                    if (!e.features || e.features.length === 0) return;
                    const props = e.features[0].properties;
                    const formatIncome = (val) => val ? '$' + Math.round(parseFloat(val)).toLocaleString('en-US') : 'N/A';
                    let baselineLabel = props.baseline_type === 'cbsa' ? 'Metro Area Median' : (props.baseline_type === 'state' ? 'State Median' : 'County Median');
                    new mapboxgl.Popup({ maxWidth: '280px' })
                        .setLngLat(e.lngLat)
                        .setHTML(`<div style="min-width:200px;">
                            <strong>${props.NAME || 'Census Tract'}</strong><br><hr style="margin:8px 0;">
                            <strong>Income Category:</strong> ${props.income_category || 'Unknown'}<br>
                            <strong>Tract Median Family Income:</strong> ${formatIncome(props.median_family_income)}<br>
                            <strong>${baselineLabel}:</strong> ${formatIncome(props.baseline_median_income)}<br>
                            ${props.income_ratio ? `<strong>Ratio:</strong> ${parseFloat(props.income_ratio).toFixed(2)}x<br>` : ''}
                            <hr style="margin:8px 0;">
                            <small style="color:#666;">Categories: Low (≤50%), Moderate (≤80%), Middle (≤120%), Upper (>120%)</small>
                        </div>`)
                        .addTo(branchMap);
                });

                branchMap.on('mouseenter', 'income-tracts-fill', () => branchMap.getCanvas().style.cursor = 'pointer');
                branchMap.on('mouseleave', 'income-tracts-fill', () => branchMap.getCanvas().style.cursor = '');

                updateInfoPanel(`Loaded income data for ${totalTracts} census tracts across ${stateFipsList.length} state(s).`);
            } catch (error) {
                if (error.name === 'AbortError') return;
                console.error('Error loading income layer by state:', error);
                updateInfoPanel(`Error loading income data: ${error.message || error}`);
            }
        }

        // Load minority layer for one or more states, merge features, render as single layer
        async function loadMinorityLayerByStates(stateFipsList) {
            if (!branchMap) { initMap(); return; }
            if (minorityLayerAbortController) minorityLayerAbortController.abort();
            minorityLayerAbortController = new AbortController();
            const signal = minorityLayerAbortController.signal;

            removeSourceAndLayers('minority-tracts');
            minorityLayerVisible = false;

            try {
                updateInfoPanel(`Loading census minority data for ${stateFipsList.length} state(s)...`);
                const allFeatures = [];
                let totalTracts = 0;

                const fetches = stateFipsList.map(async (fips) => {
                    const url = `${APP_BASE_URL}/api/census-tracts-by-state/${fips}?income=false&minority=true`;
                    const resp = await fetch(url, { signal });
                    if (!resp.ok) { console.warn(`Census state ${fips} failed: ${resp.status}`); return; }
                    const data = await resp.json();
                    if (data.success && data.geojson && data.geojson.features) {
                        allFeatures.push(...data.geojson.features);
                        totalTracts += data.tract_count || data.geojson.features.length;
                    }
                });
                await Promise.all(fetches);

                if (allFeatures.length === 0) {
                    updateInfoPanel('No census minority data available for this area.');
                    return;
                }

                const mergedGeojson = { type: 'FeatureCollection', features: allFeatures };

                branchMap.addSource('minority-tracts', { type: 'geojson', data: mergedGeojson });

                const firstBankLayer = selectedBanks.length > 0 && selectedBanks[0]._layerIds.length > 1
                    ? selectedBanks[0]._layerIds[1] : undefined;
                const beforeLayer = branchMap.getLayer('gray-all-banks-fill') ? 'gray-all-banks-fill' : firstBankLayer;

                branchMap.addLayer({
                    id: 'minority-tracts-fill', type: 'fill', source: 'minority-tracts',
                    paint: { 'fill-color': getMinorityColorExpression(), 'fill-opacity': 0.5 }
                }, beforeLayer);

                branchMap.addLayer({
                    id: 'minority-tracts-outline', type: 'line', source: 'minority-tracts',
                    paint: { 'line-color': '#666666', 'line-width': 1, 'line-opacity': 0.6 }
                }, beforeLayer);

                minorityLayerVisible = true;

                branchMap.on('click', 'minority-tracts-fill', function(e) {
                    if (!e.features || e.features.length === 0) return;
                    const props = e.features[0].properties;
                    const pct = props.minority_percentage != null ? parseFloat(props.minority_percentage).toFixed(1) + '%' : 'N/A';
                    const pop = props.total_population ? Math.round(parseFloat(props.total_population)).toLocaleString() : 'N/A';
                    new mapboxgl.Popup({ maxWidth: '280px' })
                        .setLngLat(e.lngLat)
                        .setHTML(`<div style="min-width:200px;">
                            <strong>${props.NAME || 'Census Tract'}</strong><br><hr style="margin:8px 0;">
                            <strong>Minority Category:</strong> ${props.minority_category || 'Unknown'}<br>
                            <strong>Minority Population:</strong> ${pct}<br>
                            <strong>Total Population:</strong> ${pop}<br>
                            <hr style="margin:8px 0;">
                            <small style="color:#666;">Based on quartile distribution across state</small>
                        </div>`)
                        .addTo(branchMap);
                });

                branchMap.on('mouseenter', 'minority-tracts-fill', () => branchMap.getCanvas().style.cursor = 'pointer');
                branchMap.on('mouseleave', 'minority-tracts-fill', () => branchMap.getCanvas().style.cursor = '');

                updateInfoPanel(`Loaded minority data for ${totalTracts} census tracts across ${stateFipsList.length} state(s).`);
            } catch (error) {
                if (error.name === 'AbortError') return;
                console.error('Error loading minority layer by state:', error);
                updateInfoPanel(`Error loading minority data: ${error.message || error}`);
            }
        }

        // Legacy: Load and display income layer using Mapbox GL JS
        async function loadIncomeLayer(county) {
            if (!branchMap) {
                initMap();
                return;
            }

            // Cancel any previous in-flight request
            if (incomeLayerAbortController) {
                incomeLayerAbortController.abort();
            }
            incomeLayerAbortController = new AbortController();
            const signal = incomeLayerAbortController.signal;

            // Remove existing income layer
            removeSourceAndLayers('income-tracts');
            incomeLayerVisible = false;

            try {
                updateInfoPanel('Loading census tract income data...');
                console.log('Loading income layer for county:', county);

                const url = `${APP_BASE_URL}/api/census-tracts/${encodeURIComponent(county)}?income=true&minority=false`;
                console.log('Fetching from URL:', url);

                const response = await fetch(url, { signal });
                console.log('Response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        console.error('API error response:', errorData);
                        errorMessage = errorData.error || errorData.message || errorMessage;
                    } catch (jsonError) {
                        // Response is not JSON, try to get text
                        try {
                            const errorText = await response.text();
                            console.error('API error response (text):', errorText);
                            errorMessage = errorText || errorMessage;
                        } catch (textError) {
                            console.error('Could not parse error response:', textError);
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                let data;
                try {
                    data = await response.json();
                    console.log('API response data:', data);
                } catch (jsonError) {
                    console.error('Failed to parse JSON response:', jsonError);
                    throw new Error('Invalid JSON response from server');
                }
                
                if (!data.success) {
                    console.error('API returned success=false:', data);
                    throw new Error(data.error || data.message || 'Failed to load census tract data');
                }
                
                if (!data.geojson || !data.geojson.features) {
                    console.error('Invalid GeoJSON data:', data);
                    throw new Error('Invalid GeoJSON data received from server');
                }
                
                console.log('Creating GeoJSON layer with', data.geojson.features.length, 'features');
                
                // Add GeoJSON source
                branchMap.addSource('income-tracts', {
                    type: 'geojson',
                    data: data.geojson
                });
                
                // Find the first bank marker layer to insert census layers below it
                const firstBankLayer = selectedBanks.length > 0 && selectedBanks[0]._layerIds.length > 1
                    ? selectedBanks[0]._layerIds[1] : undefined;
                const grayLayer = branchMap.getLayer('gray-all-banks-fill') ? 'gray-all-banks-fill' : firstBankLayer;

                // Add fill layer (below bank markers)
                branchMap.addLayer({
                    id: 'income-tracts-fill',
                    type: 'fill',
                    source: 'income-tracts',
                    paint: {
                        'fill-color': getIncomeColorExpression(),
                        'fill-opacity': 0.5
                    }
                }, grayLayer);

                // Add outline layer (below bank markers)
                branchMap.addLayer({
                    id: 'income-tracts-outline',
                    type: 'line',
                    source: 'income-tracts',
                    paint: {
                        'line-color': '#666666',
                        'line-width': 1,
                        'line-opacity': 0.6
                    }
                }, grayLayer);
                
                incomeLayerVisible = true;
                
                // Add click handler for popups
                branchMap.on('click', 'income-tracts-fill', function(e) {
                    if (!e.features || e.features.length === 0) return;
                    
                    const props = e.features[0].properties;
                    const income = props.median_family_income;
                    const category = props.income_category || 'Unknown';
                    const baselineIncome = props.baseline_median_income || props.cbsa_median_income;
                    const baselineType = props.baseline_type;
                    const ratio = props.income_ratio;
                    
                    const formatIncome = (val) => {
                        if (!val) return 'N/A';
                        return '$' + Math.round(parseFloat(val)).toLocaleString('en-US');
                    };
                    
                    let baselineLabel = 'County Median';
                    if (baselineType === 'state') baselineLabel = 'State Median';
                    else if (baselineType === 'cbsa') baselineLabel = 'Metro Area Median';
                    
                    const popupContent = `
                        <div style="min-width: 200px;">
                            <strong>${props.NAME || 'Census Tract'}</strong><br>
                            <hr style="margin: 8px 0;">
                            <strong>Income Category:</strong> ${category}<br>
                            <strong>Tract Median Family Income:</strong> ${formatIncome(income)}<br>
                            <strong>${baselineLabel}:</strong> ${formatIncome(baselineIncome)}<br>
                            ${ratio ? `<strong>Ratio:</strong> ${parseFloat(ratio).toFixed(2)}x county average<br>` : ''}
                            <hr style="margin: 8px 0;">
                            <small style="color: #666;">
                                Categories: Low (≤50%), Moderate (≤80%), Middle (≤120%), Upper (>120%)
                            </small>
                        </div>
                    `;
                    
                    new mapboxgl.Popup({ maxWidth: '280px' })
                        .setLngLat(e.lngLat)
                        .setHTML(popupContent)
                        .addTo(branchMap);
                });
                
                // Change cursor on hover
                branchMap.on('mouseenter', 'income-tracts-fill', function() {
                    branchMap.getCanvas().style.cursor = 'pointer';
                });
                branchMap.on('mouseleave', 'income-tracts-fill', function() {
                    branchMap.getCanvas().style.cursor = '';
                });
                
                console.log('Income layer added to map (no zoom change)');
                
                const countyIncome = data.baseline_median_family_income;
                const countyIncomeStr = (countyIncome !== null && countyIncome !== undefined) ? '$' + Math.round(countyIncome).toLocaleString() : 'N/A';
                updateInfoPanel(`Loaded income data for ${data.tract_count} census tracts. County median: ${countyIncomeStr}`);
                
            } catch (error) {
                // Don't show error for aborted requests (user switched counties)
                if (error.name === 'AbortError') {
                    console.log('Income layer request was cancelled');
                    return;
                }
                console.error('Error loading income layer:', error);
                const errorMessage = error.message || error.toString() || 'Unknown error occurred';
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name,
                    error: error
                });
                updateInfoPanel(`Error loading income data: ${errorMessage}`);
            }
        }

        // Load and display minority layer using Mapbox GL JS
        async function loadMinorityLayer(county) {
            if (!branchMap) {
                initMap();
                return;
            }

            // Cancel any previous in-flight request
            if (minorityLayerAbortController) {
                minorityLayerAbortController.abort();
            }
            minorityLayerAbortController = new AbortController();
            const signal = minorityLayerAbortController.signal;

            // Remove existing minority layer
            removeSourceAndLayers('minority-tracts');
            minorityLayerVisible = false;

            try {
                updateInfoPanel('Loading census tract minority population data...');

                const response = await fetch(`${APP_BASE_URL}/api/census-tracts/${encodeURIComponent(county)}?income=false&minority=true`, { signal });
                
                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorData.message || errorMessage;
                    } catch (jsonError) {
                        try {
                            const errorText = await response.text();
                            errorMessage = errorText || errorMessage;
                        } catch (textError) {
                            console.error('Could not parse error response:', textError);
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                let data;
                try {
                    data = await response.json();
                } catch (jsonError) {
                    console.error('Failed to parse JSON response:', jsonError);
                    throw new Error('Invalid JSON response from server');
                }
                
                if (!data.success) {
                    throw new Error(data.error || data.message || 'Failed to load census tract data');
                }
                
                // Add GeoJSON source
                branchMap.addSource('minority-tracts', {
                    type: 'geojson',
                    data: data.geojson
                });
                
                // Find the first bank marker layer to insert census layers below it
                const firstBankLayer = selectedBanks.length > 0 && selectedBanks[0]._layerIds.length > 1
                    ? selectedBanks[0]._layerIds[1] : undefined;
                const grayLayer = branchMap.getLayer('gray-all-banks-fill') ? 'gray-all-banks-fill' : firstBankLayer;

                // Add fill layer (below bank markers)
                branchMap.addLayer({
                    id: 'minority-tracts-fill',
                    type: 'fill',
                    source: 'minority-tracts',
                    paint: {
                        'fill-color': getMinorityColorExpression(),
                        'fill-opacity': 0.5
                    }
                }, grayLayer);

                // Add outline layer (below bank markers)
                branchMap.addLayer({
                    id: 'minority-tracts-outline',
                    type: 'line',
                    source: 'minority-tracts',
                    paint: {
                        'line-color': '#666666',
                        'line-width': 1,
                        'line-opacity': 0.6
                    }
                }, grayLayer);
                
                minorityLayerVisible = true;
                
                // Add click handler for popups
                branchMap.on('click', 'minority-tracts-fill', function(e) {
                    if (!e.features || e.features.length === 0) return;
                    
                    const props = e.features[0].properties;
                    const minorityPct = props.minority_percentage;
                    const category = props.minority_category || 'Unknown';
                    const countyMinorityPct = props.county_minority_percentage;
                    const ratio = props.minority_ratio;
                    const totalPop = props.total_population;
                    const minorityPop = props.minority_population;
                    
                    const formatNumber = (val) => {
                        if (!val && val !== 0) return 'N/A';
                        return Math.round(parseFloat(val)).toLocaleString('en-US');
                    };
                    
                    const formatPercent = (val) => {
                        if (val === null || val === undefined || (val !== 0 && !val)) return 'N/A';
                        try {
                            return parseFloat(val).toFixed(1) + '%';
                        } catch (e) {
                            return 'N/A';
                        }
                    };
                    
                    const popupContent = `
                        <div style="min-width: 200px;">
                            <strong>${props.NAME || 'Census Tract'}</strong><br>
                            <hr style="margin: 8px 0;">
                            <strong>Minority Category:</strong> ${category}<br>
                            <strong>Tract Minority %:</strong> ${formatPercent(minorityPct)}<br>
                            <strong>County Minority %:</strong> ${formatPercent(countyMinorityPct)}<br>
                            ${ratio !== null && ratio !== undefined ? `<strong>Ratio:</strong> ${parseFloat(ratio).toFixed(2)}x county average<br>` : ''}
                            <hr style="margin: 8px 0;">
                            <strong>Total Population:</strong> ${formatNumber(totalPop)}<br>
                            <strong>Minority Population:</strong> ${formatNumber(minorityPop)}<br>
                            <hr style="margin: 8px 0;">
                            <small style="color: #666;">
                                Minority = Non-Hispanic White excluded<br>
                                ${category.startsWith('Q') ? 'Categories based on quartiles of minority % within county' : 'Categories based on ratio to county average'}
                            </small>
                        </div>
                    `;
                    
                    new mapboxgl.Popup({ maxWidth: '280px' })
                        .setLngLat(e.lngLat)
                        .setHTML(popupContent)
                        .addTo(branchMap);
                });
                
                // Change cursor on hover
                branchMap.on('mouseenter', 'minority-tracts-fill', function() {
                    branchMap.getCanvas().style.cursor = 'pointer';
                });
                branchMap.on('mouseleave', 'minority-tracts-fill', function() {
                    branchMap.getCanvas().style.cursor = '';
                });
                
                const countyMinorityPct = data.county_minority_percentage;
                const countyMinorityStr = (countyMinorityPct !== null && countyMinorityPct !== undefined) ? countyMinorityPct.toFixed(1) + '%' : 'N/A';
                updateInfoPanel(`Loaded minority data for ${data.tract_count} census tracts. County: ${countyMinorityStr} minority`);
                
            } catch (error) {
                // Don't show error for aborted requests (user switched counties)
                if (error.name === 'AbortError') {
                    console.log('Minority layer request was cancelled');
                    return;
                }
                console.error('Error loading minority layer:', error);
                const errorMessage = error.message || error.toString() || 'Unknown error occurred';
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name,
                    error: error
                });
                updateInfoPanel(`Error loading minority data: ${errorMessage}`);
            }
        }

        // Toggle income layer visibility
        function toggleIncomeLayer(county) {
            if (incomeLayerVisible && branchMap.getLayer('income-tracts-fill')) {
                branchMap.setLayoutProperty('income-tracts-fill', 'visibility', 'none');
                branchMap.setLayoutProperty('income-tracts-outline', 'visibility', 'none');
                incomeLayerVisible = false;
                updateInfoPanel('Income layer hidden');
            } else if (branchMap.getLayer('income-tracts-fill')) {
                branchMap.setLayoutProperty('income-tracts-fill', 'visibility', 'visible');
                branchMap.setLayoutProperty('income-tracts-outline', 'visibility', 'visible');
                incomeLayerVisible = true;
                updateInfoPanel('Income layer shown');
            } else if (county) {
                loadIncomeLayer(county);
            }
        }
        
        // Zoom map to state using Mapbox GL JS
        function zoomToState(stateCode) {
            if (!branchMap) {
                initMap();
                return;
            }
            
            if (stateCenters[stateCode]) {
                const center = stateCenters[stateCode];
                branchMap.flyTo({
                    center: [center.lng, center.lat], // [lng, lat] for Mapbox
                    zoom: center.zoom
                });
                console.log('Zoomed to state:', stateCode, center);
            } else {
                // Default to US center if state not found
                branchMap.flyTo({
                    center: [-98.5, 38.0],
                    zoom: 3
                });
            }
        }
        
        // Format deposits for display
        function formatDeposits(deposits) {
            if (!deposits && deposits !== 0) return 'N/A';
            return '$' + deposits.toLocaleString('en-US');
        }
        
        // Export map and data as multi-sheet Excel workbook
        async function exportMapAndData() {
            if (!branchMap) {
                alert('No map loaded.');
                return;
            }

            try {
                updateInfoPanel('Loading data for export...');

                // Ensure both SOD branches AND OSCR events are loaded for each selected bank
                const loadPromises = [];
                for (const bank of selectedBanks) {
                    if (bank.branches.length === 0) {
                        loadPromises.push(loadBankBranches(bank));
                    }
                    if (bank.oscrEvents.length === 0) {
                        loadPromises.push(loadBankOSCREvents(bank));
                    }
                }

                // For "Show All Banks" mode, load both views for current bounds
                let allBanksBranches = [];
                let allBanksOscrData = [];
                if (showAllBanksActive) {
                    const bounds = branchMap.getBounds();
                    const sw = bounds.getSouthWest(), ne = bounds.getNorthEast();
                    const latPad = (ne.lat - sw.lat) * 0.1, lngPad = (ne.lng - sw.lng) * 0.1;
                    const params = `sw_lat=${sw.lat - latPad}&sw_lng=${sw.lng - lngPad}&ne_lat=${ne.lat + latPad}&ne_lng=${ne.lng + lngPad}`;

                    // Load SOD branches for bounds
                    loadPromises.push(
                        fetch(`${APP_BASE_URL}/api/branches-in-bounds?${params}&year=2025`)
                            .then(r => r.json())
                            .then(d => { if (d.success) allBanksBranches = d.branches || []; })
                            .catch(() => {})
                    );
                    // Load OSCR events for bounds
                    const dateRange = getOSCRDateRange();
                    loadPromises.push(
                        fetch(`${APP_BASE_URL}/api/oscr-events-in-bounds?${params}&start_date=${dateRange.start}&end_date=${dateRange.end}`)
                            .then(r => r.json())
                            .then(d => { if (d.success) allBanksOscrData = d.events || []; })
                            .catch(() => {})
                    );
                }

                if (loadPromises.length > 0) {
                    await Promise.all(loadPromises);
                }

                // Collect all data
                let allBranches = [];
                let allOscrEvents = [];
                selectedBanks.forEach(b => {
                    allBranches.push(...b.branches);
                    allOscrEvents.push(...b.oscrEvents);
                });
                // Merge "Show All Banks" data
                if (showAllBanksActive) {
                    allBranches.push(...allBanksBranches);
                    allOscrEvents.push(...allBanksOscrData);
                }

                if (allBranches.length === 0 && allOscrEvents.length === 0) {
                    alert('No data to export. Please load branch data or OSCR events first.');
                    return;
                }

                // Filter to drawn polygon area if active
                if (activeDrawFilter) {
                    const polyGeom = activeDrawFilter.type === 'Feature' ? activeDrawFilter : { type: 'Feature', geometry: activeDrawFilter, properties: {} };
                    allBranches = allBranches.filter(b => {
                        const lat = parseFloat(b.latitude), lng = parseFloat(b.longitude);
                        return !isNaN(lat) && !isNaN(lng) && turf.booleanPointInPolygon(turf.point([lng, lat]), polyGeom);
                    });
                    allOscrEvents = allOscrEvents.filter(e => {
                        const lat = parseFloat(e.latitude), lng = parseFloat(e.longitude);
                        return !isNaN(lat) && !isNaN(lng) && turf.booleanPointInPolygon(turf.point([lng, lat]), polyGeom);
                    });
                }

                updateInfoPanel('Exporting Excel workbook...');

                // Filename
                const bankNames = selectedBanks.map(b => b.name).join('_') || (showAllBanksActive ? 'AllBanks' : 'Unknown');
                const contextSlug = bankNames.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 80);
                const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const filename = `BranchMapper_${contextSlug}_${timestamp}.xlsx`;

                const wb = XLSX.utils.book_new();

                // --- Sheet 1: Notes ---
                const notesData = [
                    ['BranchMapper Export'],
                    [''],
                    ['DATA SOURCES'],
                    ['FDIC Summary of Deposits (SOD)', 'Annual survey of branch-level deposit data for all FDIC-insured institutions. Published June 30 each year.'],
                    ['FDIC OSCR (Office of Supervisory Changes Report)', 'Records branch openings (711/713) and closings (721/722) reported to the FDIC.'],
                    ['Census ACS Tract Classifications', 'Tract-level income and demographic data from the American Community Survey, used for LMI and majority-minority flags.'],
                    [''],
                    ['REPORT CONFIGURATION'],
                    ['Selected Banks', selectedBanks.map(b => b.name).join(', ')],
                    ['SOD Year', '2025'],
                    ['OSCR Date Range', (() => { try { const dr = getOSCRDateRange(); return dr.start + ' to ' + dr.end; } catch(e) { return 'N/A'; } })()],
                    ['Export Timestamp', new Date().toISOString()],
                    ['Area Filter', activeDrawFilter ? 'Yes — exported data filtered to drawn polygon' : 'None — all branches/events exported'],
                    ['Total SOD Branches', String(allBranches.length)],
                    ['Total OSCR Events', String(allOscrEvents.length)],
                    [''],
                    ['INCOME CLASSIFICATIONS'],
                    ['Low Income', 'Tract median family income < 50% of area median'],
                    ['Moderate Income', 'Tract median family income 50-79% of area median'],
                    ['Middle Income', 'Tract median family income 80-119% of area median'],
                    ['Upper Income', 'Tract median family income >= 120% of area median'],
                    ['LMI Tract', 'Low or Moderate income tract (< 80% of area median family income)'],
                    [''],
                    ['MINORITY CLASSIFICATIONS'],
                    ['Majority-Minority Tract', 'Census tract where > 50% of the population identifies as a racial or ethnic minority'],
                    [''],
                    ['OSCR CHANGE CODES'],
                    ['711', 'Branch opening (new)'],
                    ['713', 'Branch opening (relocation — new site of a relocated branch)'],
                    ['721', 'Branch closing (permanent)'],
                    ['722', 'Branch closing (relocation — former site of a relocated branch)'],
                    [''],
                    ['SERVICE TYPES'],
                    ['11', 'Full Service, brick and mortar office'],
                    ['12', 'Full Service, retail office'],
                    ['13', 'Full Service, cyber office'],
                    ['21', 'Limited Service, administrative office'],
                    ['22', 'Limited Service, military facility'],
                    ['23', 'Limited Service, drive-through facility'],
                    ['24', 'Limited Service, loan production office'],
                    ['25', 'Limited Service, consumer credit office'],
                    ['26', 'Limited Service, contractual office'],
                    ['27', 'Limited Service, messenger office'],
                    ['28', 'Limited Service, retail office'],
                    ['29', 'Limited Service, mobile/seasonal office'],
                    ['30', 'Limited Service, trust office'],
                    [''],
                    ['RELOCATION INFERENCE'],
                    ['Method', 'Relocations are inferred by matching a closing and an opening for the same CERT within 90 days and 2 miles, at different addresses.']
                ];
                const wsNotes = XLSX.utils.aoa_to_sheet(notesData);
                wsNotes['!cols'] = [{ wch: 35 }, { wch: 90 }];
                XLSX.utils.book_append_sheet(wb, wsNotes, 'Notes');

                // --- Sheet 2: Bank Branches ---
                // Deduplicate
                const seenBranches = new Set();
                const uniqueBranches = [];
                allBranches.forEach(branch => {
                    const key = [
                        (branch.bank_name || '').toLowerCase().trim(),
                        (branch.branch_name || '').toLowerCase().trim(),
                        branch.latitude || '',
                        branch.longitude || ''
                    ].join('|');
                    if (!seenBranches.has(key)) {
                        seenBranches.add(key);
                        uniqueBranches.push(branch);
                    }
                });

                // Sort by bank name → state → city
                uniqueBranches.sort((a, b) => {
                    const cmp1 = (a.bank_name || '').localeCompare(b.bank_name || '');
                    if (cmp1 !== 0) return cmp1;
                    const cmp2 = (a.state_abbrv || a.state || '').localeCompare(b.state_abbrv || b.state || '');
                    if (cmp2 !== 0) return cmp2;
                    return (a.city || '').localeCompare(b.city || '');
                });

                const branchHeaders = [
                    'Bank Name', 'Branch Name', 'Address', 'City', 'State', 'ZIP',
                    'County', 'Latitude', 'Longitude', 'Total Deposits ($)',
                    'Assets ($000s)', 'Service Type', 'RSSD', 'UNINUMBR',
                    'LMI Tract', 'Majority-Minority Tract'
                ];
                const branchRows = uniqueBranches.map(b => [
                    b.bank_name || '',
                    b.branch_name || '',
                    b.address || '',
                    b.city || '',
                    b.state_abbrv || b.state || '',
                    b.zip || '',
                    b.county || '',
                    b.latitude != null ? Number(b.latitude) : '',
                    b.longitude != null ? Number(b.longitude) : '',
                    b.total_deposits != null ? Number(b.total_deposits) : '',
                    b.assets_000s != null ? Number(b.assets_000s) : '',
                    b.service_type || '',
                    b.rssd || '',
                    b.uninumbr || '',
                    b.lmict ? 'Yes' : 'No',
                    b.mmct ? 'Yes' : 'No'
                ]);

                const wsBranches = XLSX.utils.aoa_to_sheet([branchHeaders, ...branchRows]);
                wsBranches['!cols'] = [
                    { wch: 30 }, { wch: 30 }, { wch: 35 }, { wch: 18 }, { wch: 6 }, { wch: 10 },
                    { wch: 20 }, { wch: 12 }, { wch: 12 }, { wch: 18 },
                    { wch: 15 }, { wch: 14 }, { wch: 12 }, { wch: 12 },
                    { wch: 10 }, { wch: 22 }
                ];
                XLSX.utils.book_append_sheet(wb, wsBranches, 'Bank Branches');

                // --- Sheet 3: Changes (OSCR Events) ---
                const allEvents = allOscrEvents;

                const eventHeaders = [
                    'Institution', 'CERT', 'Branch Name', 'Event Type', 'Is Relocation',
                    'Change Code', 'Effective Date', 'Processed Date',
                    'Address', 'City', 'State', 'ZIP', 'County',
                    'Latitude', 'Longitude', 'Service Type', 'Bank Class',
                    'Former Branch Name', 'Former Address', 'Former City', 'Former State', 'Former ZIP',
                    'Former Latitude', 'Former Longitude',
                    'Relocation Partner Address', 'Relocation Distance (mi)'
                ];

                let eventRows;
                if (allEvents.length > 0) {
                    eventRows = allEvents.map(e => [
                        e.institution || '',
                        e.cert || '',
                        e.branch_name || '',
                        e.display_type === 'opening' ? 'Opening' : e.display_type === 'closing' ? 'Closing' : (e.display_type || ''),
                        e.is_relocation ? 'Yes' : 'No',
                        e.changecode || '',
                        e.effective_date || '',
                        e.processed_date || '',
                        e.address || '',
                        e.city || '',
                        e.state || '',
                        e.zip || '',
                        e.county || '',
                        e.latitude != null ? Number(e.latitude) : '',
                        e.longitude != null ? Number(e.longitude) : '',
                        e.service_type || '',
                        e.bank_class || '',
                        e.frm_branch_name || '',
                        e.frm_address || '',
                        e.frm_city || '',
                        e.frm_state || '',
                        e.frm_zip || '',
                        e.frm_latitude != null ? Number(e.frm_latitude) : '',
                        e.frm_longitude != null ? Number(e.frm_longitude) : '',
                        e.relocation_pair_address || '',
                        e.relocation_distance_miles != null ? Number(e.relocation_distance_miles) : ''
                    ]);
                } else {
                    eventRows = [['No OSCR events loaded. Switch to OSCR view mode and load events for selected banks, then re-export.']];
                }

                const wsChanges = XLSX.utils.aoa_to_sheet([eventHeaders, ...eventRows]);
                wsChanges['!cols'] = [
                    { wch: 30 }, { wch: 10 }, { wch: 30 }, { wch: 12 }, { wch: 14 },
                    { wch: 12 }, { wch: 14 }, { wch: 14 },
                    { wch: 35 }, { wch: 18 }, { wch: 6 }, { wch: 10 }, { wch: 20 },
                    { wch: 12 }, { wch: 12 }, { wch: 14 }, { wch: 12 },
                    { wch: 25 }, { wch: 35 }, { wch: 18 }, { wch: 6 }, { wch: 10 },
                    { wch: 12 }, { wch: 12 },
                    { wch: 40 }, { wch: 20 }
                ];
                XLSX.utils.book_append_sheet(wb, wsChanges, 'Changes');

                // Write and download
                XLSX.writeFile(wb, filename);

                console.log(`Export: ${uniqueBranches.length} branches, ${allEvents.length} OSCR events`);
                updateInfoPanel(`Export complete! Downloaded ${filename}`);

            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting data: ' + error.message);
                updateInfoPanel('Export failed. Please try again.');
            }
        }
        
        // Helper function to escape CSV values
        function escapeCSV(value) {
            if (value === null || value === undefined) return '';
            const stringValue = String(value);
            // If value contains comma, quote, or newline, wrap in quotes and escape quotes
            if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                return '"' + stringValue.replace(/"/g, '""') + '"';
            }
            return stringValue;
        }
        
        // Update info panel
        function updateInfoPanel(message) {
            const panel = document.getElementById('infoPanel');
            panel.innerHTML = `<strong>Status:</strong> ${message}`;
        }
        
        
        // Setup HTML tooltips for feature cards
        function setupFeatureCardTooltips() {
            const featureCards = document.querySelectorAll('.sidebar .feature-card[data-tooltip]');
            featureCards.forEach(card => {
                const tooltipText = card.getAttribute('data-tooltip');
                if (!tooltipText) return;
                
                // Create tooltip element
                const tooltip = document.createElement('div');
                tooltip.className = 'feature-card-tooltip';
                tooltip.innerHTML = tooltipText;
                tooltip.style.cssText = `
                    position: absolute;
                    right: calc(100% + 15px);
                    top: 50%;
                    transform: translateY(-50%);
                    background: white;
                    color: black;
                    padding: 12px 16px;
                    border-radius: 8px;
                    font-size: 0.9rem;
                    line-height: 1.5;
                    min-width: 250px;
                    max-width: 350px;
                    width: fit-content;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                    opacity: 0;
                    visibility: hidden;
                    pointer-events: none;
                    transition: opacity 0.2s ease, visibility 0.2s ease;
                    z-index: 100000;
                    text-align: left;
                    word-wrap: break-word;
                    border: 2px solid black;
                    box-sizing: border-box;
                `;
                
                // Create arrow
                const arrow = document.createElement('div');
                arrow.style.cssText = `
                    position: absolute;
                    right: -8px;
                    top: 50%;
                    transform: translateY(-50%);
                    width: 0;
                    height: 0;
                    border-top: 6px solid transparent;
                    border-bottom: 6px solid transparent;
                    border-left: 6px solid white;
                    z-index: 1;
                `;
                
                // Create arrow border
                const arrowBorder = document.createElement('div');
                arrowBorder.style.cssText = `
                    position: absolute;
                    right: -8px;
                    top: 50%;
                    transform: translateY(-50%);
                    width: 0;
                    height: 0;
                    border-top: 7px solid transparent;
                    border-bottom: 7px solid transparent;
                    border-left: 7px solid black;
                    z-index: 0;
                `;
                tooltip.appendChild(arrowBorder);
                tooltip.appendChild(arrow);
                
                card.appendChild(tooltip);
                
                // Show/hide on hover
                card.addEventListener('mouseenter', function() {
                    tooltip.style.opacity = '1';
                    tooltip.style.visibility = 'visible';
                });
                
                card.addEventListener('mouseleave', function() {
                    tooltip.style.opacity = '0';
                    tooltip.style.visibility = 'hidden';
                });
            });
        }
        
        // Initialize map on page load
        window.addEventListener('DOMContentLoaded', function() {
            setupFeatureCardTooltips();
            initMap();
            initializeBankSearch();

            // OSCR date range: show/hide custom date picker
            const dateRangeSelect = document.getElementById('dateRangeSelect');
            if (dateRangeSelect) {
                dateRangeSelect.addEventListener('change', function() {
                    document.getElementById('customDateRange').style.display =
                        this.value === 'custom' ? 'block' : 'none';
                });
            }

            // OSCR event type filter checkboxes
            const filterOpenings = document.getElementById('filterOpenings');
            const filterClosings = document.getElementById('filterClosings');
            if (filterOpenings) filterOpenings.addEventListener('change', refilterOSCR);
            if (filterClosings) filterClosings.addEventListener('change', refilterOSCR);

            updateInfoPanel('Search a bank to get started.');
        });
    </script>

    <!-- Welcome Modal -->
    <div id="welcomeModal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 9999;
        background: rgba(0,0,0,0.45); display: flex; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 12px; padding: 36px 32px; max-width: 420px; width: 90%;
            box-shadow: 0 8px 30px rgba(0,0,0,0.2); text-align: center;">
            <i class="fas fa-map-marked-alt" style="font-size: 2.5rem; color: var(--ncrc-primary-blue); margin-bottom: 14px;"></i>
            <h2 style="color: var(--ncrc-dark-blue); margin: 0 0 12px; font-size: 1.3rem;">Welcome to BranchMapper</h2>
            <p style="color: #555; line-height: 1.6; font-size: 0.9rem; margin: 0 0 24px;">
                Zoom in to see all banks in a specific area, or search for a bank in the toolbar to the left to see its national footprint.
            </p>
            <button onclick="document.getElementById('welcomeModal').style.display='none'"
                style="padding: 10px 28px; background: var(--ncrc-primary-blue); color: white; border: none;
                border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 600;">
                Got it
            </button>
        </div>
    </div>

    <!-- Shared Footer -->
    {% set app_name = "BranchMapper" %}
    {% include "shared_footer.html" %}

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-analytics-compat.js"></script>

    <!-- JustData Auth -->
    <script src="/static/js/auth.js"></script>

    <!-- JustData Analytics Event Logging -->
    <script src="/static/js/analytics-events.js"></script>

    {% include 'shared_header_js.html' %}
</body>
</html>

