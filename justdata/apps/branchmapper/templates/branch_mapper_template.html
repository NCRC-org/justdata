<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BranchMapper - Bank Branch Location Map</title>
    <meta name="description" content="Interactive map showing bank branch locations with demographic and deposit data.">
    
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16x16.png">
    <!-- Font Awesome for icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Mapbox GL JS CSS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet" />
    
    <!-- Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <!-- Shared CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    
    <style>
        /* Branch Mapper specific styles - Mobile-first responsive design */

        /* Main container - simple flexbox layout */
        .container {
            display: flex !important;
            flex-direction: column !important;
            max-width: 1400px !important;
            margin: 0 auto !important;
            padding: 15px !important;
            gap: 15px !important;
        }

        /* Controls sidebar - appears above map on all screen sizes */
        .controls-sidebar {
            width: 100% !important;
            max-width: 100% !important;
            order: 1;
        }

        /* Content wrapper with map */
        .content-wrapper {
            width: 100% !important;
            max-width: 100% !important;
            min-width: 0;
            overflow: hidden;
            order: 2;
        }

        .mapper-container {
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            padding: 0;
            box-sizing: border-box;
        }

        .map-container {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        #branchMap {
            width: 100%;
            height: 500px;
            box-sizing: border-box;
            border-radius: 8px;
        }

        /* Desktop layout - side by side */
        @media (min-width: 992px) {
            .container {
                flex-direction: row !important;
                align-items: flex-start !important;
            }

            .controls-sidebar {
                width: 300px !important;
                min-width: 300px !important;
                max-width: 300px !important;
                position: sticky !important;
                top: 20px !important;
                order: 1;
                max-height: calc(100vh - 40px);
                overflow-y: auto;
            }

            .content-wrapper {
                flex: 1 !important;
                order: 2;
            }

            #branchMap {
                height: 600px;
            }
        }

        /* Tablet layout */
        @media (min-width: 768px) and (max-width: 991px) {
            .controls-sidebar {
                display: flex;
                flex-wrap: wrap;
                gap: 15px;
            }

            .controls-sidebar .mapper-controls {
                flex: 1;
                min-width: 280px;
            }

            #branchMap {
                height: 450px;
            }
        }

        /* Mobile layout */
        @media (max-width: 767px) {
            .container {
                padding: 10px !important;
                gap: 10px !important;
            }

            #branchMap {
                height: 350px;
            }

            .mapper-controls {
                padding: 10px !important;
            }

            .control-group label {
                font-size: 0.8rem;
            }

            .control-group select {
                font-size: 0.9rem;
                padding: 8px;
            }

            .map-actions button {
                padding: 10px 12px;
                font-size: 0.85rem;
            }
        }

        /* Hide any right sidebar completely */
        .sidebar:not(.controls-sidebar) {
            display: none !important;
        }
        
        .mapper-controls {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            padding: 12px;
            margin-bottom: 12px;
        }
        
        /* Left sidebar controls - single column layout */
        .sidebar-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        /* Remove the old 3-column grid */
        .controls-grid {
            display: none;
        }
        
        .map-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }
        
        .map-actions button {
            width: 100%;
            padding: 8px 14px;
            background: var(--ncrc-primary-blue);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: background 0.2s;
        }
        
        .map-actions button:hover {
            background: var(--ncrc-dark-blue);
        }
        
        .map-actions button.secondary {
            background: #6c757d;
        }
        
        .map-actions button.secondary:hover {
            background: #5a6268;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group label {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--ncrc-dark-blue);
        }
        
        .control-group select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.85rem;
            background: white;
        }
        
        .control-group select[multiple] {
            min-height: 150px;
            max-height: 200px;
            padding: 6px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 0.85rem;
        }
        
        .control-group select[multiple]:focus {
            border-color: var(--ncrc-primary-blue);
            outline: none;
            box-shadow: 0 0 0 3px rgba(3, 78, 160, 0.1);
        }
        
        .bank-select-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .bank-select-help {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .selected-banks-display {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .selected-bank-tag {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            background: var(--ncrc-light-blue);
            color: var(--ncrc-dark-blue);
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        .selected-bank-tag .remove-btn {
            cursor: pointer;
            color: var(--ncrc-dark-blue);
            font-weight: bold;
            padding: 0 2px;
        }
        
        .selected-bank-tag .remove-btn:hover {
            color: #e82e2e;
        }
        
        .control-group small {
            font-size: 0.7rem;
            color: #666;
            margin-top: 2px;
        }
        
        
        .map-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            padding: 12px;
            margin-bottom: 12px;
        }
        
        #branchMap {
            height: 600px;
            width: 100%;
            border: 2px solid #ddd;
            border-radius: 6px;
        }
        
        .bank-legend {
            margin-top: 8px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            display: none;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 0.85rem;
        }
        
        .bank-legend.active {
            display: flex;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .info-panel {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 8px 12px;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #666;
        }
        
        .info-panel strong {
            color: var(--ncrc-dark-blue);
        }
        
        /* Custom marker popup styles */
        .mapboxgl-popup-content {
            min-width: 200px;
            padding: 12px;
            border-radius: 8px;
        }
        .mapboxgl-popup-close-button {
            font-size: 18px;
            padding: 4px 8px;
        }
        
        .popup-content {
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .popup-content .bank-name-header {
            color: #000;
            font-size: 1.15rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .popup-content .branch-info {
            margin: 5px 0;
        }

        .popup-content .branch-info strong {
            color: var(--ncrc-primary-blue);
        }
        
        .popup-content .branch-tags {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }
        
        .tag {
            display: inline-block;
            padding: 3px 8px;
            background: #e6f2ff;
            color: var(--ncrc-primary-blue);
            border-radius: 4px;
            font-size: 0.8rem;
            margin-right: 5px;
            margin-top: 5px;
        }
        
        .tag.lmi {
            background: #fff3cd;
            color: #856404;
        }
        
        .tag.minority {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .report-problem-btn {
            margin-top: 12px;
            padding: 8px 16px;
            background: #e82e2e;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            text-align: center;
            transition: background 0.2s;
            text-decoration: none;
            display: inline-block;
        }
        
        .report-problem-btn:hover {
            background: #c41e1e;
            color: white;
            text-decoration: none;
        }
        
        .report-problem-btn i {
            margin-right: 6px;
        }
        
        /* Explicitly hide any version text in footer */
        .footer .version-text,
        .footer-bottom .version-text,
        footer .version-text {
            display: none !important;
            visibility: hidden !important;
        }
    </style>
</head>
<body>
    {% set app_name = "BranchMapper" %}{% include "shared_header.html" %}

    <div class="container">
        <!-- Left Controls Sidebar -->
        <aside class="controls-sidebar">
            <div class="mapper-controls">
                <h3 style="margin-bottom: 12px; color: var(--ncrc-dark-blue); font-size: 1rem; border-bottom: 2px solid var(--ncrc-primary-blue); padding-bottom: 8px;">
                    <i class="fas fa-map-marked-alt"></i> Map Controls
                </h3>
                
                <div class="sidebar-controls">
                    <!-- State Dropdown -->
                    <div class="control-group">
                        <label for="stateSelect">
                            <i class="fas fa-map"></i> State
                        </label>
                        <select id="stateSelect">
                            <option value="">Select State</option>
                        </select>
                    </div>
                    
                    <!-- County Dropdown -->
                    <div class="control-group">
                        <label for="countySelect">
                            <i class="fas fa-map-marker-alt"></i> County
                        </label>
                        <select id="countySelect">
                            <option value="">Select County</option>
                        </select>
                    </div>
                    
                    <!-- Census Layer Dropdown -->
                    <div class="control-group">
                        <label for="censusLayerSelect">
                            <i class="fas fa-layer-group"></i> Census Tract Layer
                        </label>
                        <select id="censusLayerSelect">
                            <option value="">None</option>
                            <option value="income">Income Levels</option>
                            <option value="minority">Minority Population</option>
                        </select>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="map-actions">
                        <button onclick="loadMapData()">
                            <i class="fas fa-map"></i> Load Map
                        </button>
                        <button onclick="clearMap()" class="secondary">
                            <i class="fas fa-trash"></i> Clear Map
                        </button>
                        <button onclick="exportMapAndData()">
                            <i class="fas fa-download"></i> Export Map & Data
                        </button>
                    </div>
                    
                    <!-- Dynamic Legend (shows based on selected layer) -->
                    <div id="column2Legend" style="padding: 10px; background: #f9f9f9; border-radius: 6px; border: 1px solid #ddd; margin-top: 8px; display: none;">
                        <!-- Income Levels Legend -->
                        <div id="column2IncomeLegend" style="display: none;">
                            <strong style="font-size: 0.85rem; color: var(--ncrc-dark-blue);">Income Levels:</strong>
                            <div style="display: flex; flex-direction: column; gap: 6px; margin-top: 6px; font-size: 0.75rem; color: #666;">
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #333333; border: 1px solid #333;"></span>
                                    <span>Low (≤50%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #666666; border: 1px solid #333;"></span>
                                    <span>Moderate (≤80%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #999999; border: 1px solid #333;"></span>
                                    <span>Middle (≤120%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #cccccc; border: 1px solid #333;"></span>
                                    <span>Upper (>120%)</span>
                                </div>
                            </div>
                        </div>
                        <!-- Minority Population Legend -->
                        <div id="column2MinorityLegend" style="display: none;">
                            <strong style="font-size: 0.85rem; color: var(--ncrc-dark-blue);">Minority Population:</strong>
                            <div style="display: flex; flex-direction: column; gap: 6px; margin-top: 6px; font-size: 0.75rem; color: #666;">
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #1a1a1a; border: 1px solid #333;"></span>
                                    <span>Q4 (Highest 25%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #666666; border: 1px solid #333;"></span>
                                    <span>Q3 (50-75%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #999999; border: 1px solid #333;"></span>
                                    <span>Q2 (25-50%)</span>
                                </div>
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: #cccccc; border: 1px solid #333;"></span>
                                    <span>Q1 (Lowest 25%)</span>
                                </div>
                            </div>
                            <div style="margin-top: 4px; font-style: italic; color: #999; font-size: 0.7rem;">
                                Minority = All non-Hispanic White excluded<br>
                                Categories based on quartiles of minority % within county
                            </div>
                        </div>
                    </div>
                    
                    <!-- Banks Selector at Bottom -->
                    <div class="control-group" style="margin-top: 20px;">
                        <label for="bankSelect">
                            <i class="fas fa-university"></i> Banks
                        </label>
                        <div class="bank-select-container">
                            <select id="bankSelect" multiple style="width: 100%;">
                                <option value="all">All Banks</option>
                            </select>
                            <div class="bank-select-help">
                                <small>Click to select/deselect (max 3 banks)</small>
                                <div class="selected-banks-display" id="selectedBanksDisplay"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </aside>
        
        <!-- Main Content -->
        <div class="content-wrapper">
    <div class="mapper-container">
        <!-- Map Controls Header (simplified) -->
        <div class="mapper-controls" style="margin-bottom: 12px;">
            <h2 style="margin-bottom: 10px; color: var(--ncrc-dark-blue); font-size: 1.1rem;">
                <i class="fas fa-map-marked-alt"></i> Branch Location Map
            </h2>
            
            <!-- Data Description -->
            <div class="data-description" style="background: #e6f2ff; padding: 6px 10px; border-radius: 4px; margin-bottom: 10px; border-left: 3px solid var(--ncrc-primary-blue);">
                <p style="margin: 0; color: #333; line-height: 1.4; font-size: 0.8rem;">
                    <strong><i class="fas fa-info-circle"></i> About:</strong> Data from <strong>Summary of Deposits</strong> (June 30, 2025). Use the left sidebar to select state/county and load the map.
                </p>
            </div>
        </div>
        
        <!-- Bank Legend -->
        <div class="bank-legend" id="bankLegend">
            <strong>Bank Colors:</strong>
        </div>
        
        <!-- Map Container -->
        <div class="map-container">
            <div id="branchMap"></div>
        </div>
        
        <!-- Info Panel -->
        <div class="info-panel" id="infoPanel">
            <strong>Instructions:</strong><br>
            • Select a state and county to view 2025 bank branch locations<br>
            • Use the bank selector to filter by specific banks (select up to 3)<br>
            • Click on markers to see branch details<br>
            • Use the "Get Support" button in popups for help via Slack
        </div>
        </div>
        </div>
        
        <!-- Right Info Sidebar -->
    </div>
    
    <!-- Mapbox GL JS -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
    
    <script>
        // Base URL for API calls (handles blueprint prefix)
        const APP_BASE_URL = '{{ app_base_url|default("/branchmapper") }}';

        // Mapbox configuration
        const MAPBOX_TOKEN = '{{ mapbox_token|default("pk.eyJ1IjoiamVkbGViaSIsImEiOiJjanhhc3M4NnYwMmxsM3lyODlxYTFhOGRxIn0.746AmyW45uwRPeUy1PczOg", true) }}';
        const MAPBOX_STYLE = '{{ mapbox_style|default("mapbox://styles/jedlebi/cltg2vre600wz01p02c3jf3h3", true) }}';

        let branchMap = null;
        let currentMarkers = [];
        let allBranches = [];
        let bankColors = {};
        let incomeLayerVisible = false;
        let minorityLayerVisible = false;
        let currentPopup = null;

        // AbortControllers for cancelling in-flight requests
        let incomeLayerAbortController = null;
        let minorityLayerAbortController = null;

        // Cached user type for Slack support routing
        let cachedUserType = null;

        // Fetch user type and open appropriate Slack support channel
        async function openSlackSupport(event) {
            event.preventDefault();

            // Fetch user type if not cached
            if (!cachedUserType) {
                try {
                    const response = await fetch('/api/auth/status');
                    if (response.ok) {
                        const data = await response.json();
                        cachedUserType = data.user_type || 'public_anonymous';
                    } else {
                        cachedUserType = 'public_anonymous';
                    }
                } catch (error) {
                    console.log('Could not fetch user type, defaulting to public');
                    cachedUserType = 'public_anonymous';
                }
            }

            const isInternalUser = ['staff', 'senior_executive', 'admin'].includes(cachedUserType);

            // Staff channel for internal users, public support channel for everyone else
            const slackChannelUrl = isInternalUser
                ? 'https://ncrcgroup.slack.com/app_redirect?channel=C0A0BBWRT36'  // justdata_staff
                : 'https://ncrcgroup.slack.com/app_redirect?channel=C0AAHCK98A0'; // public support

            window.open(slackChannelUrl, '_blank');
        }

        // Color palette for banks (distinct colors)
        const colorPalette = [
            '#1e3a5f', // Standard Navy
            '#e82e2e', // NCRC Red
            '#552d87', // NCRC Purple
            '#2fade3', // NCRC Sky Blue
            '#eb2f89', // NCRC Pink
            '#ffc23a', // NCRC Gold
            '#28a745', // Green
            '#17a2b8', // Teal
            '#6f42c1', // Purple
            '#fd7e14', // Orange
            '#20c997', // Mint
            '#dc3545'  // Red
        ];
        
        // State center coordinates and zoom levels (approximate)
        const stateCenters = {
            '01': { lat: 32.806671, lng: -86.791130, zoom: 7 }, // Alabama
            '04': { lat: 34.048928, lng: -111.093731, zoom: 7 }, // Arizona
            '06': { lat: 36.116203, lng: -119.681564, zoom: 6 }, // California
            '10': { lat: 39.318523, lng: -75.507141, zoom: 8 }, // Delaware
            '12': { lat: 27.766279, lng: -81.686783, zoom: 7 }, // Florida
            '13': { lat: 33.040619, lng: -83.643074, zoom: 7 }, // Georgia
            '17': { lat: 40.349457, lng: -88.986137, zoom: 7 }, // Illinois
            '24': { lat: 39.063946, lng: -76.802101, zoom: 7 }, // Maryland
            '26': { lat: 43.326618, lng: -84.536095, zoom: 7 }, // Michigan
            '36': { lat: 42.165726, lng: -74.948051, zoom: 7 }, // New York
            '39': { lat: 40.388783, lng: -82.764915, zoom: 7 }, // Ohio
            '42': { lat: 40.590752, lng: -77.209755, zoom: 7 }, // Pennsylvania
            '48': { lat: 31.054487, lng: -97.563461, zoom: 6 }, // Texas
            '53': { lat: 47.400902, lng: -121.490494, zoom: 7 }  // Washington
        };
        
        // Initialize map using Mapbox GL JS
        function initMap() {
            if (branchMap) {
                branchMap.remove();
            }
            
            // Set access token
            mapboxgl.accessToken = MAPBOX_TOKEN;
            
            // Create Mapbox GL JS map - centered on continental US
            branchMap = new mapboxgl.Map({
                container: 'branchMap',
                style: MAPBOX_STYLE,
                center: [-96.0, 39.0], // [lng, lat] centered on continental US
                zoom: 3.5 // Show all of continental US in view
            });
            
            // Add navigation controls
            branchMap.addControl(new mapboxgl.NavigationControl(), 'top-right');
            
            // Wait for map to load before adding any layers
            branchMap.on('load', function() {
                console.log('Mapbox GL JS map loaded');
            });
        }
        
        // Helper function to remove a source and its layers
        function removeSourceAndLayers(sourceId) {
            if (!branchMap) return;
            
            // Remove layers first
            const layerIds = [sourceId + '-fill', sourceId + '-outline'];
            layerIds.forEach(function(layerId) {
                if (branchMap.getLayer(layerId)) {
                    branchMap.removeLayer(layerId);
                }
            });
            
            // Then remove source
            if (branchMap.getSource(sourceId)) {
                branchMap.removeSource(sourceId);
            }
        }
        
        // Get gray shade for income category (darker = lower income)
        function getIncomeColor(category) {
            switch(category) {
                case 'Low':
                    return '#333333';      // Dark gray - Low income
                case 'Moderate':
                    return '#666666';     // Medium-dark gray - Moderate income
                case 'Middle':
                    return '#999999';     // Medium gray - Middle income
                case 'Upper':
                    return '#cccccc';     // Light gray - Upper income
                default:
                    return '#e0e0e0';      // Very light gray - Unknown
            }
        }
        
        // Get gray shade for minority category (darker = higher minority percentage quartile)
        function getMinorityColor(category) {
            switch(category) {
                case 'Q4 (Highest 25%)':
                    return '#1a1a1a';      // Very dark gray - Highest quartile
                case 'Q3 (50-75%)':
                    return '#666666';      // Medium-dark gray - Third quartile
                case 'Q2 (25-50%)':
                    return '#999999';      // Medium gray - Second quartile
                case 'Q1 (Lowest 25%)':
                    return '#cccccc';      // Light gray - Lowest quartile
                // Legacy support for old categories
                case 'Very High':
                    return '#1a1a1a';
                case 'High':
                    return '#333333';
                case 'Above Average':
                    return '#666666';
                case 'Average':
                    return '#999999';
                case 'Below Average':
                    return '#cccccc';
                default:
                    return '#e0e0e0';      // Very light gray - Unknown
            }
        }
        
        // Get fill color expression for income layer (Mapbox GL JS style)
        function getIncomeColorExpression() {
            return [
                'match',
                ['get', 'income_category'],
                'Low', '#333333',
                'Moderate', '#666666',
                'Middle', '#999999',
                'Upper', '#cccccc',
                '#e0e0e0' // default
            ];
        }
        
        // Get fill color expression for minority layer (Mapbox GL JS style)
        function getMinorityColorExpression() {
            return [
                'match',
                ['get', 'minority_category'],
                'Q4 (Highest 25%)', '#1a1a1a',
                'Q3 (50-75%)', '#666666',
                'Q2 (25-50%)', '#999999',
                'Q1 (Lowest 25%)', '#cccccc',
                'Very High', '#1a1a1a',
                'High', '#333333',
                'Above Average', '#666666',
                'Average', '#999999',
                'Below Average', '#cccccc',
                '#e0e0e0' // default
            ];
        }
        
        // Load and display income layer using Mapbox GL JS
        async function loadIncomeLayer(county) {
            if (!branchMap) {
                initMap();
                return;
            }

            // Cancel any previous in-flight request
            if (incomeLayerAbortController) {
                incomeLayerAbortController.abort();
            }
            incomeLayerAbortController = new AbortController();
            const signal = incomeLayerAbortController.signal;

            // Remove existing income layer
            removeSourceAndLayers('income-tracts');
            incomeLayerVisible = false;

            try {
                updateInfoPanel('Loading census tract income data...');
                console.log('Loading income layer for county:', county);

                const url = `${APP_BASE_URL}/api/census-tracts/${encodeURIComponent(county)}?income=true&minority=false`;
                console.log('Fetching from URL:', url);

                const response = await fetch(url, { signal });
                console.log('Response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        console.error('API error response:', errorData);
                        errorMessage = errorData.error || errorData.message || errorMessage;
                    } catch (jsonError) {
                        // Response is not JSON, try to get text
                        try {
                            const errorText = await response.text();
                            console.error('API error response (text):', errorText);
                            errorMessage = errorText || errorMessage;
                        } catch (textError) {
                            console.error('Could not parse error response:', textError);
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                let data;
                try {
                    data = await response.json();
                    console.log('API response data:', data);
                } catch (jsonError) {
                    console.error('Failed to parse JSON response:', jsonError);
                    throw new Error('Invalid JSON response from server');
                }
                
                if (!data.success) {
                    console.error('API returned success=false:', data);
                    throw new Error(data.error || data.message || 'Failed to load census tract data');
                }
                
                if (!data.geojson || !data.geojson.features) {
                    console.error('Invalid GeoJSON data:', data);
                    throw new Error('Invalid GeoJSON data received from server');
                }
                
                console.log('Creating GeoJSON layer with', data.geojson.features.length, 'features');
                
                // Add GeoJSON source
                branchMap.addSource('income-tracts', {
                    type: 'geojson',
                    data: data.geojson
                });
                
                // Add fill layer
                branchMap.addLayer({
                    id: 'income-tracts-fill',
                    type: 'fill',
                    source: 'income-tracts',
                    paint: {
                        'fill-color': getIncomeColorExpression(),
                        'fill-opacity': 0.5
                    }
                });
                
                // Add outline layer
                branchMap.addLayer({
                    id: 'income-tracts-outline',
                    type: 'line',
                    source: 'income-tracts',
                    paint: {
                        'line-color': '#666666',
                        'line-width': 1,
                        'line-opacity': 0.6
                    }
                });
                
                incomeLayerVisible = true;
                
                // Add click handler for popups
                branchMap.on('click', 'income-tracts-fill', function(e) {
                    if (!e.features || e.features.length === 0) return;
                    
                    const props = e.features[0].properties;
                    const income = props.median_family_income;
                    const category = props.income_category || 'Unknown';
                    const baselineIncome = props.baseline_median_income || props.cbsa_median_income;
                    const baselineType = props.baseline_type;
                    const ratio = props.income_ratio;
                    
                    const formatIncome = (val) => {
                        if (!val) return 'N/A';
                        return '$' + Math.round(parseFloat(val)).toLocaleString('en-US');
                    };
                    
                    let baselineLabel = 'County Median';
                    if (baselineType === 'state') baselineLabel = 'State Median';
                    else if (baselineType === 'cbsa') baselineLabel = 'Metro Area Median';
                    
                    const popupContent = `
                        <div style="min-width: 200px;">
                            <strong>${props.NAME || 'Census Tract'}</strong><br>
                            <hr style="margin: 8px 0;">
                            <strong>Income Category:</strong> ${category}<br>
                            <strong>Tract Median Family Income:</strong> ${formatIncome(income)}<br>
                            <strong>${baselineLabel}:</strong> ${formatIncome(baselineIncome)}<br>
                            ${ratio ? `<strong>Ratio:</strong> ${parseFloat(ratio).toFixed(2)}x county average<br>` : ''}
                            <hr style="margin: 8px 0;">
                            <small style="color: #666;">
                                Categories: Low (≤50%), Moderate (≤80%), Middle (≤120%), Upper (>120%)
                            </small>
                        </div>
                    `;
                    
                    new mapboxgl.Popup({ maxWidth: '280px' })
                        .setLngLat(e.lngLat)
                        .setHTML(popupContent)
                        .addTo(branchMap);
                });
                
                // Change cursor on hover
                branchMap.on('mouseenter', 'income-tracts-fill', function() {
                    branchMap.getCanvas().style.cursor = 'pointer';
                });
                branchMap.on('mouseleave', 'income-tracts-fill', function() {
                    branchMap.getCanvas().style.cursor = '';
                });
                
                // Fit map to show all tracts
                const bounds = new mapboxgl.LngLatBounds();
                data.geojson.features.forEach(function(feature) {
                    if (feature.geometry.type === 'Polygon') {
                        feature.geometry.coordinates[0].forEach(function(coord) {
                            bounds.extend(coord);
                        });
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        feature.geometry.coordinates.forEach(function(polygon) {
                            polygon[0].forEach(function(coord) {
                                bounds.extend(coord);
                            });
                        });
                    }
                });
                
                if (!bounds.isEmpty()) {
                    branchMap.fitBounds(bounds, { padding: 50 });
                }
                
                console.log('Income layer added to map');
                
                const countyIncome = data.baseline_median_family_income;
                const countyIncomeStr = (countyIncome !== null && countyIncome !== undefined) ? '$' + Math.round(countyIncome).toLocaleString() : 'N/A';
                updateInfoPanel(`Loaded income data for ${data.tract_count} census tracts. County median: ${countyIncomeStr}`);
                
            } catch (error) {
                // Don't show error for aborted requests (user switched counties)
                if (error.name === 'AbortError') {
                    console.log('Income layer request was cancelled');
                    return;
                }
                console.error('Error loading income layer:', error);
                const errorMessage = error.message || error.toString() || 'Unknown error occurred';
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name,
                    error: error
                });
                updateInfoPanel(`Error loading income data: ${errorMessage}`);
            }
        }

        // Load and display minority layer using Mapbox GL JS
        async function loadMinorityLayer(county) {
            if (!branchMap) {
                initMap();
                return;
            }

            // Cancel any previous in-flight request
            if (minorityLayerAbortController) {
                minorityLayerAbortController.abort();
            }
            minorityLayerAbortController = new AbortController();
            const signal = minorityLayerAbortController.signal;

            // Remove existing minority layer
            removeSourceAndLayers('minority-tracts');
            minorityLayerVisible = false;

            try {
                updateInfoPanel('Loading census tract minority population data...');

                const response = await fetch(`${APP_BASE_URL}/api/census-tracts/${encodeURIComponent(county)}?income=false&minority=true`, { signal });
                
                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorData.message || errorMessage;
                    } catch (jsonError) {
                        try {
                            const errorText = await response.text();
                            errorMessage = errorText || errorMessage;
                        } catch (textError) {
                            console.error('Could not parse error response:', textError);
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                let data;
                try {
                    data = await response.json();
                } catch (jsonError) {
                    console.error('Failed to parse JSON response:', jsonError);
                    throw new Error('Invalid JSON response from server');
                }
                
                if (!data.success) {
                    throw new Error(data.error || data.message || 'Failed to load census tract data');
                }
                
                // Add GeoJSON source
                branchMap.addSource('minority-tracts', {
                    type: 'geojson',
                    data: data.geojson
                });
                
                // Add fill layer
                branchMap.addLayer({
                    id: 'minority-tracts-fill',
                    type: 'fill',
                    source: 'minority-tracts',
                    paint: {
                        'fill-color': getMinorityColorExpression(),
                        'fill-opacity': 0.5
                    }
                });
                
                // Add outline layer
                branchMap.addLayer({
                    id: 'minority-tracts-outline',
                    type: 'line',
                    source: 'minority-tracts',
                    paint: {
                        'line-color': '#666666',
                        'line-width': 1,
                        'line-opacity': 0.6
                    }
                });
                
                minorityLayerVisible = true;
                
                // Add click handler for popups
                branchMap.on('click', 'minority-tracts-fill', function(e) {
                    if (!e.features || e.features.length === 0) return;
                    
                    const props = e.features[0].properties;
                    const minorityPct = props.minority_percentage;
                    const category = props.minority_category || 'Unknown';
                    const countyMinorityPct = props.county_minority_percentage;
                    const ratio = props.minority_ratio;
                    const totalPop = props.total_population;
                    const minorityPop = props.minority_population;
                    
                    const formatNumber = (val) => {
                        if (!val && val !== 0) return 'N/A';
                        return Math.round(parseFloat(val)).toLocaleString('en-US');
                    };
                    
                    const formatPercent = (val) => {
                        if (val === null || val === undefined || (val !== 0 && !val)) return 'N/A';
                        try {
                            return parseFloat(val).toFixed(1) + '%';
                        } catch (e) {
                            return 'N/A';
                        }
                    };
                    
                    const popupContent = `
                        <div style="min-width: 200px;">
                            <strong>${props.NAME || 'Census Tract'}</strong><br>
                            <hr style="margin: 8px 0;">
                            <strong>Minority Category:</strong> ${category}<br>
                            <strong>Tract Minority %:</strong> ${formatPercent(minorityPct)}<br>
                            <strong>County Minority %:</strong> ${formatPercent(countyMinorityPct)}<br>
                            ${ratio !== null && ratio !== undefined ? `<strong>Ratio:</strong> ${parseFloat(ratio).toFixed(2)}x county average<br>` : ''}
                            <hr style="margin: 8px 0;">
                            <strong>Total Population:</strong> ${formatNumber(totalPop)}<br>
                            <strong>Minority Population:</strong> ${formatNumber(minorityPop)}<br>
                            <hr style="margin: 8px 0;">
                            <small style="color: #666;">
                                Minority = Non-Hispanic White excluded<br>
                                ${category.startsWith('Q') ? 'Categories based on quartiles of minority % within county' : 'Categories based on ratio to county average'}
                            </small>
                        </div>
                    `;
                    
                    new mapboxgl.Popup({ maxWidth: '280px' })
                        .setLngLat(e.lngLat)
                        .setHTML(popupContent)
                        .addTo(branchMap);
                });
                
                // Change cursor on hover
                branchMap.on('mouseenter', 'minority-tracts-fill', function() {
                    branchMap.getCanvas().style.cursor = 'pointer';
                });
                branchMap.on('mouseleave', 'minority-tracts-fill', function() {
                    branchMap.getCanvas().style.cursor = '';
                });
                
                // Fit map to show all tracts
                const bounds = new mapboxgl.LngLatBounds();
                data.geojson.features.forEach(function(feature) {
                    if (feature.geometry.type === 'Polygon') {
                        feature.geometry.coordinates[0].forEach(function(coord) {
                            bounds.extend(coord);
                        });
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        feature.geometry.coordinates.forEach(function(polygon) {
                            polygon[0].forEach(function(coord) {
                                bounds.extend(coord);
                            });
                        });
                    }
                });
                
                if (!bounds.isEmpty()) {
                    branchMap.fitBounds(bounds, { padding: 50 });
                }
                
                const countyMinorityPct = data.county_minority_percentage;
                const countyMinorityStr = (countyMinorityPct !== null && countyMinorityPct !== undefined) ? countyMinorityPct.toFixed(1) + '%' : 'N/A';
                updateInfoPanel(`Loaded minority data for ${data.tract_count} census tracts. County: ${countyMinorityStr} minority`);
                
            } catch (error) {
                // Don't show error for aborted requests (user switched counties)
                if (error.name === 'AbortError') {
                    console.log('Minority layer request was cancelled');
                    return;
                }
                console.error('Error loading minority layer:', error);
                const errorMessage = error.message || error.toString() || 'Unknown error occurred';
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name,
                    error: error
                });
                updateInfoPanel(`Error loading minority data: ${errorMessage}`);
            }
        }

        // Toggle income layer visibility
        function toggleIncomeLayer(county) {
            if (incomeLayerVisible && branchMap.getLayer('income-tracts-fill')) {
                branchMap.setLayoutProperty('income-tracts-fill', 'visibility', 'none');
                branchMap.setLayoutProperty('income-tracts-outline', 'visibility', 'none');
                incomeLayerVisible = false;
                updateInfoPanel('Income layer hidden');
            } else if (branchMap.getLayer('income-tracts-fill')) {
                branchMap.setLayoutProperty('income-tracts-fill', 'visibility', 'visible');
                branchMap.setLayoutProperty('income-tracts-outline', 'visibility', 'visible');
                incomeLayerVisible = true;
                updateInfoPanel('Income layer shown');
            } else if (county) {
                loadIncomeLayer(county);
            }
        }
        
        // Zoom map to state using Mapbox GL JS
        function zoomToState(stateCode) {
            if (!branchMap) {
                initMap();
                return;
            }
            
            if (stateCenters[stateCode]) {
                const center = stateCenters[stateCode];
                branchMap.flyTo({
                    center: [center.lng, center.lat], // [lng, lat] for Mapbox
                    zoom: center.zoom
                });
                console.log('Zoomed to state:', stateCode, center);
            } else {
                // Default to US center if state not found
                branchMap.flyTo({
                    center: [-96.0, 39.0],
                    zoom: 3.5
                });
            }
        }
        
        // Initialize dropdowns
        async function initializeDropdowns() {
            // Year is fixed to 2025, no dropdown needed
            // Populate state dropdown
            await populateStateDropdown();
            
            // Try to detect user's location from IP
            detectUserLocation();
        }
        
        // Detect user's location - try browser geolocation first, fall back to IP
        async function detectUserLocation() {
            // Try browser geolocation first (more accurate)
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    async (position) => {
                        console.log('Browser geolocation:', position.coords);
                        await reverseGeocodeAndSelect(position.coords.latitude, position.coords.longitude);
                    },
                    async (error) => {
                        console.log('Browser geolocation denied/failed:', error.message);
                        // Fall back to IP-based geolocation
                        await detectLocationFromIP();
                    },
                    { timeout: 5000, enableHighAccuracy: false }
                );
            } else {
                // No browser geolocation, use IP
                await detectLocationFromIP();
            }
        }

        // Reverse geocode lat/long to county using Nominatim
        async function reverseGeocodeAndSelect(lat, lon) {
            try {
                const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&addressdetails=1`;
                const response = await fetch(url, {
                    headers: { 'User-Agent': 'JustData-BranchMapper/1.0' }
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('Reverse geocode result:', data);

                    const address = data.address || {};
                    const county = address.county || address.city || '';
                    const state = address.state || '';

                    if (state && county) {
                        await selectStateAndCounty(state, county);
                    }
                }
            } catch (error) {
                console.log('Reverse geocode failed:', error.message);
                await detectLocationFromIP();
            }
        }

        // IP-based geolocation fallback
        async function detectLocationFromIP() {
            try {
                // ipapi.co provides free geolocation (1000 requests/day free)
                const response = await fetch('https://ipapi.co/json/');

                if (response.ok) {
                    const data = await response.json();
                    console.log('IP location detected:', data);

                    if (data.region && data.county) {
                        await selectStateAndCounty(data.region, data.county);
                    } else if (data.region) {
                        // At least select the state
                        await selectStateAndCounty(data.region, null);
                    }
                }
            } catch (error) {
                console.log('Could not detect location from IP:', error.message);
            }
        }

        // Helper to select state and county in dropdowns
        async function selectStateAndCounty(stateName, countyName) {
            const stateSelect = document.getElementById('stateSelect');

            // Find matching state
            const stateOptions = Array.from(stateSelect.options);
            let matchingState = stateOptions.find(opt => {
                const optText = opt.textContent.trim().toLowerCase();
                return optText === stateName.toLowerCase();
            });

            // Try partial match if no exact match
            if (!matchingState) {
                matchingState = stateOptions.find(opt => {
                    const optText = opt.textContent.trim().toLowerCase();
                    return optText.includes(stateName.toLowerCase()) ||
                           stateName.toLowerCase().includes(optText);
                });
            }

            if (matchingState) {
                stateSelect.value = matchingState.value;
                console.log('Pre-selected state:', matchingState.textContent);

                // Populate counties for this state
                await populateCountyDropdown(matchingState.value);

                // Try to select county if provided
                if (countyName) {
                    const countySelect = document.getElementById('countySelect');

                    // Wait for counties to load
                    setTimeout(() => {
                        const countyOptions = Array.from(countySelect.options);

                        // Try to find matching county (handle "County" suffix variations)
                        const normalizedCounty = countyName.replace(/ County$/i, '').toLowerCase();

                        const matchingCounty = countyOptions.find(opt => {
                            const optText = opt.textContent.trim().toLowerCase();
                            const normalizedOpt = optText.replace(/ county,.*$/i, '');
                            return optText.includes(normalizedCounty) ||
                                   normalizedOpt.includes(normalizedCounty) ||
                                   normalizedCounty.includes(normalizedOpt);
                        });

                        if (matchingCounty) {
                            countySelect.value = matchingCounty.value;
                            console.log('Pre-selected county:', matchingCounty.textContent);
                            // Trigger change event on SELECT element (not option) to zoom map
                            countySelect.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    }, 600);
                }
            }
        }
        
        // Populate state dropdown
        async function populateStateDropdown() {
            const stateSelect = document.getElementById('stateSelect');
            
            // Store reference to original select for event listener
            let originalStateSelect = stateSelect;
            
            // Common US states for testing
            const commonStates = [
                { code: '12', name: 'Florida' },
                { code: '06', name: 'California' },
                { code: '36', name: 'New York' },
                { code: '48', name: 'Texas' },
                { code: '17', name: 'Illinois' },
                { code: '13', name: 'Georgia' },
                { code: '39', name: 'Ohio' },
                { code: '26', name: 'Michigan' },
                { code: '24', name: 'Maryland' },
                { code: '42', name: 'Pennsylvania' },
                { code: '53', name: 'Washington' },
                { code: '04', name: 'Arizona' },
                { code: '01', name: 'Alabama' }
            ];
            
            // Check if we're running on a server (not file://)
            const isServer = window.location.protocol === 'http:' || window.location.protocol === 'https:';
            
            // Add change listener to state dropdown FIRST, before populating options
            // This ensures the listener is always attached
            stateSelect.addEventListener('change', async function() {
                const stateCode = this.value;
                const selectedOption = this.options[this.selectedIndex];
                if (!selectedOption) return;
                
                const stateName = selectedOption.textContent.trim();
                console.log('=== STATE CHANGED ===');
                console.log('State code:', stateCode);
                console.log('State name:', stateName);
                console.log('Selected index:', this.selectedIndex);
                
                // Immediately clear the county dropdown
                const countySelect = document.getElementById('countySelect');
                countySelect.innerHTML = '<option value="">Loading counties...</option>';
                
                // Clear any existing markers
                clearMarkers();
                
                // Zoom map to selected state
                if (stateCode && this.selectedIndex > 0) {
                    zoomToState(stateCode);
                    
                    // Populate counties for the selected state
                    try {
                        await populateCountyDropdown(stateCode);
                        console.log('Counties loaded for state:', stateName);
                    } catch (error) {
                        console.error('Error loading counties:', error);
                        countySelect.innerHTML = '<option value="">Error loading counties</option>';
                    }
                } else {
                    countySelect.innerHTML = '<option value="">Select a state first</option>';
                    // Reset to US view
                    if (branchMap) {
                        branchMap.flyTo({
                            center: [-96.0, 39.0],
                            zoom: 3.5
                        });
                    }
                }
            }, { once: false }); // Allow multiple calls
            
            // Now populate the state options
            // Try to fetch from API if available and on server
            if (isServer) {
                try {
                    const response = await fetch(`${APP_BASE_URL}/states`);
                    if (response.ok) {
                        const states = await response.json();
                        states.forEach(state => {
                            const option = document.createElement('option');
                            option.value = state.code;
                            option.textContent = state.name;
                            // Don't pre-select - let geolocation handle it
                            stateSelect.appendChild(option);
                        });
                        // Don't auto-load counties - wait for geolocation or user selection
                        return;
                    }
                } catch (error) {
                    console.log('API not available, using hardcoded states:', error.message);
                }
            } else {
                console.log('Opening file directly - using hardcoded states. For API access, open via http://127.0.0.1:8080');
            }
            
            // Use hardcoded states (don't pre-select - let geolocation or timeout handle it)
            commonStates.forEach(state => {
                const option = document.createElement('option');
                option.value = state.code;
                option.textContent = state.name;
                stateSelect.appendChild(option);
            });
            
            // Don't auto-select Florida - let geolocation handle it, or user can select manually
            // Only default to Florida if geolocation fails and nothing is selected after a delay
            setTimeout(() => {
                const currentStateSelect = document.getElementById('stateSelect');
                if (currentStateSelect && (currentStateSelect.selectedIndex === 0 || currentStateSelect.value === '')) {
                    // No state selected yet, default to Florida
                    currentStateSelect.value = '12';
                    populateCountyDropdown('12');
                }
            }, 2000); // Wait 2 seconds for geolocation to complete
        }
        
        // Populate county dropdown based on selected state
        async function populateCountyDropdown(stateCode) {
            console.log('=== POPULATE COUNTY DROPDOWN ===');
            console.log('State code received:', stateCode);
            
            const countySelect = document.getElementById('countySelect');
            const stateSelect = document.getElementById('stateSelect');
            
            if (!stateSelect) {
                console.error('State select element not found!');
                return;
            }
            
            // Get state name from dropdown - use the actual selected option
            if (!stateCode || stateSelect.selectedIndex === 0 || stateSelect.value === '' || stateSelect.value !== stateCode) {
                console.warn('Invalid state selection:', {
                    stateCode,
                    selectedIndex: stateSelect.selectedIndex,
                    value: stateSelect.value
                });
                countySelect.innerHTML = '<option value="">Select a state first</option>';
                return;
            }
            
            // Get state name from the currently selected option
            const selectedOption = stateSelect.options[stateSelect.selectedIndex];
            if (!selectedOption) {
                console.error('No selected option found in state dropdown');
                countySelect.innerHTML = '<option value="">Error: No state selected</option>';
                return;
            }
            
            const stateName = selectedOption.textContent.trim();
            console.log('Populating counties for state:', stateCode, stateName);
            console.log('State select value:', stateSelect.value, 'selectedIndex:', stateSelect.selectedIndex);
            
            // Clear the dropdown immediately
            countySelect.innerHTML = '<option value="">Loading counties...</option>';
            
            // Small delay to ensure UI updates
            await new Promise(resolve => setTimeout(resolve, 50));
            
            // Check if we're running on a server (not file://)
            const isServer = window.location.protocol === 'http:' || window.location.protocol === 'https:';
            
            // Try to fetch counties for the specific state (only if on server)
            if (isServer) {
                try {
                    // Use the state-specific endpoint which queries BigQuery directly
                    const response = await fetch(`${APP_BASE_URL}/counties-by-state/${stateCode}`);
                    console.log('Response status:', response.status, response.statusText);
                    
                    if (response.ok) {
                        const stateCounties = await response.json();
                        console.log('Fetched counties for state', stateName, ':', stateCounties.length);
                        
                        // Handle case where API returns error object
                        if (stateCounties.error) {
                            throw new Error(stateCounties.error);
                        }
                        
                        if (stateCounties.length > 0) {
                            console.log('Sample counties:', stateCounties.slice(0, 5));
                        }
                        
                        // Clear and repopulate - IMPORTANT: Clear first!
                        countySelect.innerHTML = '';
                        
                        // Add default option
                        const defaultOption = document.createElement('option');
                        defaultOption.value = '';
                        defaultOption.textContent = 'Select County';
                        countySelect.appendChild(defaultOption);
                        
                        if (stateCounties.length === 0) {
                            const noCountiesOption = document.createElement('option');
                            noCountiesOption.value = '';
                            noCountiesOption.textContent = `No counties found for ${stateName}`;
                            countySelect.appendChild(noCountiesOption);
                            console.warn('No counties found for state:', stateName);
                        } else {
                            stateCounties.forEach(county => {
                                const option = document.createElement('option');
                                option.value = county;
                                option.textContent = county;
                                countySelect.appendChild(option);
                            });
                            console.log('Successfully populated', stateCounties.length, 'counties for', stateName);
                            
                            // Re-setup the county change listener after populating
                            setupCountyChangeListener();
                        }
                        return;
                    } else {
                        // If state-specific endpoint fails, get error details
                        const errorText = await response.text();
                        console.error('State-specific endpoint failed:', response.status, errorText);
                        
                        // Try the general counties endpoint as fallback
                        console.log('Trying general counties endpoint as fallback...');
                        try {
                            const fallbackResponse = await fetch(`${APP_BASE_URL}/counties`);
                            if (fallbackResponse.ok) {
                                const allCounties = await fallbackResponse.json();
                                console.log('Total counties from API:', allCounties.length);
                                console.log('Filtering for state:', stateName);
                                
                                // Filter counties by selected state - must end with ", StateName"
                                const filteredCounties = allCounties.filter(county => {
                                    const countyStr = String(county).trim();
                                    return countyStr.endsWith(`, ${stateName}`);
                                });
                                
                                console.log('Filtered counties for', stateName, ':', filteredCounties.length);
                                
                                // Clear and repopulate
                                countySelect.innerHTML = '<option value="">Select County</option>';
                                
                                if (filteredCounties.length === 0) {
                                    countySelect.innerHTML = '<option value="">No counties found for ' + stateName + '</option>';
                                } else {
                                filteredCounties.forEach(county => {
                                    const option = document.createElement('option');
                                    option.value = county;
                                    option.textContent = county;
                                    countySelect.appendChild(option);
                                });
                                
                                // Re-setup the county change listener after populating
                                setupCountyChangeListener();
                            }
                            return;
                            }
                        } catch (fallbackError) {
                            console.error('Fallback also failed:', fallbackError);
                        }
                    }
                } catch (error) {
                    console.error('Error fetching counties:', error);
                    console.log('API not available, using hardcoded counties:', error.message);
                }
            } else {
                console.log('Opening file directly - using hardcoded counties. For API access, open via http://127.0.0.1:8080');
            }
            
            // Fallback: Use hardcoded counties for Florida only
            // For other states, show message that API is needed
            if (stateCode === '12') {
                const floridaCounties = [
                    'Hillsborough County, Florida',
                    'Miami-Dade County, Florida',
                    'Broward County, Florida',
                    'Orange County, Florida',
                    'Pinellas County, Florida',
                    'Duval County, Florida',
                    'Palm Beach County, Florida'
                ];
                countySelect.innerHTML = '<option value="">Select County</option>';
                floridaCounties.forEach(county => {
                    const option = document.createElement('option');
                    option.value = county;
                    option.textContent = county;
                    countySelect.appendChild(option);
                });
                
                // Re-setup the county change listener after populating
                setupCountyChangeListener();
            } else {
                countySelect.innerHTML = '<option value="">API connection required for this state</option>';
                console.warn('No hardcoded counties for state code:', stateCode);
            }
        }
        
        // Load map data
        async function loadMapData() {
            const county = document.getElementById('countySelect').value;
            const year = 2025; // Fixed to 2025
            
            // Clear existing markers
            clearMarkers();
            
            // Validate selections
            if (!county) {
                alert('Please select a county.');
                return;
            }
            
            let branches = [];
            
            // Check if we're running on a server (not file://)
            const isServer = window.location.protocol === 'http:' || window.location.protocol === 'https:';
            
            if (!isServer) {
                alert('This tool requires the web server to be running.\n\nPlease access it at: http://127.0.0.1:8080/branch-mapper');
                updateInfoPanel('Cannot access API when opening file directly. Please use http://127.0.0.1:8080/branch-mapper');
                return;
            }
            
            // Load from API
            try {
                updateInfoPanel('Loading data from API...');
                const response = await fetch(`${APP_BASE_URL}/api/branches?county=${encodeURIComponent(county)}&year=${year}`);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to load branch data');
                }
                
                branches = data.branches || [];
                
                if (branches.length === 0) {
                    updateInfoPanel(`No branches found for ${county} in ${year}.`);
                    return;
                }
                
                // Log first branch to verify data structure
                if (branches.length > 0) {
                    console.log('Sample branch data from API:', branches[0]);
                }
                
                updateInfoPanel(`Loaded ${branches.length} branches from database for ${county} (2025)`);
            } catch (error) {
                console.error('Error loading from API:', error);
                alert(`Error loading data from API: ${error.message}`);
                updateInfoPanel(`API Error: ${error.message}`);
                return;
            }
            
            // Store all branches
            allBranches = branches;

            // Log analytics event for BranchMapper report
            if (window.JustDataAnalytics && window.JustDataAnalytics.logBranchMapperReport) {
                const state = document.getElementById('stateSelect')?.value || '';
                window.JustDataAnalytics.logBranchMapperReport({
                    state: state,
                    year: String(year),
                    branchCount: branches.length,
                    reportType: 'branch_mapping'
                });
            }

            // Populate bank selector
            populateBankSelector(branches);
            
            // Initialize map if not already done
            if (!branchMap) {
                initMap();
            }
            
            // Add markers based on selection (this will auto-zoom to the county)
            updateMapMarkers();
        }
        
        // Populate bank selector with unique banks
        function populateBankSelector(branches) {
            const bankSelect = document.getElementById('bankSelect');
            
            // Extract all bank names (including duplicates to see raw data)
            const allBankNames = branches.map(b => b.bank_name).filter(Boolean);
            const uniqueBanks = [...new Set(allBankNames)].sort();
            
            // Log for debugging
            console.log('Total branches loaded:', branches.length);
            console.log('Unique banks found:', uniqueBanks.length);
            console.log('All unique bank names:', uniqueBanks);
            
            // Check if "Bank of Tampa" is in the data (case-insensitive)
            const bankOfTampaVariations = allBankNames.filter(name => 
                name && name.toLowerCase().includes('tampa')
            );
            if (bankOfTampaVariations.length > 0) {
                console.log('Banks containing "Tampa":', [...new Set(bankOfTampaVariations)]);
            } else {
                console.warn('No banks containing "Tampa" found in the data');
            }
            
            // Clear existing options (except "All Banks")
            bankSelect.innerHTML = '<option value="all">All Banks</option>';
            
            // Add each bank
            uniqueBanks.forEach(bankName => {
                const option = document.createElement('option');
                option.value = bankName;
                option.textContent = bankName;
                bankSelect.appendChild(option);
            });
            
            // Select "All Banks" by default
            bankSelect.value = 'all';
            updateSelectedBanksDisplay();
            
            // Remove old event listeners by cloning the select
            const newSelect = bankSelect.cloneNode(true);
            bankSelect.parentNode.replaceChild(newSelect, bankSelect);
            
            // Add change listener with max 3 banks validation
            newSelect.addEventListener('change', function(e) {
                const selected = Array.from(this.selectedOptions).map(opt => opt.value);
                
                // If "all" is selected, allow it
                if (selected.includes('all')) {
                    // If "all" is selected with other options, remove others
                    if (selected.length > 1) {
                        // Deselect all except "all"
                        Array.from(this.options).forEach(opt => {
                            if (opt.value !== 'all') opt.selected = false;
                        });
                    }
                    updateSelectedBanksDisplay();
                    updateMapMarkers();
                    return;
                }
                
                // Limit to maximum 3 banks
                if (selected.length > 3) {
                    // Remove the last selected option
                    const lastSelected = selected[selected.length - 1];
                    const options = Array.from(this.options);
                    const lastOption = options.find(opt => opt.value === lastSelected);
                    if (lastOption) {
                        lastOption.selected = false;
                    }
                    
                    // Show popup alert
                    alert('A maximum of 3 banks are allowed.');
                    
                    // Update display and map
                    updateSelectedBanksDisplay();
                    updateMapMarkers();
                    return;
                }
                
                updateSelectedBanksDisplay();
                updateMapMarkers();
            });
        }
        
        // Update the selected banks display
        function updateSelectedBanksDisplay() {
            const bankSelect = document.getElementById('bankSelect');
            const displayDiv = document.getElementById('selectedBanksDisplay');
            const selected = Array.from(bankSelect.selectedOptions).map(opt => opt.value);
            
            displayDiv.innerHTML = '';
            
            if (selected.includes('all') || selected.length === 0) {
                // Don't show anything if "All Banks" is selected
                return;
            }
            
            selected.forEach(bankName => {
                const tag = document.createElement('div');
                tag.className = 'selected-bank-tag';
                tag.innerHTML = `
                    <span>${bankName}</span>
                    <span class="remove-btn" onclick="removeBank('${bankName.replace(/'/g, "\\'")}')">×</span>
                `;
                displayDiv.appendChild(tag);
            });
        }
        
        // Remove a bank from selection
        function removeBank(bankName) {
            const bankSelect = document.getElementById('bankSelect');
            const option = Array.from(bankSelect.options).find(opt => opt.value === bankName);
            if (option) {
                option.selected = false;
                updateSelectedBanksDisplay();
                updateMapMarkers();
            }
        }
        
        // Get selected banks
        function getSelectedBanks() {
            const bankSelect = document.getElementById('bankSelect');
            const selected = Array.from(bankSelect.selectedOptions).map(opt => opt.value);
            
            if (selected.includes('all') || selected.length === 0) {
                return 'all'; // Show all banks
            }
            
            return selected;
        }
        
        // Assign colors to banks
        function assignBankColors(banks) {
            bankColors = {};
            if (banks === 'all') {
                // When "All Banks" is selected, don't assign colors (will use black)
                bankColors = {};
            } else if (banks.length === 1) {
                // When only one bank is selected, use black
                bankColors[banks[0]] = '#000000'; // Black
            } else {
                // When multiple banks are selected, assign different colors
                banks.forEach((bankName, index) => {
                    bankColors[bankName] = colorPalette[index % colorPalette.length];
                });
            }
            
            // Update legend
            updateBankLegend();
        }
        
        // Update bank legend
        function updateBankLegend() {
            const legend = document.getElementById('bankLegend');
            const selectedBanks = getSelectedBanks();

            // Show legend when banks are selected
            if (selectedBanks === 'all' || Object.keys(bankColors).length === 0) {
                legend.classList.remove('active');
                return;
            }

            legend.innerHTML = '<strong>Bank Colors:</strong>';

            Object.entries(bankColors).forEach(([bankName, color]) => {
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-color" style="background: ${color}; border: 1px solid #fff;"></div>
                    <span>${bankName}</span>
                `;
                legend.appendChild(legendItem);
            });

            // Add "Other Banks" grey entry
            const otherItem = document.createElement('div');
            otherItem.className = 'legend-item';
            otherItem.innerHTML = `
                <div class="legend-color" style="background: #cccccc; border: 1px solid #fff; opacity: 0.6;"></div>
                <span>Other Banks</span>
            `;
            legend.appendChild(otherItem);

            legend.classList.add('active');
        }
        
        // Update map markers based on bank selection
        function updateMapMarkers() {
            clearMarkers();

            const selectedBanks = getSelectedBanks();

            // Assign colors to selected banks
            assignBankColors(selectedBanks);

            if (allBranches.length === 0) {
                updateInfoPanel('No branches to display.');
                return;
            }

            // Always show all branches - selected banks get colors, others get grey background
            addMarkersToMap(allBranches);

            const selectedCount = selectedBanks === 'all' ? allBranches.length : allBranches.filter(b => selectedBanks.includes(b.bank_name)).length;
            updateInfoPanel(`Displaying ${allBranches.length} branches${selectedBanks !== 'all' ? ` (${selectedCount} from ${selectedBanks.length} selected bank(s))` : ' from all banks'}`);
        }
        
        // Add markers to map using GeoJSON layers (much faster than HTML markers)
        function addMarkersToMap(branches) {
            // Clear existing layers first
            clearMarkers();

            const selectedBanks = getSelectedBanks();
            const hasSelection = selectedBanks !== 'all';
            const bounds = new mapboxgl.LngLatBounds();
            const features = [];

            // Store branch data for popup lookups
            window.branchDataMap = {};

            branches.forEach(branch => {
                // Parse coordinates - ensure they're numbers
                let lat = branch.latitude;
                let lng = branch.longitude;

                // Handle string or number coordinates
                if (typeof lat === 'string') lat = parseFloat(lat);
                if (typeof lng === 'string') lng = parseFloat(lng);

                // Validate coordinates
                if (isNaN(lat) || isNaN(lng) || lat === 0 || lng === 0) {
                    console.warn('Invalid coordinates for branch:', branch.branch_name, 'lat:', lat, 'lng:', lng);
                    return;
                }

                const bankName = branch.bank_name || 'Unknown';
                const isSelected = !hasSelection || selectedBanks.includes(bankName);

                // Color logic: black by default, colored when bank is selected, grey for unselected
                let markerColor;
                if (!hasSelection) {
                    markerColor = '#000000'; // Black for all when no selection
                } else if (isSelected) {
                    markerColor = bankColors[bankName] || '#000000';
                } else {
                    markerColor = '#cccccc'; // Light grey for unselected
                }

                // Create unique ID for this branch
                const branchId = `${branch.uninumbr || ''}_${lat}_${lng}`;

                // Store branch data for popup
                window.branchDataMap[branchId] = branch;

                // Create GeoJSON feature
                features.push({
                    type: 'Feature',
                    properties: {
                        id: branchId,
                        bank_name: bankName,
                        branch_name: branch.branch_name || 'Branch',
                        color: markerColor,
                        selected: isSelected ? 1 : 0,
                        lmict: branch.lmict ? 1 : 0,
                        mmct: branch.mmct ? 1 : 0
                    },
                    geometry: {
                        type: 'Point',
                        coordinates: [lng, lat]
                    }
                });

                bounds.extend([lng, lat]);
            });

            if (features.length === 0) {
                console.warn('No valid branch features to display');
                return;
            }

            // Add GeoJSON source (no clustering - show individual branches at all zoom levels)
            branchMap.addSource('branch-markers', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: features
                }
            });

            if (hasSelection) {
                // BACKGROUND LAYER: unselected branches (light grey, rendered first / behind)
                branchMap.addLayer({
                    id: 'branch-markers-bg',
                    type: 'circle',
                    source: 'branch-markers',
                    filter: ['==', ['get', 'selected'], 0],
                    paint: {
                        'circle-radius': 5,
                        'circle-color': '#cccccc',
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#ffffff',
                        'circle-opacity': 0.6
                    }
                });
            }

            // FOREGROUND LAYER: selected (or all) branches
            branchMap.addLayer({
                id: 'branch-markers-fill',
                type: 'circle',
                source: 'branch-markers',
                filter: hasSelection ? ['==', ['get', 'selected'], 1] : ['literal', true],
                paint: {
                    'circle-radius': 6,
                    'circle-color': ['get', 'color'],
                    'circle-stroke-width': 1,
                    'circle-stroke-color': '#ffffff'
                }
            });
            
            // Click handler for individual markers - show popup
            branchMap.on('click', 'branch-markers-fill', function(e) {
                if (!e.features || e.features.length === 0) return;
                
                const feature = e.features[0];
                const coords = feature.geometry.coordinates.slice();
                const props = feature.properties;
                const branch = window.branchDataMap[props.id] || {};
                
                // Build popup content
                const tags = [];
                if (branch.lmict) tags.push('<span class="tag lmi">LMI</span>');
                if (branch.mmct) tags.push('<span class="tag minority">Minority</span>');
                
                const formatDeposits = (deposits) => {
                    if (!deposits) return 'N/A';
                    return '$' + Number(deposits).toLocaleString('en-US');
                };
                
                const popupContent = `
                    <div class="popup-content">
                        <div class="bank-name-header">${props.bank_name}</div>
                        <div class="branch-info">
                            <strong>Branch:</strong> ${props.branch_name}<br>
                            ${branch.branch_type ? `<strong>Type:</strong> ${branch.branch_type.length > 25 ? branch.branch_type.substring(0, 25) + '...' : branch.branch_type}<br>` : ''}
                            ${branch.total_deposits ? `<strong>Deposits:</strong> ${formatDeposits(branch.total_deposits)}<br>` : ''}
                            <strong>Address:</strong> ${branch.address || ''}<br>
                            ${branch.city || ''}, ${branch.state_abbrv || branch.state || ''} ${branch.zip || ''}
                        </div>
                        ${tags.length > 0 ? `<div class="branch-tags">${tags.join('')}</div>` : ''}
                        <a href="#" class="report-problem-btn" onclick="openSlackSupport(event)">
                            <i class="fab fa-slack"></i> Get Support
                        </a>
                    </div>
                `;
                
                // Close existing popup
                if (currentPopup) currentPopup.remove();
                
                currentPopup = new mapboxgl.Popup({ maxWidth: '300px' })
                    .setLngLat(coords)
                    .setHTML(popupContent)
                    .addTo(branchMap);
            });
            
            // Change cursor on hover for both layers
            ['branch-markers-fill', 'branch-markers-bg'].forEach(layerId => {
                branchMap.on('mouseenter', layerId, function() {
                    branchMap.getCanvas().style.cursor = 'pointer';
                });
                branchMap.on('mouseleave', layerId, function() {
                    branchMap.getCanvas().style.cursor = '';
                });
            });

            // Click handler for background (unselected) markers - same popup
            branchMap.on('click', 'branch-markers-bg', function(e) {
                if (!e.features || e.features.length === 0) return;
                const feature = e.features[0];
                const coords = feature.geometry.coordinates.slice();
                const props = feature.properties;
                const branch = window.branchDataMap[props.id] || {};
                const tags = [];
                if (branch.lmict) tags.push('<span class="tag lmi">LMI</span>');
                if (branch.mmct) tags.push('<span class="tag minority">Minority</span>');
                const formatDeposits = (deposits) => {
                    if (!deposits) return 'N/A';
                    return '$' + Number(deposits).toLocaleString('en-US');
                };
                const popupContent = `
                    <div class="popup-content">
                        <div class="bank-name-header">${props.bank_name}</div>
                        <div class="branch-info">
                            <strong>Branch:</strong> ${props.branch_name}<br>
                            ${branch.branch_type ? `<strong>Type:</strong> ${branch.branch_type.length > 25 ? branch.branch_type.substring(0, 25) + '...' : branch.branch_type}<br>` : ''}
                            ${branch.total_deposits ? `<strong>Deposits:</strong> ${formatDeposits(branch.total_deposits)}<br>` : ''}
                            <strong>Address:</strong> ${branch.address || ''}<br>
                            ${branch.city || ''}, ${branch.state_abbrv || branch.state || ''} ${branch.zip || ''}
                        </div>
                        ${tags.length > 0 ? `<div class="branch-tags">${tags.join('')}</div>` : ''}
                        <a href="#" class="report-problem-btn" onclick="openSlackSupport(event)">
                            <i class="fab fa-slack"></i> Get Support
                        </a>
                    </div>
                `;
                if (currentPopup) currentPopup.remove();
                currentPopup = new mapboxgl.Popup({ maxWidth: '300px' })
                    .setLngLat(coords)
                    .setHTML(popupContent)
                    .addTo(branchMap);
            });
            
            // Fit map to show all markers
            if (!bounds.isEmpty()) {
                branchMap.fitBounds(bounds, { padding: 50 });
                console.log('Map zoomed to fit', features.length, 'markers');
            } else {
                console.warn('No markers to zoom to');
            }
        }
        
        // Clear markers (remove GeoJSON layers and source)
        function clearMarkers() {
            const layerIds = ['branch-markers-bg', 'branch-markers-fill'];
            layerIds.forEach(id => {
                if (branchMap.getLayer(id)) branchMap.removeLayer(id);
            });
            if (branchMap.getSource('branch-markers')) branchMap.removeSource('branch-markers');
            if (currentPopup) {
                currentPopup.remove();
                currentPopup = null;
            }
        }
        
        // Handle census layer dropdown change
        function handleCensusLayerChange() {
            const dropdown = document.getElementById('censusLayerSelect');
            const selectedValue = dropdown.value;
            const county = document.getElementById('countySelect').value;
            
            // Column 2 legend elements
            const column2Legend = document.getElementById('column2Legend');
            const column2IncomeLegend = document.getElementById('column2IncomeLegend');
            const column2MinorityLegend = document.getElementById('column2MinorityLegend');
            
            // Remove any existing layers
            removeSourceAndLayers('income-tracts');
            removeSourceAndLayers('minority-tracts');
            incomeLayerVisible = false;
            minorityLayerVisible = false;
            
            // Hide column 2 legend by default
            column2Legend.style.display = 'none';
            column2IncomeLegend.style.display = 'none';
            column2MinorityLegend.style.display = 'none';
            
            if (!selectedValue || selectedValue === '') {
                // No layer selected
                return;
            }
            
            if (!county) {
                alert('Please select a county first');
                dropdown.value = '';
                return;
            }
            
            if (selectedValue === 'income') {
                // Show income legend in column 2
                column2Legend.style.display = 'block';
                column2IncomeLegend.style.display = 'block';
                loadIncomeLayer(county);
            } else if (selectedValue === 'minority') {
                // Show minority legend in column 2
                column2Legend.style.display = 'block';
                column2MinorityLegend.style.display = 'block';
                loadMinorityLayer(county);
            }
        }
        
        // Clear map
        function clearMap() {
            clearMarkers();
            allBranches = [];
            bankColors = {};
            document.getElementById('bankSelect').innerHTML = '<option value="all">All Banks</option>';
            document.getElementById('bankSelect').value = 'all';
            updateSelectedBanksDisplay();
            document.getElementById('bankLegend').classList.remove('active');
            
            // Remove census tract layers
            if (branchMap) {
                removeSourceAndLayers('income-tracts');
                removeSourceAndLayers('minority-tracts');
            }
            incomeLayerVisible = false;
            minorityLayerVisible = false;
            
            // Reset dropdown and hide legend
            const censusLayerSelect = document.getElementById('censusLayerSelect');
            if (censusLayerSelect) {
                censusLayerSelect.value = '';
            }
            const column2Legend = document.getElementById('column2Legend');
            if (column2Legend) {
                column2Legend.style.display = 'none';
            }
            const column2IncomeLegend = document.getElementById('column2IncomeLegend');
            if (column2IncomeLegend) {
                column2IncomeLegend.style.display = 'none';
            }
            const column2MinorityLegend = document.getElementById('column2MinorityLegend');
            if (column2MinorityLegend) {
                column2MinorityLegend.style.display = 'none';
            }
            
            if (branchMap) {
                branchMap.flyTo({
                    center: [-96.0, 39.0],
                    zoom: 3.5
                });
            }
            updateInfoPanel('Map cleared. Select a county to load 2025 branch data.');
        }
        
        // Format deposits for display
        function formatDeposits(deposits) {
            if (!deposits && deposits !== 0) return 'N/A';
            return '$' + deposits.toLocaleString('en-US');
        }
        
        // Export map and data
        async function exportMapAndData() {
            if (!branchMap || allBranches.length === 0) {
                alert('Please load a map with branch data first.');
                return;
            }
            
            try {
                updateInfoPanel('Exporting map and data...');
                
                // Get current selections
                const state = document.getElementById('stateSelect').selectedOptions[0]?.text || 'Unknown';
                const county = document.getElementById('countySelect').selectedOptions[0]?.text || 'Unknown';
                const censusLayer = document.getElementById('censusLayerSelect').value;
                
                // Create filename prefix
                const countySlug = county.replace(/[^a-zA-Z0-9]/g, '_');
                const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const filenamePrefix = `BranchMapper_${countySlug}_${timestamp}`;
                
                // 1. Capture map as image
                const mapContainer = document.getElementById('branchMap');
                const mapCanvas = await html2canvas(mapContainer, {
                    backgroundColor: '#ffffff',
                    useCORS: true,
                    logging: false,
                    scale: 2 // Higher quality
                });
                
                // Convert canvas to blob
                const mapBlob = await new Promise(resolve => {
                    mapCanvas.toBlob(resolve, 'image/png', 1.0);
                });
                
                // 2. Create CSV with branch data
                const csvRows = [];
                
                // CSV Header
                const headers = [
                    'Bank Name',
                    'Branch Name',
                    'Branch Type',
                    'Address',
                    'City',
                    'State',
                    'ZIP',
                    'Latitude',
                    'Longitude',
                    'Total Deposits',
                    'LMI Branch',
                    'Minority Branch'
                ];
                csvRows.push(headers.join(','));
                
                // Format deposits - they're stored in thousands, so multiply by 1000 and format
                function formatDepositsForExport(deposits) {
                    if (!deposits && deposits !== 0) return '';
                    // Deposits are in thousands, convert to actual amount
                    const amount = deposits * 1000;
                    // Format with commas and dollar sign
                    return '$' + amount.toLocaleString('en-US');
                }
                
                // Deduplicate branches - use a combination of bank_name, branch_name, and coordinates as unique key
                const seenBranches = new Set();
                const uniqueBranches = [];
                
                allBranches.forEach(branch => {
                    // Create a unique key from bank name, branch name, and coordinates
                    const branchKey = [
                        (branch.bank_name || '').toLowerCase().trim(),
                        (branch.branch_name || '').toLowerCase().trim(),
                        branch.latitude || '',
                        branch.longitude || ''
                    ].join('|');
                    
                    if (!seenBranches.has(branchKey)) {
                        seenBranches.add(branchKey);
                        uniqueBranches.push(branch);
                    }
                });
                
                console.log(`Export: ${allBranches.length} total branches, ${uniqueBranches.length} unique branches`);
                
                // Add branch data rows
                uniqueBranches.forEach(branch => {
                    // Format deposits and ensure it's properly escaped for CSV
                    const depositsFormatted = branch.total_deposits ? formatDepositsForExport(branch.total_deposits) : '';
                    
                    const row = [
                        escapeCSV(branch.bank_name || ''),
                        escapeCSV(branch.branch_name || ''),
                        escapeCSV(branch.branch_type || ''),
                        escapeCSV(branch.address || ''),
                        escapeCSV(branch.city || ''),
                        escapeCSV(branch.state_abbrv || branch.state || ''),
                        escapeCSV(branch.zip || ''),
                        branch.latitude ? String(branch.latitude) : '',
                        branch.longitude ? String(branch.longitude) : '',
                        escapeCSV(depositsFormatted), // Properly escape the formatted deposit value
                        branch.lmict ? 'Yes' : 'No',
                        branch.mmct ? 'Yes' : 'No'
                    ];
                    csvRows.push(row.join(','));
                });
                
                const csvContent = csvRows.join('\n');
                const csvBlob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                
                // 3. Create ZIP file
                const zip = new JSZip();
                zip.file(`${filenamePrefix}_map.png`, mapBlob);
                zip.file(`${filenamePrefix}_branches.csv`, csvBlob);
                
                // Add metadata file
                const metadata = {
                    export_date: new Date().toISOString(),
                    state: state,
                    county: county,
                    census_layer: censusLayer || 'None',
                    total_branches: allBranches.length,
                    selected_banks: getSelectedBanks() === 'all' ? 'All Banks' : getSelectedBanks().join(', ')
                };
                zip.file(`${filenamePrefix}_metadata.json`, JSON.stringify(metadata, null, 2));
                
                // Generate ZIP
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                
                // Download
                saveAs(zipBlob, `${filenamePrefix}.zip`);
                
                updateInfoPanel(`Export complete! Downloaded ${filenamePrefix}.zip`);
                
            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting map and data: ' + error.message);
                updateInfoPanel('Export failed. Please try again.');
            }
        }
        
        // Helper function to escape CSV values
        function escapeCSV(value) {
            if (value === null || value === undefined) return '';
            const stringValue = String(value);
            // If value contains comma, quote, or newline, wrap in quotes and escape quotes
            if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                return '"' + stringValue.replace(/"/g, '""') + '"';
            }
            return stringValue;
        }
        
        // Update info panel
        function updateInfoPanel(message) {
            const panel = document.getElementById('infoPanel');
            panel.innerHTML = `<strong>Status:</strong> ${message}`;
        }
        
        // Geocode county name to get approximate center coordinates
        async function geocodeCounty(countyName) {
            try {
                // Use Nominatim (OpenStreetMap geocoding) - free and no API key required
                const encodedCounty = encodeURIComponent(countyName);
                const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodedCounty}&format=json&limit=1`, {
                    headers: {
                        'User-Agent': 'BranchMapper/1.0' // Required by Nominatim
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data && data.length > 0) {
                        const lat = parseFloat(data[0].lat);
                        const lon = parseFloat(data[0].lon);
                        console.log('Geocoded county:', countyName, 'to:', lat, lon);
                        return { lat, lon };
                    }
                }
            } catch (error) {
                console.log('Geocoding failed:', error);
            }
            return null;
        }
        
        // Zoom map to county using Mapbox GL JS
        async function zoomToCounty(countyName) {
            if (!branchMap) {
                initMap();
                return;
            }
            
            console.log('Zooming to county:', countyName);
            
            // Try to geocode the county
            const coords = await geocodeCounty(countyName);
            if (coords) {
                // Zoom to county center with appropriate zoom level - Mapbox uses [lng, lat]
                branchMap.flyTo({
                    center: [coords.lon, coords.lat],
                    zoom: 11
                });
                console.log('Zoomed to county:', countyName);
            } else {
                console.warn('Could not geocode county, keeping current view');
            }
        }
        
        // Add change listener to county dropdown for auto-zoom
        function setupCountyChangeListener() {
            const countySelect = document.getElementById('countySelect');
            if (!countySelect) return;
            
            // Remove old listener by cloning
            const newCountySelect = countySelect.cloneNode(true);
            countySelect.parentNode.replaceChild(newCountySelect, countySelect);
            
            newCountySelect.addEventListener('change', async function() {
                const county = this.value;
                if (county && this.selectedIndex > 0) {
                    console.log('County selected:', county);
                    // Zoom to the selected county
                    await zoomToCounty(county);
                    
                    // If a layer is enabled, reload it for the new county (only one can be active)
                    const incomeToggle = document.getElementById('incomeLayerToggle');
                    const minorityToggle = document.getElementById('minorityLayerToggle');
                    
                    if (incomeToggle && incomeToggle.checked) {
                        loadIncomeLayer(county);
                    } else if (minorityToggle && minorityToggle.checked) {
                        loadMinorityLayer(county);
                    }
                } else {
                    // If county is deselected, zoom back to state view
                    const stateSelect = document.getElementById('stateSelect');
                    if (stateSelect && stateSelect.value) {
                        zoomToState(stateSelect.value);
                    }
                    
                    // Remove layers
                    if (branchMap) {
                        removeSourceAndLayers('income-tracts');
                        removeSourceAndLayers('minority-tracts');
                    }
                    incomeLayerVisible = false;
                    minorityLayerVisible = false;
                    
                    const incomeToggle = document.getElementById('incomeLayerToggle');
                    if (incomeToggle) {
                        incomeToggle.checked = false;
                    }
                    const minorityToggle = document.getElementById('minorityLayerToggle');
                    if (minorityToggle) {
                        minorityToggle.checked = false;
                    }
                }
            });
        }
        
        // Setup HTML tooltips for feature cards
        function setupFeatureCardTooltips() {
            const featureCards = document.querySelectorAll('.sidebar .feature-card[data-tooltip]');
            featureCards.forEach(card => {
                const tooltipText = card.getAttribute('data-tooltip');
                if (!tooltipText) return;
                
                // Create tooltip element
                const tooltip = document.createElement('div');
                tooltip.className = 'feature-card-tooltip';
                tooltip.innerHTML = tooltipText;
                tooltip.style.cssText = `
                    position: absolute;
                    right: calc(100% + 15px);
                    top: 50%;
                    transform: translateY(-50%);
                    background: white;
                    color: black;
                    padding: 12px 16px;
                    border-radius: 8px;
                    font-size: 0.9rem;
                    line-height: 1.5;
                    min-width: 250px;
                    max-width: 350px;
                    width: fit-content;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                    opacity: 0;
                    visibility: hidden;
                    pointer-events: none;
                    transition: opacity 0.2s ease, visibility 0.2s ease;
                    z-index: 100000;
                    text-align: left;
                    word-wrap: break-word;
                    border: 2px solid black;
                    box-sizing: border-box;
                `;
                
                // Create arrow
                const arrow = document.createElement('div');
                arrow.style.cssText = `
                    position: absolute;
                    right: -8px;
                    top: 50%;
                    transform: translateY(-50%);
                    width: 0;
                    height: 0;
                    border-top: 6px solid transparent;
                    border-bottom: 6px solid transparent;
                    border-left: 6px solid white;
                    z-index: 1;
                `;
                
                // Create arrow border
                const arrowBorder = document.createElement('div');
                arrowBorder.style.cssText = `
                    position: absolute;
                    right: -8px;
                    top: 50%;
                    transform: translateY(-50%);
                    width: 0;
                    height: 0;
                    border-top: 7px solid transparent;
                    border-bottom: 7px solid transparent;
                    border-left: 7px solid black;
                    z-index: 0;
                `;
                tooltip.appendChild(arrowBorder);
                tooltip.appendChild(arrow);
                
                card.appendChild(tooltip);
                
                // Show/hide on hover
                card.addEventListener('mouseenter', function() {
                    tooltip.style.opacity = '1';
                    tooltip.style.visibility = 'visible';
                });
                
                card.addEventListener('mouseleave', function() {
                    tooltip.style.opacity = '0';
                    tooltip.style.visibility = 'hidden';
                });
            });
        }
        
        // Initialize map on page load
        window.addEventListener('DOMContentLoaded', function() {
            setupFeatureCardTooltips();
            initMap();
            initializeDropdowns();
            setupCountyChangeListener();
            
            // Setup census layer dropdown handler
            const censusLayerSelect = document.getElementById('censusLayerSelect');
            if (censusLayerSelect) {
                censusLayerSelect.addEventListener('change', handleCensusLayerChange);
            }
            
            updateInfoPanel('Map initialized. Select state and county, then click "Load Map" to view 2025 branch data.');
        });
    </script>

    <!-- Shared Footer -->
    {% set app_name = "BranchMapper" %}
    {% include "shared_footer.html" %}

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-analytics-compat.js"></script>

    <!-- JustData Auth -->
    <script src="/static/js/auth.js"></script>

    <!-- JustData Analytics Event Logging -->
    <script src="/static/js/analytics-events.js"></script>

    {% include 'shared_header_js.html' %}
</body>
</html>

